[
  {
    "function_name": "ext3_change_inode_journal_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3522-3573",
    "snippet": "int ext3_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT3_JOURNAL(inode);\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\n\tjournal_lock_updates(journal);\n\tjournal_flush(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\tEXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;\n\telse\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;\n\text3_set_aops(inode);\n\n\tjournal_unlock_updates(journal);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext3_journal_start(inode, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\thandle->h_sync = 1;\n\text3_journal_stop(handle);\n\text3_std_error(inode->i_sb, err);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "1"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_aops",
          "args": [
            "inode"
          ],
          "line": 3557
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1979-1987",
          "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 3556
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "journal"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 3542
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 3539
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nint ext3_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT3_JOURNAL(inode);\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\n\tjournal_lock_updates(journal);\n\tjournal_flush(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\tEXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;\n\telse\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;\n\text3_set_aops(inode);\n\n\tjournal_unlock_updates(journal);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext3_journal_start(inode, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\thandle->h_sync = 1;\n\text3_journal_stop(handle);\n\text3_std_error(inode->i_sb, err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_pin_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3501-3519",
    "snippet": "static int ext3_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t  iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 3514
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "iloc.bh"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_write_access",
          "args": [
            "handle",
            "iloc.bh"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1206-1228",
          "snippet": "static int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "iloc.bh",
            "\"get_write_access\""
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2805-2810",
          "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t  iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3470-3491",
    "snippet": "void ext3_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *current_handle = ext3_journal_current_handle();\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(inode, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\tif (current_handle &&\n\t\tcurrent_handle->h_transaction != handle->h_transaction) {\n\t\t/* This task has a transaction open against a different fs */\n\t\tprintk(KERN_EMERG \"%s: transactions do not match!\\n\",\n\t\t       __func__);\n\t} else {\n\t\tjbd_debug(5, \"marking dirty.  outer handle=%p\\n\",\n\t\t\t\tcurrent_handle);\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\text3_journal_stop(handle);\nout:\n\treturn;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"marking dirty.  outer handle=%p\\n\"",
            "current_handle"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"%s: transactions do not match!\\n\"",
            "__func__"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "2"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *current_handle = ext3_journal_current_handle();\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(inode, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\tif (current_handle &&\n\t\tcurrent_handle->h_transaction != handle->h_transaction) {\n\t\t/* This task has a transaction open against a different fs */\n\t\tprintk(KERN_EMERG \"%s: transactions do not match!\\n\",\n\t\t       __func__);\n\t} else {\n\t\tjbd_debug(5, \"marking dirty.  outer handle=%p\\n\",\n\t\t\t\tcurrent_handle);\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\text3_journal_stop(handle);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "ext3_mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3443-3454",
    "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_mark_inode_dirty",
          "args": [
            "inode",
            "_RET_IP_"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_reserve_inode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3410-3428",
    "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc->bh"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "iloc->bh"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "iloc->bh",
            "\"get_write_access\""
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_loc",
          "args": [
            "inode",
            "iloc"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2805-2810",
          "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_mark_iloc_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3391-3403",
    "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "iloc->bh"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_do_update_inode",
          "args": [
            "handle",
            "inode",
            "iloc"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_do_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3032-3166",
          "snippet": "static int ext3_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc)\n{\n\tstruct ext3_inode *raw_inode = ext3_raw_inode(iloc);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tint err = 0, rc, block;\n\tint need_datasync = 0;\n\t__le32 disksize;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\nagain:\n\t/* we can't allow multiple procs in here at once, its a bit racey */\n\tlock_buffer(bh);\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\n\text3_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif(!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif(!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low =\n\t\t\tcpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low =\n\t\t\tcpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\tdisksize = cpu_to_le32(ei->i_disksize);\n\tif (disksize != raw_inode->i_size) {\n\t\tneed_datasync = 1;\n\t\traw_inode->i_size = disksize;\n\t}\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n#ifdef EXT3_FRAGMENTS\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n#endif\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\t} else {\n\t\tdisksize = cpu_to_le32(ei->i_disksize >> 32);\n\t\tif (disksize != raw_inode->i_size_high) {\n\t\t\traw_inode->i_size_high = disksize;\n\t\t\tneed_datasync = 1;\n\t\t}\n\t\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\t\t\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT3_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT3_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_brelse;\n\n\t\t\t\text3_update_dynamic_rev(sb);\n\t\t\t\tEXT3_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\thandle->h_sync = 1;\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\t/* get our lock and start over */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\traw_inode->i_block[block] = ei->i_data[block];\n\n\tif (ei->i_extra_isize)\n\t\traw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);\n\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\tunlock_buffer(bh);\n\trc = ext3_journal_dirty_metadata(handle, bh);\n\tif (!err)\n\t\terr = rc;\n\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\n\tatomic_set(&ei->i_sync_tid, handle->h_transaction->t_tid);\n\tif (need_datasync)\n\t\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\nout_brelse:\n\tbrelse (bh);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc)\n{\n\tstruct ext3_inode *raw_inode = ext3_raw_inode(iloc);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tint err = 0, rc, block;\n\tint need_datasync = 0;\n\t__le32 disksize;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\nagain:\n\t/* we can't allow multiple procs in here at once, its a bit racey */\n\tlock_buffer(bh);\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\n\text3_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif(!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif(!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low =\n\t\t\tcpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low =\n\t\t\tcpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\tdisksize = cpu_to_le32(ei->i_disksize);\n\tif (disksize != raw_inode->i_size) {\n\t\tneed_datasync = 1;\n\t\traw_inode->i_size = disksize;\n\t}\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n#ifdef EXT3_FRAGMENTS\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n#endif\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\t} else {\n\t\tdisksize = cpu_to_le32(ei->i_disksize >> 32);\n\t\tif (disksize != raw_inode->i_size_high) {\n\t\t\traw_inode->i_size_high = disksize;\n\t\t\tneed_datasync = 1;\n\t\t}\n\t\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\t\t\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT3_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT3_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_brelse;\n\n\t\t\t\text3_update_dynamic_rev(sb);\n\t\t\t\tEXT3_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\thandle->h_sync = 1;\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\t/* get our lock and start over */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\traw_inode->i_block[block] = ei->i_data[block];\n\n\tif (ei->i_extra_isize)\n\t\traw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);\n\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\tunlock_buffer(bh);\n\trc = ext3_journal_dirty_metadata(handle, bh);\n\tif (!err)\n\t\terr = rc;\n\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\n\tatomic_set(&ei->i_sync_tid, handle->h_transaction->t_tid);\n\tif (need_datasync)\n\t\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\nout_brelse:\n\tbrelse (bh);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "iloc->bh"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_writepage_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3367-3385",
    "snippet": "static int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_blocks_per_page",
          "args": [
            "inode"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_blocks_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1286-1289",
          "snippet": "static inline int ext3_journal_blocks_per_page(struct inode *inode)\n{\n\treturn journal_blocks_per_page(inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_journal_blocks_per_page(struct inode *inode)\n{\n\treturn journal_blocks_per_page(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3241-3337",
    "snippet": "int ext3_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error, rc = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext3_journal_start(inode, EXT3_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)+\n\t\t\t\t\tEXT3_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)+3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text3_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext3_mark_inode_dirty(handle, inode);\n\t\text3_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tinode_dio_wait(inode);\n\n\tif (S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid & ATTR_SIZE && attr->ia_size < inode->i_size) {\n\t\thandle_t *handle;\n\n\t\thandle = ext3_journal_start(inode, 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terror = ext3_orphan_add(handle, inode);\n\t\tif (error) {\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\tEXT3_I(inode)->i_disksize = attr->ia_size;\n\t\terror = ext3_mark_inode_dirty(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tif (error) {\n\t\t\t/* Some hard fs error must have happened. Bail out. */\n\t\t\text3_orphan_del(NULL, inode);\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = ext3_block_truncate_page(inode, attr->ia_size);\n\t\tif (rc) {\n\t\t\t/* Cleanup orphan list and exit */\n\t\t\thandle = ext3_journal_start(inode, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\text3_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\text3_orphan_del(handle, inode);\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\text3_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (ia_valid & ATTR_MODE)\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text3_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "error"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_truncate",
          "args": [
            "inode"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2493-2645",
          "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "3"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_block_truncate_page",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1995-2093",
          "snippet": "static int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_transfer",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1933-1950",
          "snippet": "int dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_DEL_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "inode->i_uid"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_quota_modification",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error, rc = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext3_journal_start(inode, EXT3_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)+\n\t\t\t\t\tEXT3_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)+3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text3_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext3_mark_inode_dirty(handle, inode);\n\t\text3_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tinode_dio_wait(inode);\n\n\tif (S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid & ATTR_SIZE && attr->ia_size < inode->i_size) {\n\t\thandle_t *handle;\n\n\t\thandle = ext3_journal_start(inode, 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terror = ext3_orphan_add(handle, inode);\n\t\tif (error) {\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\tEXT3_I(inode)->i_disksize = attr->ia_size;\n\t\terror = ext3_mark_inode_dirty(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tif (error) {\n\t\t\t/* Some hard fs error must have happened. Bail out. */\n\t\t\text3_orphan_del(NULL, inode);\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = ext3_block_truncate_page(inode, attr->ia_size);\n\t\tif (rc) {\n\t\t\t/* Cleanup orphan list and exit */\n\t\t\thandle = ext3_journal_start(inode, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\text3_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\text3_orphan_del(handle, inode);\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\text3_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (ia_valid & ATTR_MODE)\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text3_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3202-3222",
    "snippet": "int ext3_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (ext3_journal_current_handle()) {\n\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\tdump_stack();\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t * ext3_sync_fs() will force the commit after everything is\n\t * written.\n\t */\n\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\treturn 0;\n\n\treturn ext3_force_commit(inode->i_sb);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_force_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2563-2574",
          "snippet": "int ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nint ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"called recursively, non-PF_MEMALLOC!\\n\""
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->flags & PF_MEMALLOC"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (ext3_journal_current_handle()) {\n\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\tdump_stack();\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t * ext3_sync_fs() will force the commit after everything is\n\t * written.\n\t */\n\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\treturn 0;\n\n\treturn ext3_force_commit(inode->i_sb);\n}"
  },
  {
    "function_name": "ext3_do_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "3032-3166",
    "snippet": "static int ext3_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc)\n{\n\tstruct ext3_inode *raw_inode = ext3_raw_inode(iloc);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tint err = 0, rc, block;\n\tint need_datasync = 0;\n\t__le32 disksize;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\nagain:\n\t/* we can't allow multiple procs in here at once, its a bit racey */\n\tlock_buffer(bh);\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\n\text3_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif(!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif(!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low =\n\t\t\tcpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low =\n\t\t\tcpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\tdisksize = cpu_to_le32(ei->i_disksize);\n\tif (disksize != raw_inode->i_size) {\n\t\tneed_datasync = 1;\n\t\traw_inode->i_size = disksize;\n\t}\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n#ifdef EXT3_FRAGMENTS\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n#endif\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\t} else {\n\t\tdisksize = cpu_to_le32(ei->i_disksize >> 32);\n\t\tif (disksize != raw_inode->i_size_high) {\n\t\t\traw_inode->i_size_high = disksize;\n\t\t\tneed_datasync = 1;\n\t\t}\n\t\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\t\t\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT3_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT3_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_brelse;\n\n\t\t\t\text3_update_dynamic_rev(sb);\n\t\t\t\tEXT3_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\thandle->h_sync = 1;\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\t/* get our lock and start over */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\traw_inode->i_block[block] = ei->i_data[block];\n\n\tif (ei->i_extra_isize)\n\t\traw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);\n\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\tunlock_buffer(bh);\n\trc = ext3_journal_dirty_metadata(handle, bh);\n\tif (!err)\n\t\terr = rc;\n\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\n\tatomic_set(&ei->i_sync_tid, handle->h_transaction->t_tid);\n\tif (need_datasync)\n\t\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\nout_brelse:\n\tbrelse (bh);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_datasync_tid",
            "handle->h_transaction->t_tid"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_sync_tid",
            "handle->h_transaction->t_tid"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_clear_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_NEW"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "727-730",
          "snippet": "static inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ei->i_extra_isize"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_encode_dev(inode->i_rdev)"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SET_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "329-352",
          "snippet": "void ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_GOOD_OLD_REV"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_disksize >> 32"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_dir_acl"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_file_acl"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_faddr"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_flags"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_dtime"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_blocks"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_disksize"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowgid(i_gid)"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowgid",
          "args": [
            "i_gid"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowuid(i_uid)"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowuid",
          "args": [
            "i_uid"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(i_gid)"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "i_gid"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(i_uid)"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "i_uid"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(i_gid)"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "i_gid"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(i_uid)"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "i_uid"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_UID32"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2830-2846",
          "snippet": "void ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nvoid ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "EXT3_SB(inode->i_sb)->s_inode_size"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_NEW"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc)\n{\n\tstruct ext3_inode *raw_inode = ext3_raw_inode(iloc);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tint err = 0, rc, block;\n\tint need_datasync = 0;\n\t__le32 disksize;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\nagain:\n\t/* we can't allow multiple procs in here at once, its a bit racey */\n\tlock_buffer(bh);\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\n\text3_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif(!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif(!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low =\n\t\t\tcpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low =\n\t\t\tcpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\tdisksize = cpu_to_le32(ei->i_disksize);\n\tif (disksize != raw_inode->i_size) {\n\t\tneed_datasync = 1;\n\t\traw_inode->i_size = disksize;\n\t}\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n#ifdef EXT3_FRAGMENTS\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n#endif\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\t} else {\n\t\tdisksize = cpu_to_le32(ei->i_disksize >> 32);\n\t\tif (disksize != raw_inode->i_size_high) {\n\t\t\traw_inode->i_size_high = disksize;\n\t\t\tneed_datasync = 1;\n\t\t}\n\t\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\t\t\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT3_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT3_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_brelse;\n\n\t\t\t\text3_update_dynamic_rev(sb);\n\t\t\t\tEXT3_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\thandle->h_sync = 1;\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\tEXT3_SB(sb)->s_sbh);\n\t\t\t\t/* get our lock and start over */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\traw_inode->i_block[block] = ei->i_data[block];\n\n\tif (ei->i_extra_isize)\n\t\traw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);\n\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\tunlock_buffer(bh);\n\trc = ext3_journal_dirty_metadata(handle, bh);\n\tif (!err)\n\t\terr = rc;\n\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\n\tatomic_set(&ei->i_sync_tid, handle->h_transaction->t_tid);\n\tif (need_datasync)\n\t\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\nout_brelse:\n\tbrelse (bh);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2848-3023",
    "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2812-2827",
          "snippet": "void ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(le32_to_cpu(raw_inode->i_block[1]))"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[1])"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_block[1]"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[0])"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_aops",
          "args": [
            "inode"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1979-1987",
          "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nd_terminate_link",
          "args": [
            "ei->i_data",
            "inode->i_size",
            "sizeof(ei->i_data) - 1"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "41-47",
          "snippet": "static int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_XATTR_MAGIC"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_extra_isize"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "inode->i_sb"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_datasync_tid",
            "tid"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_sync_tid",
            "tid"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(raw_inode->i_links_count)"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "i_gid"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "i_uid"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_UID32"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext3_get_inode_loc",
          "args": [
            "inode",
            "&iloc",
            "0"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "__ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2687-2803",
          "snippet": "static int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "ext3_get_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2830-2846",
    "snippet": "void ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nvoid ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}"
  },
  {
    "function_name": "ext3_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2812-2827",
    "snippet": "void ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
  },
  {
    "function_name": "ext3_get_inode_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2805-2810",
    "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext3_get_inode_loc",
          "args": [
            "inode",
            "iloc",
            "!ext3_test_inode_state(inode, EXT3_STATE_XATTR)"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "__ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2687-2803",
          "snippet": "static int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
  },
  {
    "function_name": "__ext3_get_inode_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2687-2803",
    "snippet": "static int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "\"ext3_get_inode_loc\"",
            "\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK",
            "inode->i_ino",
            "block"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_load_inode",
          "args": [
            "inode"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "bh->b_size"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "i",
            "bitmap_bh->b_data"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bitmap_bh"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "le32_to_cpu(desc->bg_inode_bitmap)"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_bitmap"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "inode->i_sb",
            "block_group",
            "NULL"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_block",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "iloc"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2647-2679",
          "snippet": "static ext3_fsblk_t ext3_get_inode_block(struct super_block *sb,\n\t\tunsigned long ino, struct ext3_iloc *iloc)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\text3_fsblk_t block;\n\tstruct ext3_group_desc *gdp;\n\n\tif (!ext3_valid_inum(sb, ino)) {\n\t\t/*\n\t\t * This error is already checked for in namei.c unless we are\n\t\t * looking at an NFS filehandle, in which case no error\n\t\t * report is needed\n\t\t */\n\t\treturn 0;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tgdp = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\treturn 0;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT3_INODES_PER_GROUP(sb)) *\n\t\tEXT3_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT3_BLOCK_SIZE_BITS(sb));\n\n\tiloc->block_group = block_group;\n\tiloc->offset = offset & (EXT3_BLOCK_SIZE(sb) - 1);\n\treturn block;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic ext3_fsblk_t ext3_get_inode_block(struct super_block *sb,\n\t\tunsigned long ino, struct ext3_iloc *iloc)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\text3_fsblk_t block;\n\tstruct ext3_group_desc *gdp;\n\n\tif (!ext3_valid_inum(sb, ino)) {\n\t\t/*\n\t\t * This error is already checked for in namei.c unless we are\n\t\t * looking at an NFS filehandle, in which case no error\n\t\t * report is needed\n\t\t */\n\t\treturn 0;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tgdp = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\treturn 0;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT3_INODES_PER_GROUP(sb)) *\n\t\tEXT3_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT3_BLOCK_SIZE_BITS(sb));\n\n\tiloc->block_group = block_group;\n\tiloc->offset = offset & (EXT3_BLOCK_SIZE(sb) - 1);\n\treturn block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int __ext3_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext3_iloc *iloc, int in_mem)\n{\n\text3_fsblk_t block;\n\tstruct buffer_head *bh;\n\n\tblock = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);\n\tif (!block)\n\t\treturn -EIO;\n\n\tbh = sb_getblk(inode->i_sb, block);\n\tif (unlikely(!bh)) {\n\t\text3_error (inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t inode->i_ino, block);\n\t\treturn -ENOMEM;\n\t}\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tstruct ext3_group_desc *desc;\n\t\t\tint inodes_per_buffer;\n\t\t\tint inode_offset, i;\n\t\t\tint block_group;\n\t\t\tint start;\n\n\t\t\tblock_group = (inode->i_ino - 1) /\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb);\n\t\t\tinodes_per_buffer = bh->b_size /\n\t\t\t\tEXT3_INODE_SIZE(inode->i_sb);\n\t\t\tinode_offset = ((inode->i_ino - 1) %\n\t\t\t\t\tEXT3_INODES_PER_GROUP(inode->i_sb));\n\t\t\tstart = inode_offset & ~(inodes_per_buffer - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tdesc = ext3_get_group_desc(inode->i_sb,\n\t\t\t\t\t\tblock_group, NULL);\n\t\t\tif (!desc)\n\t\t\t\tgoto make_io;\n\n\t\t\tbitmap_bh = sb_getblk(inode->i_sb,\n\t\t\t\t\tle32_to_cpu(desc->bg_inode_bitmap));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_buffer; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext3_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_buffer) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext3_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\text3_error(inode->i_sb, \"ext3_get_inode_loc\",\n\t\t\t\t\t\"unable to read inode block - \"\n\t\t\t\t\t\"inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\tinode->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_get_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2647-2679",
    "snippet": "static ext3_fsblk_t ext3_get_inode_block(struct super_block *sb,\n\t\tunsigned long ino, struct ext3_iloc *iloc)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\text3_fsblk_t block;\n\tstruct ext3_group_desc *gdp;\n\n\tif (!ext3_valid_inum(sb, ino)) {\n\t\t/*\n\t\t * This error is already checked for in namei.c unless we are\n\t\t * looking at an NFS filehandle, in which case no error\n\t\t * report is needed\n\t\t */\n\t\treturn 0;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tgdp = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\treturn 0;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT3_INODES_PER_GROUP(sb)) *\n\t\tEXT3_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT3_BLOCK_SIZE_BITS(sb));\n\n\tiloc->block_group = block_group;\n\tiloc->offset = offset & (EXT3_BLOCK_SIZE(sb) - 1);\n\treturn block;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE",
          "args": [
            "sb"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdp->bg_inode_table"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_valid_inum",
          "args": [
            "sb",
            "ino"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "698-705",
          "snippet": "static inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT3_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT3_ROOT_INO\t\t 2\t/* Root inode */\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic ext3_fsblk_t ext3_get_inode_block(struct super_block *sb,\n\t\tunsigned long ino, struct ext3_iloc *iloc)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\text3_fsblk_t block;\n\tstruct ext3_group_desc *gdp;\n\n\tif (!ext3_valid_inum(sb, ino)) {\n\t\t/*\n\t\t * This error is already checked for in namei.c unless we are\n\t\t * looking at an NFS filehandle, in which case no error\n\t\t * report is needed\n\t\t */\n\t\treturn 0;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tgdp = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\treturn 0;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT3_INODES_PER_GROUP(sb)) *\n\t\tEXT3_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT3_BLOCK_SIZE_BITS(sb));\n\n\tiloc->block_group = block_group;\n\tiloc->offset = offset & (EXT3_BLOCK_SIZE(sb) - 1);\n\treturn block;\n}"
  },
  {
    "function_name": "ext3_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2493-2645",
    "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_truncate_exit",
          "args": [
            "inode"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_truncate_exit",
          "args": [
            "inode"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_discard_reservation",
          "args": [
            "inode"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_discard_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "461-480",
          "snippet": "void ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_free_branches",
          "args": [
            "handle",
            "inode",
            "NULL",
            "&nr",
            "&nr+1",
            "3"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2341-2452",
          "snippet": "static void ext3_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text3_fsblk_t nr;\n\t__le32 *p;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\text3_error(inode->i_sb, \"ext3_free_branches\",\n\t\t\t\t\t   \"Read failure, inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\t   inode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text3_free_branches(handle, inode, bh,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (is_handle_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t\ttruncate_restart_transaction(handle, inode);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've probably journalled the indirect block several\n\t\t\t * times during the truncate.  But it's no longer\n\t\t\t * needed and we now drop it from the transaction via\n\t\t\t * journal_revoke().\n\t\t\t *\n\t\t\t * That's easy if it's exclusively part of this\n\t\t\t * transaction.  But if it's part of the committing\n\t\t\t * transaction then journal_forget() will simply\n\t\t\t * brelse() it.  That means that if the underlying\n\t\t\t * block is reallocated in ext3_get_block(),\n\t\t\t * unmap_underlying_metadata() will find this block\n\t\t\t * and will try to get rid of it.  damn, damn. Thus\n\t\t\t * we don't allow a block to be reallocated until\n\t\t\t * a transaction freeing it has fully committed.\n\t\t\t *\n\t\t\t * We also have to make sure journal replay after a\n\t\t\t * crash does not overwrite non-journaled data blocks\n\t\t\t * with old metadata when the block got reallocated for\n\t\t\t * data.  Thus we have to store a revoke record for a\n\t\t\t * block in the same transaction in which we free the\n\t\t\t * block.\n\t\t\t */\n\t\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\n\t\t\text3_free_blocks(handle, inode, nr, 1);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\t\text3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text3_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic void ext3_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text3_fsblk_t nr;\n\t__le32 *p;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\text3_error(inode->i_sb, \"ext3_free_branches\",\n\t\t\t\t\t   \"Read failure, inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\t   inode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text3_free_branches(handle, inode, bh,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (is_handle_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t\ttruncate_restart_transaction(handle, inode);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've probably journalled the indirect block several\n\t\t\t * times during the truncate.  But it's no longer\n\t\t\t * needed and we now drop it from the transaction via\n\t\t\t * journal_revoke().\n\t\t\t *\n\t\t\t * That's easy if it's exclusively part of this\n\t\t\t * transaction.  But if it's part of the committing\n\t\t\t * transaction then journal_forget() will simply\n\t\t\t * brelse() it.  That means that if the underlying\n\t\t\t * block is reallocated in ext3_get_block(),\n\t\t\t * unmap_underlying_metadata() will find this block\n\t\t\t * and will try to get rid of it.  damn, damn. Thus\n\t\t\t * we don't allow a block to be reallocated until\n\t\t\t * a transaction freeing it has fully committed.\n\t\t\t *\n\t\t\t * We also have to make sure journal replay after a\n\t\t\t * crash does not overwrite non-journaled data blocks\n\t\t\t * with old metadata when the block got reallocated for\n\t\t\t * data.  Thus we have to store a revoke record for a\n\t\t\t * block in the same transaction in which we free the\n\t\t\t * block.\n\t\t\t */\n\t\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\n\t\t\text3_free_blocks(handle, inode, nr, 1);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\t\text3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text3_free_data(handle, inode, parent_bh, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_shared",
          "args": [
            "inode",
            "n",
            "offsets",
            "chain",
            "&nr"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2143-2189",
          "snippet": "static Indirect *ext3_find_shared(struct inode *inode, int depth,\n\t\t\tint offsets[4], Indirect chain[4], __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext3_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext3.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile(partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic Indirect *ext3_find_shared(struct inode *inode, int depth,\n\t\t\tint offsets[4], Indirect chain[4], __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext3_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext3.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile(partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_free_data",
          "args": [
            "handle",
            "inode",
            "NULL",
            "i_data+offsets[0]",
            "i_data + EXT3_NDIR_BLOCKS"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2260-2326",
          "snippet": "static void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_block_to_path",
          "args": [
            "inode",
            "last_block",
            "offsets",
            "NULL"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "342-379",
          "snippet": "static int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "inode"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "136-146",
          "snippet": "static handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_FLUSH_ON_CLOSE"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_writeback_data",
          "args": [
            "inode"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_writeback_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1321-1330",
          "snippet": "static inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_truncate_enter",
          "args": [
            "inode"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
  },
  {
    "function_name": "ext3_can_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2454-2463",
    "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "41-47",
          "snippet": "static int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_free_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2341-2452",
    "snippet": "static void ext3_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text3_fsblk_t nr;\n\t__le32 *p;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\text3_error(inode->i_sb, \"ext3_free_branches\",\n\t\t\t\t\t   \"Read failure, inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\t   inode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text3_free_branches(handle, inode, bh,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (is_handle_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t\ttruncate_restart_transaction(handle, inode);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've probably journalled the indirect block several\n\t\t\t * times during the truncate.  But it's no longer\n\t\t\t * needed and we now drop it from the transaction via\n\t\t\t * journal_revoke().\n\t\t\t *\n\t\t\t * That's easy if it's exclusively part of this\n\t\t\t * transaction.  But if it's part of the committing\n\t\t\t * transaction then journal_forget() will simply\n\t\t\t * brelse() it.  That means that if the underlying\n\t\t\t * block is reallocated in ext3_get_block(),\n\t\t\t * unmap_underlying_metadata() will find this block\n\t\t\t * and will try to get rid of it.  damn, damn. Thus\n\t\t\t * we don't allow a block to be reallocated until\n\t\t\t * a transaction freeing it has fully committed.\n\t\t\t *\n\t\t\t * We also have to make sure journal replay after a\n\t\t\t * crash does not overwrite non-journaled data blocks\n\t\t\t * with old metadata when the block got reallocated for\n\t\t\t * data.  Thus we have to store a revoke record for a\n\t\t\t * block in the same transaction in which we free the\n\t\t\t * block.\n\t\t\t */\n\t\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\n\t\t\text3_free_blocks(handle, inode, nr, 1);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\t\text3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text3_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_free_data",
          "args": [
            "handle",
            "inode",
            "parent_bh",
            "first",
            "last"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2260-2326",
          "snippet": "static void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"free data blocks\""
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "parent_bh"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "parent_bh"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"get_write_access\""
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "nr",
            "1"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_forget",
          "args": [
            "handle",
            "1",
            "inode",
            "bh",
            "bh->b_blocknr"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "58-97",
          "snippet": "int ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_restart_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "168-183",
          "snippet": "static int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_extend_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "154-161",
          "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_branches",
          "args": [
            "handle",
            "inode",
            "bh",
            "(__le32*)bh->b_data",
            "(__le32*)bh->b_data + addr_per_block",
            "depth"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2341-2452",
          "snippet": "static void ext3_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text3_fsblk_t nr;\n\t__le32 *p;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\text3_error(inode->i_sb, \"ext3_free_branches\",\n\t\t\t\t\t   \"Read failure, inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\t   inode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text3_free_branches(handle, inode, bh,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (is_handle_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t\ttruncate_restart_transaction(handle, inode);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've probably journalled the indirect block several\n\t\t\t * times during the truncate.  But it's no longer\n\t\t\t * needed and we now drop it from the transaction via\n\t\t\t * journal_revoke().\n\t\t\t *\n\t\t\t * That's easy if it's exclusively part of this\n\t\t\t * transaction.  But if it's part of the committing\n\t\t\t * transaction then journal_forget() will simply\n\t\t\t * brelse() it.  That means that if the underlying\n\t\t\t * block is reallocated in ext3_get_block(),\n\t\t\t * unmap_underlying_metadata() will find this block\n\t\t\t * and will try to get rid of it.  damn, damn. Thus\n\t\t\t * we don't allow a block to be reallocated until\n\t\t\t * a transaction freeing it has fully committed.\n\t\t\t *\n\t\t\t * We also have to make sure journal replay after a\n\t\t\t * crash does not overwrite non-journaled data blocks\n\t\t\t * with old metadata when the block got reallocated for\n\t\t\t * data.  Thus we have to store a revoke record for a\n\t\t\t * block in the same transaction in which we free the\n\t\t\t * block.\n\t\t\t */\n\t\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\n\t\t\text3_free_blocks(handle, inode, nr, 1);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\t\text3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text3_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"free child branches\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "\"ext3_free_branches\"",
            "\"Read failure, inode=%lu, block=\"E3FSBLK",
            "inode->i_ino",
            "nr"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "nr"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic void ext3_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text3_fsblk_t nr;\n\t__le32 *p;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\text3_error(inode->i_sb, \"ext3_free_branches\",\n\t\t\t\t\t   \"Read failure, inode=%lu, block=\"E3FSBLK,\n\t\t\t\t\t   inode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text3_free_branches(handle, inode, bh,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (is_handle_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t\ttruncate_restart_transaction(handle, inode);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've probably journalled the indirect block several\n\t\t\t * times during the truncate.  But it's no longer\n\t\t\t * needed and we now drop it from the transaction via\n\t\t\t * journal_revoke().\n\t\t\t *\n\t\t\t * That's easy if it's exclusively part of this\n\t\t\t * transaction.  But if it's part of the committing\n\t\t\t * transaction then journal_forget() will simply\n\t\t\t * brelse() it.  That means that if the underlying\n\t\t\t * block is reallocated in ext3_get_block(),\n\t\t\t * unmap_underlying_metadata() will find this block\n\t\t\t * and will try to get rid of it.  damn, damn. Thus\n\t\t\t * we don't allow a block to be reallocated until\n\t\t\t * a transaction freeing it has fully committed.\n\t\t\t *\n\t\t\t * We also have to make sure journal replay after a\n\t\t\t * crash does not overwrite non-journaled data blocks\n\t\t\t * with old metadata when the block got reallocated for\n\t\t\t * data.  Thus we have to store a revoke record for a\n\t\t\t * block in the same transaction in which we free the\n\t\t\t * block.\n\t\t\t */\n\t\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\n\t\t\text3_free_blocks(handle, inode, nr, 1);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\t\text3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text3_free_data(handle, inode, parent_bh, first, last);\n\t}\n}"
  },
  {
    "function_name": "ext3_free_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2260-2326",
    "snippet": "static void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "\"ext3_free_data\"",
            "\"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\"",
            "inode->i_ino",
            "(unsigned long long)this_bh->b_blocknr"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "this_bh"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "this_bh"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "this_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_clear_blocks",
          "args": [
            "handle",
            "inode",
            "this_bh",
            "block_to_free",
            "count",
            "block_to_free_p",
            "p"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2199-2239",
          "snippet": "static void ext3_clear_blocks(handle_t *handle, struct inode *inode,\n\t\tstruct buffer_head *bh, ext3_fsblk_t block_to_free,\n\t\tunsigned long count, __le32 *first, __le32 *last)\n{\n\t__le32 *p;\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\tif (ext3_journal_dirty_metadata(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t\text3_mark_inode_dirty(handle, inode);\n\t\ttruncate_restart_transaction(handle, inode);\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\tif (ext3_journal_get_write_access(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Any buffers which are on the journal will be in memory. We find\n\t * them on the hash table so journal_revoke() will run journal_forget()\n\t * on them.  We've already detached each block from the file, so\n\t * bforget() in journal_forget() should be safe.\n\t *\n\t * AKPM: turn on bforget in journal_forget()!!!\n\t */\n\tfor (p = first; p < last; p++) {\n\t\tu32 nr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t*p = 0;\n\t\t\tbh = sb_find_get_block(inode->i_sb, nr);\n\t\t\text3_forget(handle, 0, inode, bh, nr);\n\t\t}\n\t}\n\n\text3_free_blocks(handle, inode, block_to_free, count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic void ext3_clear_blocks(handle_t *handle, struct inode *inode,\n\t\tstruct buffer_head *bh, ext3_fsblk_t block_to_free,\n\t\tunsigned long count, __le32 *first, __le32 *last)\n{\n\t__le32 *p;\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\tif (ext3_journal_dirty_metadata(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t\text3_mark_inode_dirty(handle, inode);\n\t\ttruncate_restart_transaction(handle, inode);\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\tif (ext3_journal_get_write_access(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Any buffers which are on the journal will be in memory. We find\n\t * them on the hash table so journal_revoke() will run journal_forget()\n\t * on them.  We've already detached each block from the file, so\n\t * bforget() in journal_forget() should be safe.\n\t *\n\t * AKPM: turn on bforget in journal_forget()!!!\n\t */\n\tfor (p = first; p < last; p++) {\n\t\tu32 nr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t*p = 0;\n\t\t\tbh = sb_find_get_block(inode->i_sb, nr);\n\t\t\text3_forget(handle, 0, inode, bh, nr);\n\t\t}\n\t}\n\n\text3_free_blocks(handle, inode, block_to_free, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "this_bh"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "this_bh",
            "\"get_write_access\""
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text3_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text3_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\text3_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t  block_to_free,\n\t\t\t\t\t\t  count, block_to_free_p, p);\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count > 0)\n\t\text3_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t  count, block_to_free_p, p);\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext3_journal_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif (bh2jh(this_bh))\n\t\t\text3_journal_dirty_metadata(handle, this_bh);\n\t\telse\n\t\t\text3_error(inode->i_sb, \"ext3_free_data\",\n\t\t\t\t   \"circular indirect block detected, \"\n\t\t\t\t   \"inode=%lu, block=%llu\",\n\t\t\t\t   inode->i_ino,\n\t\t\t\t   (unsigned long long)this_bh->b_blocknr);\n\t}\n}"
  },
  {
    "function_name": "ext3_clear_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2199-2239",
    "snippet": "static void ext3_clear_blocks(handle_t *handle, struct inode *inode,\n\t\tstruct buffer_head *bh, ext3_fsblk_t block_to_free,\n\t\tunsigned long count, __le32 *first, __le32 *last)\n{\n\t__le32 *p;\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\tif (ext3_journal_dirty_metadata(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t\text3_mark_inode_dirty(handle, inode);\n\t\ttruncate_restart_transaction(handle, inode);\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\tif (ext3_journal_get_write_access(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Any buffers which are on the journal will be in memory. We find\n\t * them on the hash table so journal_revoke() will run journal_forget()\n\t * on them.  We've already detached each block from the file, so\n\t * bforget() in journal_forget() should be safe.\n\t *\n\t * AKPM: turn on bforget in journal_forget()!!!\n\t */\n\tfor (p = first; p < last; p++) {\n\t\tu32 nr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t*p = 0;\n\t\t\tbh = sb_find_get_block(inode->i_sb, nr);\n\t\t\text3_forget(handle, 0, inode, bh, nr);\n\t\t}\n\t}\n\n\text3_free_blocks(handle, inode, block_to_free, count);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "block_to_free",
            "count"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_forget",
          "args": [
            "handle",
            "0",
            "inode",
            "bh",
            "nr"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "58-97",
          "snippet": "int ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "inode->i_sb",
            "nr"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"retaking write access\""
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_restart_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "168-183",
          "snippet": "static int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_extend_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "154-161",
          "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic void ext3_clear_blocks(handle_t *handle, struct inode *inode,\n\t\tstruct buffer_head *bh, ext3_fsblk_t block_to_free,\n\t\tunsigned long count, __le32 *first, __le32 *last)\n{\n\t__le32 *p;\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\tif (ext3_journal_dirty_metadata(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t\text3_mark_inode_dirty(handle, inode);\n\t\ttruncate_restart_transaction(handle, inode);\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\tif (ext3_journal_get_write_access(handle, bh))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Any buffers which are on the journal will be in memory. We find\n\t * them on the hash table so journal_revoke() will run journal_forget()\n\t * on them.  We've already detached each block from the file, so\n\t * bforget() in journal_forget() should be safe.\n\t *\n\t * AKPM: turn on bforget in journal_forget()!!!\n\t */\n\tfor (p = first; p < last; p++) {\n\t\tu32 nr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t*p = 0;\n\t\t\tbh = sb_find_get_block(inode->i_sb, nr);\n\t\t\text3_forget(handle, 0, inode, bh, nr);\n\t\t}\n\t}\n\n\text3_free_blocks(handle, inode, block_to_free, count);\n}"
  },
  {
    "function_name": "ext3_find_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2143-2189",
    "snippet": "static Indirect *ext3_find_shared(struct inode *inode, int depth,\n\t\t\tint offsets[4], Indirect chain[4], __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext3_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext3.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile(partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_zeroes",
          "args": [
            "(__le32*)p->bh->b_data",
            "p->p"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "all_zeroes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2100-2106",
          "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_branch",
          "args": [
            "inode",
            "k",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "410-444",
          "snippet": "static Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic Indirect *ext3_find_shared(struct inode *inode, int depth,\n\t\t\tint offsets[4], Indirect chain[4], __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext3_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext3.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile(partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
  },
  {
    "function_name": "all_zeroes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "2100-2106",
    "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext3_block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1995-2093",
    "snippet": "static int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_data",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_dirty_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1318-1325",
          "snippet": "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_order_data",
          "args": [
            "inode"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1310-1319",
          "snippet": "static inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"zeroed end of block\""
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get write access\""
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "1"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_writeback_data",
          "args": [
            "inode"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_writeback_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1321-1330",
          "snippet": "static inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"still unmapped\""
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1021-1050",
          "snippet": "static int ext3_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tint ret = 0, started = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\n\tif (create && !handle) {\t/* Direct IO write... */\n\t\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n\t\thandle = ext3_journal_start(inode, DIO_CREDITS +\n\t\t\t\tEXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext3_get_blocks_handle(handle, inode, iblock,\n\t\t\t\t\tmax_blocks, bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text3_journal_stop(handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [
            "#define DIO_CREDITS 25",
            "#define DIO_MAX_BLOCKS 4096"
          ],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\n#define DIO_CREDITS 25\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tint ret = 0, started = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\n\tif (create && !handle) {\t/* Direct IO write... */\n\t\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n\t\thandle = ext3_journal_start(inode, DIO_CREDITS +\n\t\t\t\tEXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext3_get_blocks_handle(handle, inode, iblock,\n\t\t\t\t\tmax_blocks, bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text3_journal_stop(handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"unmapped\""
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"freed: skip\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_set_aops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1979-1987",
    "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
      "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
      "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_writeback_data",
          "args": [
            "inode"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_writeback_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1321-1330",
          "snippet": "static inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_order_data",
          "args": [
            "inode"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1310-1319",
          "snippet": "static inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
  },
  {
    "function_name": "ext3_journalled_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1928-1932",
    "snippet": "static int ext3_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}"
  },
  {
    "function_name": "ext3_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1823-1913",
    "snippet": "static ssize_t ext3_direct_IO(int rw, struct kiocb *iocb,\n\t\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\ttrace_ext3_direct_IO_enter(inode, offset, count, rw);\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext3_journal_start(inode, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext3_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text3_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text3_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, ext3_get_block);\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\text3_truncate_failed_direct_write(inode);\n\t}\n\tif (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext3_journal_start(inode, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Truncate allocated blocks\n\t\t\t * and pretend the write failed... */\n\t\t\text3_truncate_failed_direct_write(inode);\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text3_orphan_del(NULL, inode);\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text3_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext3_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext3_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\ttrace_ext3_direct_IO_exit(inode, offset, count, rw, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_direct_IO_exit",
          "args": [
            "inode",
            "offset",
            "count",
            "rw",
            "ret"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "end"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_truncate_failed_direct_write",
          "args": [
            "inode"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate_failed_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1244-1248",
          "snippet": "static void ext3_truncate_failed_direct_write(struct inode *inode)\n{\n\text3_block_truncate_page(inode, inode->i_size);\n\text3_truncate(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_direct_write(struct inode *inode)\n{\n\text3_block_truncate_page(inode, inode->i_size);\n\text3_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "2"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "ext3_get_block"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_direct_IO_enter",
          "args": [
            "inode",
            "offset",
            "count",
            "rw"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic ssize_t ext3_direct_IO(int rw, struct kiocb *iocb,\n\t\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\ttrace_ext3_direct_IO_enter(inode, offset, count, rw);\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext3_journal_start(inode, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext3_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text3_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text3_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, ext3_get_block);\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\text3_truncate_failed_direct_write(inode);\n\t}\n\tif (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext3_journal_start(inode, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Truncate allocated blocks\n\t\t\t * and pretend the write failed... */\n\t\t\text3_truncate_failed_direct_write(inode);\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text3_orphan_del(NULL, inode);\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text3_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext3_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text3_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext3_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\ttrace_ext3_direct_IO_exit(inode, offset, count, rw, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1803-1812",
    "snippet": "static int ext3_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT3_JOURNAL(page->mapping->host);\n\n\ttrace_ext3_releasepage(page);\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\treturn journal_try_to_free_buffers(journal, page, wait);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_try_to_free_buffers",
          "args": [
            "journal",
            "page",
            "wait"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "journal_try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1726-1761",
          "snippet": "int journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageChecked(page)"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_releasepage",
          "args": [
            "page"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_JOURNAL",
          "args": [
            "page->mapping->host"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT3_JOURNAL(page->mapping->host);\n\n\ttrace_ext3_releasepage(page);\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\treturn journal_try_to_free_buffers(journal, page, wait);\n}"
  },
  {
    "function_name": "ext3_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1787-1801",
    "snippet": "static void ext3_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tjournal_t *journal = EXT3_JOURNAL(page->mapping->host);\n\n\ttrace_ext3_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\tjournal_invalidatepage(journal, page, offset, length);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_invalidatepage",
          "args": [
            "journal",
            "page",
            "offset",
            "length"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "journal_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2027-2073",
          "snippet": "void journal_invalidatepage(journal_t *journal,\n\t\t      struct page *page,\n\t\t      unsigned int offset,\n\t\t      unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tmay_free &= journal_unmap_buffer(journal, bh,\n\t\t\t\t\t\t\t partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_invalidatepage(journal_t *journal,\n\t\t      struct page *page,\n\t\t      unsigned int offset,\n\t\t      unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tmay_free &= journal_unmap_buffer(journal, bh,\n\t\t\t\t\t\t\t partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_JOURNAL",
          "args": [
            "page->mapping->host"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic void ext3_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tjournal_t *journal = EXT3_JOURNAL(page->mapping->host);\n\n\ttrace_ext3_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\tjournal_invalidatepage(journal, page, offset, length);\n}"
  },
  {
    "function_name": "ext3_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1780-1785",
    "snippet": "static int\next3_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, ext3_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "ext3_get_block"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int\next3_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, ext3_get_block);\n}"
  },
  {
    "function_name": "ext3_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1774-1778",
    "snippet": "static int ext3_readpage(struct file *file, struct page *page)\n{\n\ttrace_ext3_readpage(page);\n\treturn mpage_readpage(page, ext3_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "ext3_get_block"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_readpage",
          "args": [
            "page"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_readpage(struct file *file, struct page *page)\n{\n\ttrace_ext3_readpage(page);\n\treturn mpage_readpage(page, ext3_get_block);\n}"
  },
  {
    "function_name": "ext3_journalled_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1702-1772",
    "snippet": "static int ext3_journalled_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\ttrace_ext3_journalled_writepage(page);\n\tif (!page_has_buffers(page) || PageChecked(page)) {\n\t\tif (ext3_journal_current_handle())\n\t\t\tgoto no_write;\n\n\t\thandle = ext3_journal_start(inode,\n\t\t\t\t\t    ext3_writepage_trans_blocks(inode));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto no_write;\n\t\t}\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\tClearPageChecked(page);\n\t\tret = __block_write_begin(page, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\t  ext3_get_block);\n\t\tif (ret != 0) {\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, do_journal_get_write_access);\n\n\t\terr = walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t\tPAGE_CACHE_SIZE, NULL, write_end_fn);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t\text3_set_inode_state(inode, EXT3_STATE_JDATA);\n\t\tatomic_set(&EXT3_I(inode)->i_datasync_tid,\n\t\t\t   handle->h_transaction->t_tid);\n\t\tunlock_page(page);\n\t\terr = ext3_journal_stop(handle);\n\t\tif (!ret)\n\t\t\tret = err;\n\t} else {\n\t\t/*\n\t\t * It is a page full of checkpoint-mode buffers. Go and write\n\t\t * them. They should have been already mapped when they went\n\t\t * to the journal so provide NULL get_block function to catch\n\t\t * errors.\n\t\t */\n\t\tret = block_write_full_page(page, NULL, wbc);\n\t}\nout:\n\treturn ret;\n\nno_write:\n\tredirty_page_for_writepage(wbc, page);\nout_unlock:\n\tunlock_page(page);\n\tgoto out;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "NULL",
            "wbc"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&EXT3_I(inode)->i_datasync_tid",
            "handle->h_transaction->t_tid"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_JDATA"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "0",
            "PAGE_CACHE_SIZE",
            "NULL",
            "write_end_fn"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE",
            "ext3_get_block"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "ext3_writepage_trans_blocks(inode)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3367-3385",
          "snippet": "static int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_journalled_writepage",
          "args": [
            "page"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "inode"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "PageLocked(page)"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_journalled_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\ttrace_ext3_journalled_writepage(page);\n\tif (!page_has_buffers(page) || PageChecked(page)) {\n\t\tif (ext3_journal_current_handle())\n\t\t\tgoto no_write;\n\n\t\thandle = ext3_journal_start(inode,\n\t\t\t\t\t    ext3_writepage_trans_blocks(inode));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto no_write;\n\t\t}\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\tClearPageChecked(page);\n\t\tret = __block_write_begin(page, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\t  ext3_get_block);\n\t\tif (ret != 0) {\n\t\t\text3_journal_stop(handle);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, do_journal_get_write_access);\n\n\t\terr = walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t\tPAGE_CACHE_SIZE, NULL, write_end_fn);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t\text3_set_inode_state(inode, EXT3_STATE_JDATA);\n\t\tatomic_set(&EXT3_I(inode)->i_datasync_tid,\n\t\t\t   handle->h_transaction->t_tid);\n\t\tunlock_page(page);\n\t\terr = ext3_journal_stop(handle);\n\t\tif (!ret)\n\t\t\tret = err;\n\t} else {\n\t\t/*\n\t\t * It is a page full of checkpoint-mode buffers. Go and write\n\t\t * them. They should have been already mapped when they went\n\t\t * to the journal so provide NULL get_block function to catch\n\t\t * errors.\n\t\t */\n\t\tret = block_write_full_page(page, NULL, wbc);\n\t}\nout:\n\treturn ret;\n\nno_write:\n\tredirty_page_for_writepage(wbc, page);\nout_unlock:\n\tunlock_page(page);\n\tgoto out;\n}"
  },
  {
    "function_name": "ext3_writeback_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1653-1700",
    "snippet": "static int ext3_writeback_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\tif (ext3_journal_current_handle())\n\t\tgoto out_fail;\n\n\ttrace_ext3_writeback_writepage(page);\n\tif (page_has_buffers(page)) {\n\t\tif (!walk_page_buffers(NULL, page_buffers(page), 0,\n\t\t\t\t      PAGE_CACHE_SIZE, NULL, buffer_unmapped)) {\n\t\t\t/* Provide NULL get_block() to catch bugs if buffers\n\t\t\t * weren't really mapped */\n\t\t\treturn block_write_full_page(page, NULL, wbc);\n\t\t}\n\t}\n\n\thandle = ext3_journal_start(inode, ext3_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_fail;\n\t}\n\n\tret = block_write_full_page(page, ext3_get_block, wbc);\n\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n\nout_fail:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "ext3_get_block",
            "wbc"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "ext3_writepage_trans_blocks(inode)"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3367-3385",
          "snippet": "static int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "NULL",
            "page_buffers(page)",
            "0",
            "PAGE_CACHE_SIZE",
            "NULL",
            "buffer_unmapped"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_writeback_writepage",
          "args": [
            "page"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS)"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "inode"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "PageLocked(page)"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writeback_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\tif (ext3_journal_current_handle())\n\t\tgoto out_fail;\n\n\ttrace_ext3_writeback_writepage(page);\n\tif (page_has_buffers(page)) {\n\t\tif (!walk_page_buffers(NULL, page_buffers(page), 0,\n\t\t\t\t      PAGE_CACHE_SIZE, NULL, buffer_unmapped)) {\n\t\t\t/* Provide NULL get_block() to catch bugs if buffers\n\t\t\t * weren't really mapped */\n\t\t\treturn block_write_full_page(page, NULL, wbc);\n\t\t}\n\t}\n\n\thandle = ext3_journal_start(inode, ext3_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_fail;\n\t}\n\n\tret = block_write_full_page(page, ext3_get_block, wbc);\n\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n\nout_fail:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_ordered_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1574-1651",
    "snippet": "static int ext3_ordered_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bufs;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\t/*\n\t * We give up here if we're reentered, because it might be for a\n\t * different filesystem.\n\t */\n\tif (ext3_journal_current_handle())\n\t\tgoto out_fail;\n\n\ttrace_ext3_ordered_writepage(page);\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\tpage_bufs = page_buffers(page);\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!walk_page_buffers(NULL, page_bufs, 0, PAGE_CACHE_SIZE,\n\t\t\t\t       NULL, buffer_unmapped)) {\n\t\t\t/* Provide NULL get_block() to catch bugs if buffers\n\t\t\t * weren't really mapped */\n\t\t\treturn block_write_full_page(page, NULL, wbc);\n\t\t}\n\t}\n\thandle = ext3_journal_start(inode, ext3_writepage_trans_blocks(inode));\n\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_fail;\n\t}\n\n\twalk_page_buffers(handle, page_bufs, 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, bget_one);\n\n\tret = block_write_full_page(page, ext3_get_block, wbc);\n\n\t/*\n\t * The page can become unlocked at any point now, and\n\t * truncate can then come in and change things.  So we\n\t * can't touch *page from now on.  But *page_bufs is\n\t * safe due to elevated refcount.\n\t */\n\n\t/*\n\t * And attach them to the current transaction.  But only if\n\t * block_write_full_page() succeeded.  Otherwise they are unmapped,\n\t * and generally junk.\n\t */\n\tif (ret == 0)\n\t\tret = walk_page_buffers(handle, page_bufs, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\tNULL, journal_dirty_data_fn);\n\twalk_page_buffers(handle, page_bufs, 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, bput_one);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n\nout_fail:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_bufs",
            "0",
            "PAGE_CACHE_SIZE",
            "NULL",
            "bput_one"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "ext3_get_block",
            "wbc"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "ext3_writepage_trans_blocks(inode)"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3367-3385",
          "snippet": "static int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "inode->i_sb->s_blocksize",
            "(1 << BH_Dirty)|(1 << BH_Uptodate)"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_ordered_writepage",
          "args": [
            "page"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS)"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "inode"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "PageLocked(page)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_ordered_writepage(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bufs;\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tint err;\n\n\tJ_ASSERT(PageLocked(page));\n\t/*\n\t * We don't want to warn for emergency remount. The condition is\n\t * ordered to avoid dereferencing inode->i_sb in non-error case to\n\t * avoid slow-downs.\n\t */\n\tWARN_ON_ONCE(IS_RDONLY(inode) &&\n\t\t     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));\n\n\t/*\n\t * We give up here if we're reentered, because it might be for a\n\t * different filesystem.\n\t */\n\tif (ext3_journal_current_handle())\n\t\tgoto out_fail;\n\n\ttrace_ext3_ordered_writepage(page);\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\tpage_bufs = page_buffers(page);\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!walk_page_buffers(NULL, page_bufs, 0, PAGE_CACHE_SIZE,\n\t\t\t\t       NULL, buffer_unmapped)) {\n\t\t\t/* Provide NULL get_block() to catch bugs if buffers\n\t\t\t * weren't really mapped */\n\t\t\treturn block_write_full_page(page, NULL, wbc);\n\t\t}\n\t}\n\thandle = ext3_journal_start(inode, ext3_writepage_trans_blocks(inode));\n\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_fail;\n\t}\n\n\twalk_page_buffers(handle, page_bufs, 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, bget_one);\n\n\tret = block_write_full_page(page, ext3_get_block, wbc);\n\n\t/*\n\t * The page can become unlocked at any point now, and\n\t * truncate can then come in and change things.  So we\n\t * can't touch *page from now on.  But *page_bufs is\n\t * safe due to elevated refcount.\n\t */\n\n\t/*\n\t * And attach them to the current transaction.  But only if\n\t * block_write_full_page() succeeded.  Otherwise they are unmapped,\n\t * and generally junk.\n\t */\n\tif (ret == 0)\n\t\tret = walk_page_buffers(handle, page_bufs, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\tNULL, journal_dirty_data_fn);\n\twalk_page_buffers(handle, page_bufs, 0,\n\t\t\tPAGE_CACHE_SIZE, NULL, bput_one);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n\nout_fail:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "buffer_unmapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1556-1559",
    "snippet": "static int buffer_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int buffer_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}"
  },
  {
    "function_name": "bput_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1550-1554",
    "snippet": "static int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "bget_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1544-1548",
    "snippet": "static int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1506-1542",
    "snippet": "static sector_t ext3_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT3_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text3_clear_inode_state(inode, EXT3_STATE_JDATA);\n\t\tjournal = EXT3_JOURNAL(inode);\n\t\tjournal_lock_updates(journal);\n\t\terr = journal_flush(journal);\n\t\tjournal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping,block,ext3_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "ext3_get_block"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "journal"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_clear_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_JDATA"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "727-730",
          "snippet": "static inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_JDATA"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic sector_t ext3_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT3_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text3_clear_inode_state(inode, EXT3_STATE_JDATA);\n\t\tjournal = EXT3_JOURNAL(inode);\n\t\tjournal_lock_updates(journal);\n\t\terr = journal_flush(journal);\n\t\tjournal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping,block,ext3_get_block);\n}"
  },
  {
    "function_name": "ext3_journalled_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1436-1490",
    "snippet": "static int ext3_journalled_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\n\ttrace_ext3_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (copied < len) {\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\t\tpage_zero_new_buffers(page, from + copied, to);\n\t\tto = from + copied;\n\t}\n\n\tret = walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\tto, &partial, write_end_fn);\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\text3_set_inode_state(inode, EXT3_STATE_JDATA);\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\tif (inode->i_size > ei->i_disksize) {\n\t\tei->i_disksize = inode->i_size;\n\t\tret2 = ext3_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tret2 = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1234-1238",
          "snippet": "static void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_datasync_tid",
            "handle->h_transaction->t_tid"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_JDATA"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "&partial",
            "write_end_fn"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from + copied",
            "to"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_journalled_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_journalled_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\n\ttrace_ext3_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (copied < len) {\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\t\tpage_zero_new_buffers(page, from + copied, to);\n\t\tto = from + copied;\n\t}\n\n\tret = walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\tto, &partial, write_end_fn);\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\text3_set_inode_state(inode, EXT3_STATE_JDATA);\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\tif (inode->i_size > ei->i_disksize) {\n\t\tei->i_disksize = inode->i_size;\n\t\tret2 = ext3_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tret2 = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "ext3_writeback_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1409-1434",
    "snippet": "static int ext3_writeback_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\ttrace_ext3_writeback_write_end(inode, pos, len, copied);\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tupdate_file_sizes(inode, pos, copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\tret = ext3_journal_stop(handle);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1234-1238",
          "snippet": "static void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_file_sizes",
          "args": [
            "inode",
            "pos",
            "copied"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "update_file_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1354-1363",
          "snippet": "static void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_writeback_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writeback_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\ttrace_ext3_writeback_write_end(inode, pos, len, copied);\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tupdate_file_sizes(inode, pos, copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\tret = ext3_journal_stop(handle);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "ext3_ordered_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1372-1407",
    "snippet": "static int ext3_ordered_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = file->f_mapping->host;\n\tunsigned from, to;\n\tint ret = 0, ret2;\n\n\ttrace_ext3_ordered_write_end(inode, pos, len, copied);\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + copied;\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\tfrom, to, NULL, journal_dirty_data_fn);\n\n\tif (ret == 0)\n\t\tupdate_file_sizes(inode, pos, copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\tret2 = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1234-1238",
          "snippet": "static void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_file_sizes",
          "args": [
            "inode",
            "pos",
            "copied"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "update_file_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1354-1363",
          "snippet": "static void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "NULL",
            "journal_dirty_data_fn"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_ordered_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_ordered_write_end(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tstruct inode *inode = file->f_mapping->host;\n\tunsigned from, to;\n\tint ret = 0, ret2;\n\n\ttrace_ext3_ordered_write_end(inode, pos, len, copied);\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + copied;\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\tfrom, to, NULL, journal_dirty_data_fn);\n\n\tif (ret == 0)\n\t\tupdate_file_sizes(inode, pos, copied);\n\t/*\n\t * There may be allocated blocks outside of i_size because\n\t * we failed to copy some data. Prepare for truncate.\n\t */\n\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\text3_orphan_add(handle, inode);\n\tret2 = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\text3_truncate_failed_write(inode);\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "update_file_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1354-1363",
    "snippet": "static void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void update_file_sizes(struct inode *inode, loff_t pos, unsigned copied)\n{\n\t/* What matters to us is i_disksize. We don't write i_size anywhere */\n\tif (pos + copied > inode->i_size)\n\t\ti_size_write(inode, pos + copied);\n\tif (pos + copied > EXT3_I(inode)->i_disksize) {\n\t\tEXT3_I(inode)->i_disksize = pos + copied;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
  },
  {
    "function_name": "write_end_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1340-1346",
    "snippet": "static int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\treturn ext3_journal_dirty_metadata(handle, bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\treturn ext3_journal_dirty_metadata(handle, bh);\n}"
  },
  {
    "function_name": "journal_dirty_data_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1328-1337",
    "snippet": "static int journal_dirty_data_fn(handle_t *handle, struct buffer_head *bh)\n{\n\t/*\n\t * Write could have mapped the buffer but it didn't copy the data in\n\t * yet. So avoid filing such buffer into a transaction.\n\t */\n\tif (buffer_mapped(bh) && buffer_uptodate(bh))\n\t\treturn ext3_journal_dirty_data(handle, bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_dirty_data",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_dirty_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1318-1325",
          "snippet": "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int journal_dirty_data_fn(handle_t *handle, struct buffer_head *bh)\n{\n\t/*\n\t * Write could have mapped the buffer but it didn't copy the data in\n\t * yet. So avoid filing such buffer into a transaction.\n\t */\n\tif (buffer_mapped(bh) && buffer_uptodate(bh))\n\t\treturn ext3_journal_dirty_data(handle, bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_journal_dirty_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1318-1325",
    "snippet": "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "__func__",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_dirty_data",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "journal_dirty_data_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1328-1337",
          "snippet": "static int journal_dirty_data_fn(handle_t *handle, struct buffer_head *bh)\n{\n\t/*\n\t * Write could have mapped the buffer but it didn't copy the data in\n\t * yet. So avoid filing such buffer into a transaction.\n\t */\n\tif (buffer_mapped(bh) && buffer_uptodate(bh))\n\t\treturn ext3_journal_dirty_data(handle, bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int journal_dirty_data_fn(handle_t *handle, struct buffer_head *bh)\n{\n\t/*\n\t * Write could have mapped the buffer but it didn't copy the data in\n\t * yet. So avoid filing such buffer into a transaction.\n\t */\n\tif (buffer_mapped(bh) && buffer_uptodate(bh))\n\t\treturn ext3_journal_dirty_data(handle, bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1250-1315",
    "snippet": "static int ext3_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\t/* Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason */\n\tint needed_blocks = ext3_writepage_trans_blocks(inode) + 1;\n\n\ttrace_ext3_write_begin(inode, pos, len, flags);\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\nretry:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\thandle = ext3_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = __block_write_begin(page, pos, len, ext3_get_block);\n\tif (ret)\n\t\tgoto write_begin_failed;\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\nwrite_begin_failed:\n\tif (ret) {\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before truncate\n\t\t * finishes. Do this only if ext3_can_truncate() agrees so\n\t\t * that orphan processing code is happy.\n\t\t */\n\t\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\t\text3_orphan_add(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size)\n\t\t\text3_truncate_failed_write(inode);\n\t}\n\tif (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1234-1238",
          "snippet": "static void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "NULL",
            "do_journal_get_write_access"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1149-1179",
          "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "ext3_get_block"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "needed_blocks"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_write_begin",
          "args": [
            "inode",
            "pos",
            "len",
            "flags"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3367-3385",
          "snippet": "static int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext3_journal_blocks_per_page(inode);\n\tint indirects = (EXT3_NDIR_BLOCKS % bpp) ? 5 : 3;\n\tint ret;\n\n\tif (ext3_should_journal_data(inode))\n\t\tret = 3 * (bpp + indirects) + 2;\n\telse\n\t\tret = 2 * (bpp + indirects) + indirects + 2;\n\n#ifdef CONFIG_QUOTA\n\t/* We know that structure was already allocated during dquot_initialize so\n\t * we will be updating only the data blocks + inodes */\n\tret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n#endif\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\t/* Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason */\n\tint needed_blocks = ext3_writepage_trans_blocks(inode) + 1;\n\n\ttrace_ext3_write_begin(inode, pos, len, flags);\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\nretry:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\thandle = ext3_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = __block_write_begin(page, pos, len, ext3_get_block);\n\tif (ret)\n\t\tgoto write_begin_failed;\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\nwrite_begin_failed:\n\tif (ret) {\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before truncate\n\t\t * finishes. Do this only if ext3_can_truncate() agrees so\n\t\t * that orphan processing code is happy.\n\t\t */\n\t\tif (pos + len > inode->i_size && ext3_can_truncate(inode))\n\t\t\text3_orphan_add(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size)\n\t\t\text3_truncate_failed_write(inode);\n\t}\n\tif (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_truncate_failed_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1244-1248",
    "snippet": "static void ext3_truncate_failed_direct_write(struct inode *inode)\n{\n\text3_block_truncate_page(inode, inode->i_size);\n\text3_truncate(inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_truncate",
          "args": [
            "inode"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2493-2645",
          "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_block_truncate_page",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1995-2093",
          "snippet": "static int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from)\n{\n\text3_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, length, pos;\n\tstruct page *page;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\t/* Truncated on block boundary - nothing to do */\n\tblocksize = inode->i_sb->s_blocksize;\n\tif ((from & (blocksize - 1)) == 0)\n\t\treturn 0;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = blocksize - (offset & (blocksize - 1));\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text3_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\terr = bh_submit_read(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t/* data=writeback mode doesn't need transaction to zero-out data */\n\tif (!ext3_should_writeback_data(inode)) {\n\t\t/* We journal at most one block */\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tclear_highpage(page);\n\t\t\tflush_dcache_page(page);\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (ext3_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto stop;\n\t}\n\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\terr = 0;\n\tif (ext3_should_journal_data(inode)) {\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t} else {\n\t\tif (ext3_should_order_data(inode))\n\t\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\nstop:\n\tif (handle)\n\t\text3_journal_stop(handle);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_direct_write(struct inode *inode)\n{\n\text3_block_truncate_page(inode, inode->i_size);\n\text3_truncate(inode);\n}"
  },
  {
    "function_name": "ext3_truncate_failed_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1234-1238",
    "snippet": "static void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_truncate",
          "args": [
            "inode"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2493-2645",
          "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "inode->i_mapping",
            "inode->i_size"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic void ext3_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text3_truncate(inode);\n}"
  },
  {
    "function_name": "do_journal_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1206-1228",
    "snippet": "static int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1149-1179",
    "snippet": "static int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int walk_page_buffers(\thandle_t *handle,\n\t\t\t\tstruct buffer_head *head,\n\t\t\t\tunsigned from,\n\t\t\t\tunsigned to,\n\t\t\t\tint *partial,\n\t\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t\tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1128-1147",
    "snippet": "struct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_getblk",
          "args": [
            "handle",
            "inode",
            "block",
            "create",
            "err"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1062-1126",
          "snippet": "struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_getblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1062-1126",
    "snippet": "struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"not a new buffer\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call get_create_access\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "create != 0"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&dummy"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "dummy.b_blocknr"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&dummy"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err > 1"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_blocks_handle",
          "args": [
            "handle",
            "inode",
            "block",
            "1",
            "&dummy",
            "create"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_blocks_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "857-1008",
          "snippet": "int ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_trace_init",
          "args": [
            "&dummy.b_history"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL || create == 0"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1052-1057",
    "snippet": "int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t    ext3_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_fiemap",
          "args": [
            "inode",
            "fieinfo",
            "start",
            "len",
            "ext3_get_block"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "409-418",
          "snippet": "int generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t    ext3_get_block);\n}"
  },
  {
    "function_name": "ext3_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "1021-1050",
    "snippet": "static int ext3_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tint ret = 0, started = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\n\tif (create && !handle) {\t/* Direct IO write... */\n\t\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n\t\thandle = ext3_journal_start(inode, DIO_CREDITS +\n\t\t\t\tEXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext3_get_blocks_handle(handle, inode, iblock,\n\t\t\t\t\tmax_blocks, bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text3_journal_stop(handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [
      "#define DIO_CREDITS 25",
      "#define DIO_MAX_BLOCKS 4096"
    ],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_blocks_handle",
          "args": [
            "handle",
            "inode",
            "iblock",
            "max_blocks",
            "bh_result",
            "create"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_blocks_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "857-1008",
          "snippet": "int ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "DIO_CREDITS +\n\t\t\t\tEXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb)"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\n#define DIO_CREDITS 25\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = ext3_journal_current_handle();\n\tint ret = 0, started = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\n\tif (create && !handle) {\t/* Direct IO write... */\n\t\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n\t\thandle = ext3_journal_start(inode, DIO_CREDITS +\n\t\t\t\tEXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext3_get_blocks_handle(handle, inode, iblock,\n\t\t\t\t\tmax_blocks, bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text3_journal_stop(handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_get_blocks_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "857-1008",
    "snippet": "int ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_get_blocks_exit",
          "args": [
            "inode",
            "iblock",
            "depth ? le32_to_cpu(chain[depth-1].key) : 0",
            "count",
            "err"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "chain[depth-1].key"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_result",
            "\"returned\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_boundary",
          "args": [
            "bh_result"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "le32_to_cpu(chain[depth-1].key)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_splice_branch",
          "args": [
            "handle",
            "inode",
            "iblock",
            "partial",
            "indirect_blks",
            "count"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_splice_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "747-836",
          "snippet": "static int ext3_splice_branch(handle_t *handle, struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tint err = 0;\n\tstruct ext3_block_alloc_info *block_i;\n\text3_fsblk_t current_block;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct timespec now;\n\n\tblock_i = ei->i_block_alloc_info;\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\tnow = CURRENT_TIME_SEC;\n\tif (!timespec_equal(&inode->i_ctime, &now) || !where->bh) {\n\t\tinode->i_ctime = now;\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\t/* ext3_mark_inode_dirty already updated i_sync_tid */\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext3_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t * Inode was dirtied above.\n\t\t */\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\tBUFFER_TRACE(where[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, where[i].bh);\n\t\text3_free_blocks(handle,inode,le32_to_cpu(where[i-1].key),1);\n\t}\n\text3_free_blocks(handle, inode, le32_to_cpu(where[num].key), blks);\n\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_splice_branch(handle_t *handle, struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tint err = 0;\n\tstruct ext3_block_alloc_info *block_i;\n\text3_fsblk_t current_block;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct timespec now;\n\n\tblock_i = ei->i_block_alloc_info;\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\tnow = CURRENT_TIME_SEC;\n\tif (!timespec_equal(&inode->i_ctime, &now) || !where->bh) {\n\t\tinode->i_ctime = now;\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\t/* ext3_mark_inode_dirty already updated i_sync_tid */\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext3_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t * Inode was dirtied above.\n\t\t */\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\tBUFFER_TRACE(where[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, where[i].bh);\n\t\text3_free_blocks(handle,inode,le32_to_cpu(where[i-1].key),1);\n\t}\n\text3_free_blocks(handle, inode, le32_to_cpu(where[num].key), blks);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_alloc_branch",
          "args": [
            "handle",
            "inode",
            "indirect_blks",
            "&count",
            "goal",
            "offsets + (partial - chain)",
            "partial"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_alloc_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "653-732",
          "snippet": "static int ext3_alloc_branch(handle_t *handle, struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext3_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text3_fsblk_t new_blocks[4];\n\text3_fsblk_t current_block;\n\n\tnum = ext3_alloc_blocks(handle, inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext3_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\t*blks = num;\n\treturn err;\nfailed:\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i <= n ; i++) {\n\t\tBUFFER_TRACE(branch[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, branch[i].bh);\n\t}\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\n\text3_free_blocks(handle, inode, new_blocks[i], num);\n\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_alloc_branch(handle_t *handle, struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext3_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text3_fsblk_t new_blocks[4];\n\text3_fsblk_t current_block;\n\n\tnum = ext3_alloc_blocks(handle, inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext3_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\t*blks = num;\n\treturn err;\nfailed:\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i <= n ; i++) {\n\t\tBUFFER_TRACE(branch[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, branch[i].bh);\n\t}\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\n\text3_free_blocks(handle, inode, new_blocks[i], num);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_blks_to_allocate",
          "args": [
            "partial",
            "indirect_blks",
            "maxblocks",
            "blocks_to_boundary"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blks_to_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "535-559",
          "snippet": "static int ext3_blks_to_allocate(Indirect *branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_blks_to_allocate(Indirect *branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_goal",
          "args": [
            "inode",
            "iblock",
            "partial"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "504-521",
          "snippet": "static ext3_fsblk_t ext3_find_goal(struct inode *inode, long block,\n\t\t\t\t   Indirect *partial)\n{\n\tstruct ext3_block_alloc_info *block_i;\n\n\tblock_i =  EXT3_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext3_find_near(inode, partial);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic ext3_fsblk_t ext3_find_goal(struct inode *inode, long block,\n\t\t\t\t   Indirect *partial)\n{\n\tstruct ext3_block_alloc_info *block_i;\n\n\tblock_i =  EXT3_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext3_find_near(inode, partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_init_block_alloc_info",
          "args": [
            "inode"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_block_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "419-446",
          "snippet": "void ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_branch",
          "args": [
            "inode",
            "depth",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "410-444",
          "snippet": "static Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "partial"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "304-309",
          "snippet": "static int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_block_to_path",
          "args": [
            "inode",
            "iblock",
            "offsets",
            "&blocks_to_boundary"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "342-379",
          "snippet": "static int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL || create == 0"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_get_blocks_enter",
          "args": [
            "inode",
            "iblock",
            "maxblocks",
            "create"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_splice_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "747-836",
    "snippet": "static int ext3_splice_branch(handle_t *handle, struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tint err = 0;\n\tstruct ext3_block_alloc_info *block_i;\n\text3_fsblk_t current_block;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct timespec now;\n\n\tblock_i = ei->i_block_alloc_info;\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\tnow = CURRENT_TIME_SEC;\n\tif (!timespec_equal(&inode->i_ctime, &now) || !where->bh) {\n\t\tinode->i_ctime = now;\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\t/* ext3_mark_inode_dirty already updated i_sync_tid */\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext3_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t * Inode was dirtied above.\n\t\t */\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\tBUFFER_TRACE(where[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, where[i].bh);\n\t\text3_free_blocks(handle,inode,le32_to_cpu(where[i-1].key),1);\n\t}\n\text3_free_blocks(handle, inode, le32_to_cpu(where[num].key), blks);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "le32_to_cpu(where[num].key)",
            "blks"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "where[num].key"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_forget",
          "args": [
            "handle",
            "where[i].bh"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "where[i].bh",
            "\"call journal_forget\""
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"splicing direct\\n\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "where->bh"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "where->bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"splicing indirect only\\n\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_datasync_tid",
            "handle->h_transaction->t_tid"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_ctime",
            "&now"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "current_block++"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "where->bh"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "where->bh",
            "\"get_write_access\""
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_splice_branch(handle_t *handle, struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tint err = 0;\n\tstruct ext3_block_alloc_info *block_i;\n\text3_fsblk_t current_block;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct timespec now;\n\n\tblock_i = ei->i_block_alloc_info;\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\tnow = CURRENT_TIME_SEC;\n\tif (!timespec_equal(&inode->i_ctime, &now) || !where->bh) {\n\t\tinode->i_ctime = now;\n\t\text3_mark_inode_dirty(handle, inode);\n\t}\n\t/* ext3_mark_inode_dirty already updated i_sync_tid */\n\tatomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext3_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t * Inode was dirtied above.\n\t\t */\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\tBUFFER_TRACE(where[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, where[i].bh);\n\t\text3_free_blocks(handle,inode,le32_to_cpu(where[i-1].key),1);\n\t}\n\text3_free_blocks(handle, inode, le32_to_cpu(where[num].key), blks);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_alloc_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "653-732",
    "snippet": "static int ext3_alloc_branch(handle_t *handle, struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext3_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text3_fsblk_t new_blocks[4];\n\text3_fsblk_t current_block;\n\n\tnum = ext3_alloc_blocks(handle, inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext3_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\t*blks = num;\n\treturn err;\nfailed:\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i <= n ; i++) {\n\t\tBUFFER_TRACE(branch[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, branch[i].bh);\n\t}\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\n\text3_free_blocks(handle, inode, new_blocks[i], num);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "new_blocks[i]",
            "num"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_forget",
          "args": [
            "handle",
            "branch[i].bh"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "branch[i].bh",
            "\"call journal_forget\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"marking uptodate\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "++current_block"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_blocks[n]"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "blocksize"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call get_create_access\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "new_blocks[n-1]"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_blocks[0]"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_alloc_blocks",
          "args": [
            "handle",
            "inode",
            "goal",
            "indirect_blks",
            "*blks",
            "new_blocks",
            "&err"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "575-624",
          "snippet": "static int ext3_alloc_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text3_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text3_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext3_new_blocks(handle,inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_alloc_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text3_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text3_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext3_new_blocks(handle,inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_alloc_branch(handle_t *handle, struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext3_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text3_fsblk_t new_blocks[4];\n\text3_fsblk_t current_block;\n\n\tnum = ext3_alloc_blocks(handle, inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext3_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\t*blks = num;\n\treturn err;\nfailed:\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i <= n ; i++) {\n\t\tBUFFER_TRACE(branch[i].bh, \"call journal_forget\");\n\t\text3_journal_forget(handle, branch[i].bh);\n\t}\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\n\text3_free_blocks(handle, inode, new_blocks[i], num);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_alloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "575-624",
    "snippet": "static int ext3_alloc_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text3_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text3_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext3_new_blocks(handle,inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "new_blocks[i]",
            "1"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_new_blocks",
          "args": [
            "handle",
            "inode",
            "goal",
            "&count",
            "err"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1486-1761",
          "snippet": "ext3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_alloc_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text3_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text3_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext3_new_blocks(handle,inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text3_free_blocks(handle, inode, new_blocks[i], 1);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_blks_to_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "535-559",
    "snippet": "static int ext3_blks_to_allocate(Indirect *branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*(branch[0].p + count)"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_blks_to_allocate(Indirect *branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext3_find_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "504-521",
    "snippet": "static ext3_fsblk_t ext3_find_goal(struct inode *inode, long block,\n\t\t\t\t   Indirect *partial)\n{\n\tstruct ext3_block_alloc_info *block_i;\n\n\tblock_i =  EXT3_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext3_find_near(inode, partial);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_find_near",
          "args": [
            "inode",
            "partial"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "466-492",
          "snippet": "static ext3_fsblk_t ext3_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *start = ind->bh ? (__le32*) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text3_fsblk_t bg_start;\n\text3_grpblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\tbg_start = ext3_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic ext3_fsblk_t ext3_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *start = ind->bh ? (__le32*) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text3_fsblk_t bg_start;\n\text3_grpblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\tbg_start = ext3_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic ext3_fsblk_t ext3_find_goal(struct inode *inode, long block,\n\t\t\t\t   Indirect *partial)\n{\n\tstruct ext3_block_alloc_info *block_i;\n\n\tblock_i =  EXT3_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext3_find_near(inode, partial);\n}"
  },
  {
    "function_name": "ext3_find_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "466-492",
    "snippet": "static ext3_fsblk_t ext3_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *start = ind->bh ? (__le32*) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text3_fsblk_t bg_start;\n\text3_grpblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\tbg_start = ext3_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);",
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "inode->i_sb",
            "ei->i_block_group"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic ext3_fsblk_t ext3_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *start = ind->bh ? (__le32*) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text3_fsblk_t bg_start;\n\text3_grpblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\tbg_start = ext3_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}"
  },
  {
    "function_name": "ext3_get_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "410-444",
    "snippet": "static Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_chain",
          "args": [
            "++p",
            "bh",
            "(__le32*)bh->b_data + *++offsets"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "298-302",
          "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "p"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "304-309",
          "snippet": "static int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(p->key)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "p->key"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic Indirect *ext3_get_branch(struct inode *inode, int depth, int *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\t/* Reader: pointers */\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
  },
  {
    "function_name": "ext3_block_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "342-379",
    "snippet": "static int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "inode->i_sb",
            "\"ext3_block_to_path\"",
            "\"block > big\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT3_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text3_warning (inode->i_sb, \"ext3_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT3_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT3_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT3_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text3_warning(inode->i_sb, \"ext3_block_to_path\", \"block > big\");\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
  },
  {
    "function_name": "verify_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "304-309",
    "snippet": "static int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstatic int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
  },
  {
    "function_name": "add_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "298-302",
    "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
  },
  {
    "function_name": "ext3_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "188-290",
    "snippet": "void ext3_evict_inode (struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *rsv;\n\thandle_t *handle;\n\tint want_delete = 0;\n\n\ttrace_ext3_evict_inode(inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\twant_delete = 1;\n\t}\n\n\t/*\n\t * When journalling data dirty buffers are tracked only in the journal.\n\t * So although mm thinks everything is clean and ready for reaping the\n\t * inode might still have some pages to write in the running\n\t * transaction or waiting to be checkpointed. Thus calling\n\t * journal_invalidatepage() (via truncate_inode_pages()) to discard\n\t * these buffers can cause data loss. Also even if we did not discard\n\t * these buffers, we would have no way to find them after the inode\n\t * is reaped and thus user could see stale data if he tries to read\n\t * them before the transaction is checkpointed. So be careful and\n\t * force everything to disk here... We use ei->i_datasync_tid to\n\t * store the newest transaction containing inode's data.\n\t *\n\t * Note that directories do not have this problem because they don't\n\t * use page cache.\n\t *\n\t * The s_journal check handles the case when ext3_get_journal() fails\n\t * and puts the journal inode.\n\t */\n\tif (inode->i_nlink && ext3_should_journal_data(inode) &&\n\t    EXT3_SB(inode->i_sb)->s_journal &&\n\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t    inode->i_ino != EXT3_JOURNAL_INO) {\n\t\ttid_t commit_tid = atomic_read(&ei->i_datasync_tid);\n\t\tjournal_t *journal = EXT3_SB(inode->i_sb)->s_journal;\n\n\t\tlog_start_commit(journal, commit_tid);\n\t\tlog_wait_commit(journal, commit_tid);\n\t\tfilemap_write_and_wait(&inode->i_data);\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\text3_discard_reservation(inode);\n\trsv = ei->i_block_alloc_info;\n\tei->i_block_alloc_info = NULL;\n\tif (unlikely(rsv))\n\t\tkfree(rsv);\n\n\tif (!want_delete)\n\t\tgoto no_delete;\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text3_orphan_del(NULL, inode);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\n\tinode->i_size = 0;\n\tif (inode->i_blocks)\n\t\text3_truncate(inode);\n\t/*\n\t * Kill off the orphan record created when the inode lost the last\n\t * link.  Note that ext3_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - ext3_truncate() could\n\t * have removed the record.\n\t */\n\text3_orphan_del(handle, inode);\n\tei->i_dtime = get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext3_mark_inode_dirty(handle, inode)) {\n\t\t/* If that failed, just dquot_drop() and be done with that */\n\t\tdquot_drop(inode);\n\t\tclear_inode(inode);\n\t} else {\n\t\text3_xattr_delete_inode(handle, inode);\n\t\tdquot_free_inode(inode);\n\t\tdquot_drop(inode);\n\t\tclear_inode(inode);\n\t\text3_free_inode(handle, inode);\n\t}\n\text3_journal_stop(handle);\n\treturn;\nno_delete:\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "79-167",
          "snippet": "void ext3_free_inode (handle_t *handle, struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext3_group_desc * gdp;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint fatal = 0, err;\n\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\tprintk (\"ext3_free_inode: inode has count=%d\\n\",\n\t\t\t\t\tatomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\tprintk (\"ext3_free_inode: inode has nlink=%d\\n\",\n\t\t\tinode->i_nlink);\n\t\treturn;\n\t}\n\tif (!sb) {\n\t\tprintk(\"ext3_free_inode: inode on nonexistent device\\n\");\n\t\treturn;\n\t}\n\tsbi = EXT3_SB(sb);\n\n\tino = inode->i_ino;\n\text3_debug (\"freeing inode %lu\\n\", ino);\n\ttrace_ext3_free_inode(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tes = EXT3_SB(sb)->s_es;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\tbit, bitmap_bh->b_data))\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse {\n\t\tgdp = ext3_get_group_desc (sb, block_group, &bh2);\n\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext3_journal_get_write_access(handle, bh2);\n\t\tif (fatal) goto error_return;\n\n\t\tif (gdp) {\n\t\t\tspin_lock(sb_bgl_lock(sbi, block_group));\n\t\t\tle16_add_cpu(&gdp->bg_free_inodes_count, 1);\n\t\t\tif (is_directory)\n\t\t\t\tle16_add_cpu(&gdp->bg_used_dirs_count, -1);\n\t\t\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\t\t\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\t\t\tif (is_directory)\n\t\t\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\n\t\t}\n\t\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\tif (!fatal) fatal = err;\n\t}\n\tBUFFER_TRACE(bitmap_bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!fatal)\n\t\tfatal = err;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, fatal);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_inode (handle_t *handle, struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext3_group_desc * gdp;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint fatal = 0, err;\n\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\tprintk (\"ext3_free_inode: inode has count=%d\\n\",\n\t\t\t\t\tatomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\tprintk (\"ext3_free_inode: inode has nlink=%d\\n\",\n\t\t\tinode->i_nlink);\n\t\treturn;\n\t}\n\tif (!sb) {\n\t\tprintk(\"ext3_free_inode: inode on nonexistent device\\n\");\n\t\treturn;\n\t}\n\tsbi = EXT3_SB(sb);\n\n\tino = inode->i_ino;\n\text3_debug (\"freeing inode %lu\\n\", ino);\n\ttrace_ext3_free_inode(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tes = EXT3_SB(sb)->s_es;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\tbit, bitmap_bh->b_data))\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse {\n\t\tgdp = ext3_get_group_desc (sb, block_group, &bh2);\n\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext3_journal_get_write_access(handle, bh2);\n\t\tif (fatal) goto error_return;\n\n\t\tif (gdp) {\n\t\t\tspin_lock(sb_bgl_lock(sbi, block_group));\n\t\t\tle16_add_cpu(&gdp->bg_free_inodes_count, 1);\n\t\t\tif (is_directory)\n\t\t\t\tle16_add_cpu(&gdp->bg_used_dirs_count, -1);\n\t\t\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\t\t\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\t\t\tif (is_directory)\n\t\t\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\n\t\t}\n\t\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\tif (!fatal) fatal = err;\n\t}\n\tBUFFER_TRACE(bitmap_bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!fatal)\n\t\tfatal = err;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, fatal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_delete_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.h",
          "lines": "102-105",
          "snippet": "static inline void\next3_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline void\next3_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_truncate",
          "args": [
            "inode"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2493-2645",
          "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "inode"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "136-146",
          "snippet": "static handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rsv"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rsv"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_discard_reservation",
          "args": [
            "inode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_discard_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "461-480",
          "snippet": "void ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "&inode->i_data"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_start_commit",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "490-498",
          "snippet": "int log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ei->i_datasync_tid"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_evict_inode",
          "args": [
            "inode"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_evict_inode (struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *rsv;\n\thandle_t *handle;\n\tint want_delete = 0;\n\n\ttrace_ext3_evict_inode(inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\twant_delete = 1;\n\t}\n\n\t/*\n\t * When journalling data dirty buffers are tracked only in the journal.\n\t * So although mm thinks everything is clean and ready for reaping the\n\t * inode might still have some pages to write in the running\n\t * transaction or waiting to be checkpointed. Thus calling\n\t * journal_invalidatepage() (via truncate_inode_pages()) to discard\n\t * these buffers can cause data loss. Also even if we did not discard\n\t * these buffers, we would have no way to find them after the inode\n\t * is reaped and thus user could see stale data if he tries to read\n\t * them before the transaction is checkpointed. So be careful and\n\t * force everything to disk here... We use ei->i_datasync_tid to\n\t * store the newest transaction containing inode's data.\n\t *\n\t * Note that directories do not have this problem because they don't\n\t * use page cache.\n\t *\n\t * The s_journal check handles the case when ext3_get_journal() fails\n\t * and puts the journal inode.\n\t */\n\tif (inode->i_nlink && ext3_should_journal_data(inode) &&\n\t    EXT3_SB(inode->i_sb)->s_journal &&\n\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t    inode->i_ino != EXT3_JOURNAL_INO) {\n\t\ttid_t commit_tid = atomic_read(&ei->i_datasync_tid);\n\t\tjournal_t *journal = EXT3_SB(inode->i_sb)->s_journal;\n\n\t\tlog_start_commit(journal, commit_tid);\n\t\tlog_wait_commit(journal, commit_tid);\n\t\tfilemap_write_and_wait(&inode->i_data);\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\text3_discard_reservation(inode);\n\trsv = ei->i_block_alloc_info;\n\tei->i_block_alloc_info = NULL;\n\tif (unlikely(rsv))\n\t\tkfree(rsv);\n\n\tif (!want_delete)\n\t\tgoto no_delete;\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text3_orphan_del(NULL, inode);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\n\tinode->i_size = 0;\n\tif (inode->i_blocks)\n\t\text3_truncate(inode);\n\t/*\n\t * Kill off the orphan record created when the inode lost the last\n\t * link.  Note that ext3_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - ext3_truncate() could\n\t * have removed the record.\n\t */\n\text3_orphan_del(handle, inode);\n\tei->i_dtime = get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext3_mark_inode_dirty(handle, inode)) {\n\t\t/* If that failed, just dquot_drop() and be done with that */\n\t\tdquot_drop(inode);\n\t\tclear_inode(inode);\n\t} else {\n\t\text3_xattr_delete_inode(handle, inode);\n\t\tdquot_free_inode(inode);\n\t\tdquot_drop(inode);\n\t\tclear_inode(inode);\n\t\text3_free_inode(handle, inode);\n\t}\n\text3_journal_stop(handle);\n\treturn;\nno_delete:\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}"
  },
  {
    "function_name": "truncate_restart_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "168-183",
    "snippet": "static int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&EXT3_I(inode)->truncate_mutex"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_restart",
          "args": [
            "handle",
            "blocks_for_truncate(inode)"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1281-1284",
          "snippet": "static inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "103-124",
          "snippet": "static unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_I(inode)->truncate_mutex"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"restarting handle %p\\n\"",
            "handle"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int truncate_restart_transaction(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t/*\n\t * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle\n\t * At this moment, get_block can be called only for blocks inside\n\t * i_size since page cache has been already dropped and writes are\n\t * blocked by i_mutex. So we can safely drop the truncate_mutex.\n\t */\n\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\tret = ext3_journal_restart(handle, blocks_for_truncate(inode));\n\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "try_to_extend_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "154-161",
    "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_extend",
          "args": [
            "handle",
            "blocks_for_truncate(inode)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1276-1279",
          "snippet": "static inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "103-124",
          "snippet": "static unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)\n\t\treturn 0;\n\tif (!ext3_journal_extend(handle, blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "start_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "136-146",
    "snippet": "static handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "PTR_ERR(result)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "result"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "result"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "blocks_for_truncate(inode)"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "103-124",
          "snippet": "static unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext3_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text3_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}"
  },
  {
    "function_name": "blocks_for_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "103-124",
    "snippet": "static unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic unsigned long blocks_for_truncate(struct inode *inode)\n{\n\tunsigned long needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext3 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT3_MAX_TRANS_DATA)\n\t\tneeded = EXT3_MAX_TRANS_DATA;\n\n\treturn EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
  },
  {
    "function_name": "ext3_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "58-97",
    "snippet": "int ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"exit\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_abort",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"error %d when attempting revoke\"",
            "err"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "275-310",
          "snippet": "void ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_revoke",
          "args": [
            "handle",
            "blocknr",
            "bh"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_revoke\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_forget",
          "args": [
            "handle",
            "bh"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call journal_forget\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\"",
            "bh",
            "is_metadata",
            "inode->i_mode",
            "test_opt(inode->i_sb, DATA_FLAGS)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"enter\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_forget",
          "args": [
            "inode",
            "is_metadata",
            "blocknr"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_inode_is_fast_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
    "lines": "41-47",
    "snippet": "static int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highuid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_writepage_trans_blocks(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstatic int ext3_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT3_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
  }
]