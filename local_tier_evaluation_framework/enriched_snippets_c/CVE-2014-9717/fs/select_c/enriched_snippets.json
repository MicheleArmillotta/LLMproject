[
  {
    "function_name": "do_restart_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "935-955",
    "snippet": "static long do_restart_poll(struct restart_block *restart_block)\n{\n\tstruct pollfd __user *ufds = restart_block->poll.ufds;\n\tint nfds = restart_block->poll.nfds;\n\tstruct timespec *to = NULL, end_time;\n\tint ret;\n\n\tif (restart_block->poll.has_timeout) {\n\t\tend_time.tv_sec = restart_block->poll.tv_sec;\n\t\tend_time.tv_nsec = restart_block->poll.tv_nsec;\n\t\tto = &end_time;\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\trestart_block->fn = do_restart_poll;\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sys_poll",
          "args": [
            "ufds",
            "nfds",
            "to"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "do_sys_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "870-933",
          "snippet": "int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(nfds, head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))",
            "#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))\n#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))\n\nint do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(nfds, head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long do_restart_poll(struct restart_block *restart_block)\n{\n\tstruct pollfd __user *ufds = restart_block->poll.ufds;\n\tint nfds = restart_block->poll.nfds;\n\tstruct timespec *to = NULL, end_time;\n\tint ret;\n\n\tif (restart_block->poll.has_timeout) {\n\t\tend_time.tv_sec = restart_block->poll.tv_sec;\n\t\tend_time.tv_nsec = restart_block->poll.tv_nsec;\n\t\tto = &end_time;\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\trestart_block->fn = do_restart_poll;\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sys_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "870-933",
    "snippet": "int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(nfds, head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))",
      "#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pos"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "fds[j].revents",
            "&ufds->revents"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_freewait",
          "args": [
            "&table"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "poll_freewait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "136-155",
          "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_poll",
          "args": [
            "nfds",
            "head",
            "&table",
            "end_time"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "do_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "781-865",
          "snippet": "static int do_poll(unsigned int nfds,  struct poll_list *list,\n\t\t   struct poll_wqueues *wait, struct timespec *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int do_poll(unsigned int nfds,  struct poll_list *list,\n\t\t   struct poll_wqueues *wait, struct timespec *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_initwait",
          "args": [
            "&table"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "poll_initwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "119-127",
          "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "todo",
            "POLLFD_PER_PAGE"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "walk->entries",
            "ufds + nfds-todo",
            "sizeof(struct pollfd) * walk->len"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "nfds",
            "N_STACK_PPS"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))\n#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))\n\nint do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(nfds, head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "do_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "781-865",
    "snippet": "static int do_poll(unsigned int nfds,  struct poll_list *list,\n\t\t   struct poll_wqueues *wait, struct timespec *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_schedule_timeout",
          "args": [
            "wait",
            "TASK_INTERRUPTIBLE",
            "to",
            "slack"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "poll_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "234-258",
          "snippet": "int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_to_ktime",
          "args": [
            "*end_time"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_timeout",
          "args": [
            "busy_end"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_end_time",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pollfd",
          "args": [
            "pfd",
            "pt",
            "&can_busy_loop",
            "busy_flag"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "do_pollfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "750-779",
          "snippet": "static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     unsigned int busy_flag)\n{\n\tunsigned int mask;\n\tint fd;\n\n\tmask = 0;\n\tfd = pollfd->fd;\n\tif (fd >= 0) {\n\t\tstruct fd f = fdget(fd);\n\t\tmask = POLLNVAL;\n\t\tif (f.file) {\n\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\tif (f.file->f_op->poll) {\n\t\t\t\tpwait->_key = pollfd->events|POLLERR|POLLHUP;\n\t\t\t\tpwait->_key |= busy_flag;\n\t\t\t\tmask = f.file->f_op->poll(f.file, pwait);\n\t\t\t\tif (mask & busy_flag)\n\t\t\t\t\t*can_busy_poll = true;\n\t\t\t}\n\t\t\t/* Mask out unneeded events. */\n\t\t\tmask &= pollfd->events | POLLERR | POLLHUP;\n\t\t\tfdput(f);\n\t\t}\n\t}\n\tpollfd->revents = mask;\n\n\treturn mask;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     unsigned int busy_flag)\n{\n\tunsigned int mask;\n\tint fd;\n\n\tmask = 0;\n\tfd = pollfd->fd;\n\tif (fd >= 0) {\n\t\tstruct fd f = fdget(fd);\n\t\tmask = POLLNVAL;\n\t\tif (f.file) {\n\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\tif (f.file->f_op->poll) {\n\t\t\t\tpwait->_key = pollfd->events|POLLERR|POLLHUP;\n\t\t\t\tpwait->_key |= busy_flag;\n\t\t\t\tmask = f.file->f_op->poll(f.file, pwait);\n\t\t\t\tif (mask & busy_flag)\n\t\t\t\t\t*can_busy_poll = true;\n\t\t\t}\n\t\t\t/* Mask out unneeded events. */\n\t\t\tmask &= pollfd->events | POLLERR | POLLHUP;\n\t\t\tfdput(f);\n\t\t}\n\t}\n\tpollfd->revents = mask;\n\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "end_time"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "73-91",
          "snippet": "long select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int do_poll(unsigned int nfds,  struct poll_list *list,\n\t\t   struct poll_wqueues *wait, struct timespec *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "do_pollfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "750-779",
    "snippet": "static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     unsigned int busy_flag)\n{\n\tunsigned int mask;\n\tint fd;\n\n\tmask = 0;\n\tfd = pollfd->fd;\n\tif (fd >= 0) {\n\t\tstruct fd f = fdget(fd);\n\t\tmask = POLLNVAL;\n\t\tif (f.file) {\n\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\tif (f.file->f_op->poll) {\n\t\t\t\tpwait->_key = pollfd->events|POLLERR|POLLHUP;\n\t\t\t\tpwait->_key |= busy_flag;\n\t\t\t\tmask = f.file->f_op->poll(f.file, pwait);\n\t\t\t\tif (mask & busy_flag)\n\t\t\t\t\t*can_busy_poll = true;\n\t\t\t}\n\t\t\t/* Mask out unneeded events. */\n\t\t\tmask &= pollfd->events | POLLERR | POLLHUP;\n\t\t\tfdput(f);\n\t\t}\n\t}\n\tpollfd->revents = mask;\n\n\treturn mask;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f.file->f_op->poll",
          "args": [
            "f.file",
            "pwait"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     unsigned int busy_flag)\n{\n\tunsigned int mask;\n\tint fd;\n\n\tmask = 0;\n\tfd = pollfd->fd;\n\tif (fd >= 0) {\n\t\tstruct fd f = fdget(fd);\n\t\tmask = POLLNVAL;\n\t\tif (f.file) {\n\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\tif (f.file->f_op->poll) {\n\t\t\t\tpwait->_key = pollfd->events|POLLERR|POLLHUP;\n\t\t\t\tpwait->_key |= busy_flag;\n\t\t\t\tmask = f.file->f_op->poll(f.file, pwait);\n\t\t\t\tif (mask & busy_flag)\n\t\t\t\t\t*can_busy_poll = true;\n\t\t\t}\n\t\t\t/* Mask out unneeded events. */\n\t\t\tmask &= pollfd->events | POLLERR | POLLHUP;\n\t\t\tfdput(f);\n\t\t}\n\t}\n\tpollfd->revents = mask;\n\n\treturn mask;\n}"
  },
  {
    "function_name": "do_pselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "646-692",
    "snippet": "static long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timespec __user *tsp,\n\t\t       const sigset_t __user *sigmask, size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigsaved",
            "NULL"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&current->saved_sigmask",
            "&sigsaved",
            "sizeof(sigsaved)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_select_copy_remaining",
          "args": [
            "&end_time",
            "tsp",
            "0",
            "ret"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_copy_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "289-334",
          "snippet": "static int poll_select_copy_remaining(struct timespec *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts(&rts);\n\trts = timespec_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!copy_to_user(p, &rts, sizeof(rts)))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic int poll_select_copy_remaining(struct timespec *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts(&rts);\n\trts = timespec_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!copy_to_user(p, &rts, sizeof(rts)))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_sys_select",
          "args": [
            "n",
            "inp",
            "outp",
            "exp",
            "to"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "core_sys_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "547-620",
          "snippet": "int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tunsigned int size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(6 * size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tunsigned int size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(6 * size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&ksigmask",
            "&sigsaved"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&ksigmask",
            "sigmask(SIGKILL)|sigmask(SIGSTOP)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ksigmask",
            "sigmask",
            "sizeof(ksigmask)"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_select_set_timeout",
          "args": [
            "to",
            "ts.tv_sec",
            "ts.tv_nsec"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "272-287",
          "snippet": "int poll_select_set_timeout(struct timespec *to, long sec, long nsec)\n{\n\tstruct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts(to);\n\t\t*to = timespec_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec *to, long sec, long nsec)\n{\n\tstruct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts(to);\n\t\t*to = timespec_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timespec __user *tsp,\n\t\t       const sigset_t __user *sigmask, size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "core_sys_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "547-620",
    "snippet": "int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tunsigned int size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(6 * size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bits"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fd_set",
          "args": [
            "n",
            "exp",
            "fds.res_ex"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "compat_set_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "1194-1218",
          "snippet": "static\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tunsigned long odd;\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\n\tif (!ufdset)\n\t\treturn 0;\n\n\todd = nr & 1UL;\n\tnr &= ~1UL;\n\twhile (nr) {\n\t\tunsigned long h, l;\n\t\tl = *fdset++;\n\t\th = l >> 32;\n\t\tif (__put_user(l, ufdset) || __put_user(h, ufdset+1))\n\t\t\treturn -EFAULT;\n\t\tufdset += 2;\n\t\tnr -= 2;\n\t}\n\tif (odd && __put_user(*fdset, ufdset))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [
            "#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\n#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))\n\nstatic\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tunsigned long odd;\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\n\tif (!ufdset)\n\t\treturn 0;\n\n\todd = nr & 1UL;\n\tnr &= ~1UL;\n\twhile (nr) {\n\t\tunsigned long h, l;\n\t\tl = *fdset++;\n\t\th = l >> 32;\n\t\tif (__put_user(l, ufdset) || __put_user(h, ufdset+1))\n\t\t\treturn -EFAULT;\n\t\tufdset += 2;\n\t\tnr -= 2;\n\t}\n\tif (odd && __put_user(*fdset, ufdset))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_select",
          "args": [
            "n",
            "&fds",
            "end_time"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "do_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "399-537",
          "snippet": "int do_select(int n, fd_set_bits *fds, struct timespec *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, mask, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\tconst struct file_operations *f_op;\n\t\t\t\t\tf_op = f.file->f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\t\t\tif (f_op->poll) {\n\t\t\t\t\t\twait_key_set(wait, in, out,\n\t\t\t\t\t\t\t     bit, busy_flag);\n\t\t\t\t\t\tmask = (*f_op->poll)(f.file, wait);\n\t\t\t\t\t}\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define POLLEX_SET (POLLPRI)",
            "#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)",
            "#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (POLLPRI)\n#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)\n\nint do_select(int n, fd_set_bits *fds, struct timespec *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, mask, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\tconst struct file_operations *f_op;\n\t\t\t\t\tf_op = f.file->f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\t\t\tif (f_op->poll) {\n\t\t\t\t\t\twait_key_set(wait, in, out,\n\t\t\t\t\t\t\t     bit, busy_flag);\n\t\t\t\t\t\tmask = (*f_op->poll)(f.file, wait);\n\t\t\t\t\t}\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "n",
            "fds.res_ex"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "n",
            "fds.res_out"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "n",
            "fds.res_in"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fd_set",
          "args": [
            "n",
            "exp",
            "fds.ex"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "compat_get_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "1161-1192",
          "snippet": "static\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\tif (ufdset) {\n\t\tunsigned long odd;\n\n\t\tif (!access_ok(VERIFY_WRITE, ufdset, nr*sizeof(compat_ulong_t)))\n\t\t\treturn -EFAULT;\n\n\t\todd = nr & 1UL;\n\t\tnr &= ~1UL;\n\t\twhile (nr) {\n\t\t\tunsigned long h, l;\n\t\t\tif (__get_user(l, ufdset) || __get_user(h, ufdset+1))\n\t\t\t\treturn -EFAULT;\n\t\t\tufdset += 2;\n\t\t\t*fdset++ = h << 32 | l;\n\t\t\tnr -= 2;\n\t\t}\n\t\tif (odd && __get_user(*fdset, ufdset))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t/* Tricky, must clear full unsigned long in the\n\t\t * kernel fdset at the end, this makes sure that\n\t\t * actually happens.\n\t\t */\n\t\tmemset(fdset, 0, ((nr + 1) & ~1)*sizeof(compat_ulong_t));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [
            "#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\n#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))\n\nstatic\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\tif (ufdset) {\n\t\tunsigned long odd;\n\n\t\tif (!access_ok(VERIFY_WRITE, ufdset, nr*sizeof(compat_ulong_t)))\n\t\t\treturn -EFAULT;\n\n\t\todd = nr & 1UL;\n\t\tnr &= ~1UL;\n\t\twhile (nr) {\n\t\t\tunsigned long h, l;\n\t\t\tif (__get_user(l, ufdset) || __get_user(h, ufdset+1))\n\t\t\t\treturn -EFAULT;\n\t\t\tufdset += 2;\n\t\t\t*fdset++ = h << 32 | l;\n\t\t\tnr -= 2;\n\t\t}\n\t\tif (odd && __get_user(*fdset, ufdset))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t/* Tricky, must clear full unsigned long in the\n\t\t * kernel fdset at the end, this makes sure that\n\t\t * actually happens.\n\t\t */\n\t\tmemset(fdset, 0, ((nr + 1) & ~1)*sizeof(compat_ulong_t));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "6 * size",
            "GFP_KERNEL"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "n"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "current->files"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tunsigned int size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(6 * size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "399-537",
    "snippet": "int do_select(int n, fd_set_bits *fds, struct timespec *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, mask, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\tconst struct file_operations *f_op;\n\t\t\t\t\tf_op = f.file->f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\t\t\tif (f_op->poll) {\n\t\t\t\t\t\twait_key_set(wait, in, out,\n\t\t\t\t\t\t\t     bit, busy_flag);\n\t\t\t\t\t\tmask = (*f_op->poll)(f.file, wait);\n\t\t\t\t\t}\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define POLLEX_SET (POLLPRI)",
      "#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)",
      "#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_freewait",
          "args": [
            "&table"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "poll_freewait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "136-155",
          "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_schedule_timeout",
          "args": [
            "&table",
            "TASK_INTERRUPTIBLE",
            "to",
            "slack"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "poll_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "234-258",
          "snippet": "int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_to_ktime",
          "args": [
            "*end_time"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_timeout",
          "args": [
            "busy_end"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_end_time",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "f.file",
            "wait"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_key_set",
          "args": [
            "wait",
            "in",
            "out",
            "bit",
            "busy_flag"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "wait_key_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "388-397",
          "snippet": "static inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\tunsigned int ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define POLLEX_SET (POLLPRI)",
            "#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)",
            "#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (POLLPRI)\n#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)\n\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\tunsigned int ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "i"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "end_time"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "73-91",
          "snippet": "long select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_initwait",
          "args": [
            "&table"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "poll_initwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "119-127",
          "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_select_fd",
          "args": [
            "n",
            "fds"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (POLLPRI)\n#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)\n\nint do_select(int n, fd_set_bits *fds, struct timespec *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tunsigned long slack = 0;\n\tunsigned int busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_end = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, mask, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\tconst struct file_operations *f_op;\n\t\t\t\t\tf_op = f.file->f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n\t\t\t\t\tif (f_op->poll) {\n\t\t\t\t\t\twait_key_set(wait, in, out,\n\t\t\t\t\t\t\t     bit, busy_flag);\n\t\t\t\t\t\tmask = (*f_op->poll)(f.file, wait);\n\t\t\t\t\t}\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_end) {\n\t\t\t\tbusy_end = busy_loop_end_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_end))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "wait_key_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "388-397",
    "snippet": "static inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\tunsigned int ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define POLLEX_SET (POLLPRI)",
      "#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)",
      "#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (POLLPRI)\n#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)\n\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\tunsigned int ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}"
  },
  {
    "function_name": "max_select_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "342-382",
    "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BITS",
          "args": [
            "fds",
            "n"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS",
          "args": [
            "fds",
            "n"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "current->files"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
  },
  {
    "function_name": "poll_select_copy_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "289-334",
    "snippet": "static int poll_select_copy_remaining(struct timespec *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts(&rts);\n\trts = timespec_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!copy_to_user(p, &rts, sizeof(rts)))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&rts",
            "sizeof(rts)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&rtv",
            "sizeof(rtv)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rtv",
            "0",
            "sizeof(rtv)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_sub",
          "args": [
            "*end_time",
            "rts"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts",
          "args": [
            "&rts"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic int poll_select_copy_remaining(struct timespec *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts(&rts);\n\trts = timespec_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!copy_to_user(p, &rts, sizeof(rts)))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
  },
  {
    "function_name": "poll_select_set_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "272-287",
    "snippet": "int poll_select_set_timeout(struct timespec *to, long sec, long nsec)\n{\n\tstruct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts(to);\n\t\t*to = timespec_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_add_safe",
          "args": [
            "*to",
            "ts"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts",
          "args": [
            "to"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_valid",
          "args": [
            "&ts"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec *to, long sec, long nsec)\n{\n\tstruct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts(to);\n\t\t*to = timespec_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "poll_schedule_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "234-258",
    "snippet": "int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_mb",
          "args": [
            "pwq->triggered",
            "0"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "expires",
            "slack",
            "HRTIMER_MODE_ABS"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following set_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tset_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__pollwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "219-232",
    "snippet": "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t\t\tpoll_table *p)\n{\n\tstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\n\tstruct poll_table_entry *entry = poll_get_entry(pwq);\n\tif (!entry)\n\t\treturn;\n\tentry->filp = get_file(filp);\n\tentry->wait_address = wait_address;\n\tentry->key = p->_key;\n\tinit_waitqueue_func_entry(&entry->wait, pollwake);\n\tentry->wait.private = pwq;\n\tadd_wait_queue(wait_address, &entry->wait);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "wait_address",
            "&entry->wait"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&entry->wait",
            "pollwake"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "filp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_get_entry",
          "args": [
            "pwq"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "poll_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "158-180",
          "snippet": "static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structpoll_wqueues",
            "pt"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t\t\tpoll_table *p)\n{\n\tstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\n\tstruct poll_table_entry *entry = poll_get_entry(pwq);\n\tif (!entry)\n\t\treturn;\n\tentry->filp = get_file(filp);\n\tentry->wait_address = wait_address;\n\tentry->key = p->_key;\n\tinit_waitqueue_func_entry(&entry->wait, pollwake);\n\tentry->wait.private = pwq;\n\tadd_wait_queue(wait_address, &entry->wait);\n}"
  },
  {
    "function_name": "pollwake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "208-216",
    "snippet": "static int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_table_entry *entry;\n\n\tentry = container_of(wait, struct poll_table_entry, wait);\n\tif (key && !((unsigned long)key & entry->key))\n\t\treturn 0;\n\treturn __pollwake(wait, mode, sync, key);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pollwake",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "__pollwake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "182-206",
          "snippet": "static int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with set_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with set_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structpoll_table_entry",
            "wait"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_table_entry *entry;\n\n\tentry = container_of(wait, struct poll_table_entry, wait);\n\tif (key && !((unsigned long)key & entry->key))\n\t\treturn 0;\n\treturn __pollwake(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "__pollwake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "182-206",
    "snippet": "static int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with set_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "&dummy_wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "dummy_wait",
            "pwq->polling_task"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with set_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}"
  },
  {
    "function_name": "poll_get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "158-180",
    "snippet": "static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POLL_TABLE_FULL",
          "args": [
            "table"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}"
  },
  {
    "function_name": "poll_freewait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "136-155",
    "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) old"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_poll_entry",
          "args": [
            "entry"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "free_poll_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "130-134",
          "snippet": "static void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
  },
  {
    "function_name": "free_poll_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "130-134",
    "snippet": "static void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "entry->filp"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "entry->wait_address",
            "&entry->wait"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}"
  },
  {
    "function_name": "poll_initwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "119-127",
    "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pwq->pt",
            "__pollwait"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
  },
  {
    "function_name": "select_estimate_accuracy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "73-91",
    "snippet": "long select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__estimate_accuracy",
          "args": [
            "&now"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "50-71",
          "snippet": "static long __estimate_accuracy(struct timespec *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_SLACK\t(100 * NSEC_PER_MSEC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MAX_SLACK\t(100 * NSEC_PER_MSEC)\n\nstatic long __estimate_accuracy(struct timespec *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_sub",
          "args": [
            "*tv",
            "now"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts",
          "args": [
            "&now"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
  },
  {
    "function_name": "__estimate_accuracy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
    "lines": "50-71",
    "snippet": "static long __estimate_accuracy(struct timespec *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_SLACK\t(100 * NSEC_PER_MSEC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MAX_SLACK\t(100 * NSEC_PER_MSEC)\n\nstatic long __estimate_accuracy(struct timespec *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}"
  }
]