[
  {
    "function_name": "hfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/attr.c",
    "lines": "106-121",
    "snippet": "ssize_t hfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer || !size)\n\t\treturn HFS_ATTRLIST_SIZE;\n\tif (size < HFS_ATTRLIST_SIZE)\n\t\treturn -ERANGE;\n\tstrcpy(buffer, \"hfs.type\");\n\tstrcpy(buffer + sizeof(\"hfs.type\"), \"hfs.creator\");\n\n\treturn HFS_ATTRLIST_SIZE;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define HFS_ATTRLIST_SIZE (sizeof(\"hfs.creator\")+sizeof(\"hfs.type\"))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer + sizeof(\"hfs.type\")",
            "\"hfs.creator\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"hfs.type\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/fs.h>\n\n#define HFS_ATTRLIST_SIZE (sizeof(\"hfs.creator\")+sizeof(\"hfs.type\"))\n\nssize_t hfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer || !size)\n\t\treturn HFS_ATTRLIST_SIZE;\n\tif (size < HFS_ATTRLIST_SIZE)\n\t\treturn -ERANGE;\n\tstrcpy(buffer, \"hfs.type\");\n\tstrcpy(buffer + sizeof(\"hfs.type\"), \"hfs.creator\");\n\n\treturn HFS_ATTRLIST_SIZE;\n}"
  },
  {
    "function_name": "hfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/attr.c",
    "lines": "59-102",
    "snippet": "ssize_t hfs_getxattr(struct dentry *dentry, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tstruct hfs_cat_file *file;\n\tssize_t res = 0;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (size) {\n\t\tres = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tfd.search_key->cat = HFS_I(inode)->cat_key;\n\t\tres = hfs_brec_find(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\n\t}\n\tfile = &rec.file;\n\n\tif (!strcmp(name, \"hfs.type\")) {\n\t\tif (size >= 4) {\n\t\t\tmemcpy(value, &file->UsrWds.fdType, 4);\n\t\t\tres = 4;\n\t\t} else\n\t\t\tres = size ? -ERANGE : 4;\n\t} else if (!strcmp(name, \"hfs.creator\")) {\n\t\tif (size >= 4) {\n\t\t\tmemcpy(value, &file->UsrWds.fdCreator, 4);\n\t\t\tres = 4;\n\t\t} else\n\t\t\tres = size ? -ERANGE : 4;\n\t} else\n\t\tres = -ENODATA;\nout:\n\tif (size)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "&file->UsrWds.fdCreator",
            "4"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"hfs.creator\""
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "&file->UsrWds.fdType",
            "4"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&rec",
            "fd.entryoffset",
            "sizeof(struct hfs_cat_file)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/fs.h>\n\nssize_t hfs_getxattr(struct dentry *dentry, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tstruct hfs_cat_file *file;\n\tssize_t res = 0;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (size) {\n\t\tres = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tfd.search_key->cat = HFS_I(inode)->cat_key;\n\t\tres = hfs_brec_find(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\n\t}\n\tfile = &rec.file;\n\n\tif (!strcmp(name, \"hfs.type\")) {\n\t\tif (size >= 4) {\n\t\t\tmemcpy(value, &file->UsrWds.fdType, 4);\n\t\t\tres = 4;\n\t\t} else\n\t\t\tres = size ? -ERANGE : 4;\n\t} else if (!strcmp(name, \"hfs.creator\")) {\n\t\tif (size >= 4) {\n\t\t\tmemcpy(value, &file->UsrWds.fdCreator, 4);\n\t\t\tres = 4;\n\t\t} else\n\t\t\tres = size ? -ERANGE : 4;\n\t} else\n\t\tres = -ENODATA;\nout:\n\tif (size)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/attr.c",
    "lines": "16-57",
    "snippet": "int hfs_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tstruct hfs_cat_file *file;\n\tint res;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tres = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tfd.search_key->cat = HFS_I(inode)->cat_key;\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\tsizeof(struct hfs_cat_file));\n\tfile = &rec.file;\n\n\tif (!strcmp(name, \"hfs.type\")) {\n\t\tif (size == 4)\n\t\t\tmemcpy(&file->UsrWds.fdType, value, 4);\n\t\telse\n\t\t\tres = -ERANGE;\n\t} else if (!strcmp(name, \"hfs.creator\")) {\n\t\tif (size == 4)\n\t\t\tmemcpy(&file->UsrWds.fdCreator, value, 4);\n\t\telse\n\t\t\tres = -ERANGE;\n\t} else\n\t\tres = -EOPNOTSUPP;\n\tif (!res)\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "fd.bnode",
            "&rec",
            "fd.entryoffset",
            "sizeof(struct hfs_cat_file)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "60-70",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(kmap(page) + off, buf, len);\n\tkunmap(page);\n\tset_page_dirty(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(kmap(page) + off, buf, len);\n\tkunmap(page);\n\tset_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&file->UsrWds.fdCreator",
            "value",
            "4"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"hfs.creator\""
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&file->UsrWds.fdType",
            "value",
            "4"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&rec",
            "fd.entryoffset",
            "sizeof(struct hfs_cat_file)"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/fs.h>\n\nint hfs_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tstruct hfs_cat_file *file;\n\tint res;\n\n\tif (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tres = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tfd.search_key->cat = HFS_I(inode)->cat_key;\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\tsizeof(struct hfs_cat_file));\n\tfile = &rec.file;\n\n\tif (!strcmp(name, \"hfs.type\")) {\n\t\tif (size == 4)\n\t\t\tmemcpy(&file->UsrWds.fdType, value, 4);\n\t\telse\n\t\t\tres = -ERANGE;\n\t} else if (!strcmp(name, \"hfs.creator\")) {\n\t\tif (size == 4)\n\t\t\tmemcpy(&file->UsrWds.fdCreator, value, 4);\n\t\telse\n\t\t\tres = -ERANGE;\n\t} else\n\t\tres = -EOPNOTSUPP;\n\tif (!res)\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}"
  }
]