[
  {
    "function_name": "squashfs_read_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "416-458",
    "snippet": "void *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "actor"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_data",
          "args": [
            "sb",
            "block",
            "length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK",
            "NULL",
            "actor"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
          "lines": "90-214",
          "snippet": "int squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_page_actor_init",
          "args": [
            "data",
            "pages",
            "length"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_page_actor_init_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.c",
          "lines": "83-100",
          "snippet": "struct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "length",
            "GFP_KERNEL"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}"
  },
  {
    "function_name": "squashfs_get_datablock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "404-410",
    "snippet": "struct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_get",
          "args": [
            "sb",
            "msblk->read_page",
            "start_block",
            "length"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "65-180",
          "snippet": "struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}"
  },
  {
    "function_name": "squashfs_get_fragment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "389-396",
    "snippet": "struct squashfs_cache_entry *squashfs_get_fragment(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->fragment_cache, start_block,\n\t\tlength);\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_get",
          "args": [
            "sb",
            "msblk->fragment_cache",
            "start_block",
            "length"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "65-180",
          "snippet": "struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_get_fragment(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->fragment_cache, start_block,\n\t\tlength);\n}"
  },
  {
    "function_name": "squashfs_read_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "344-382",
    "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_put",
          "args": [
            "entry"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "186-205",
          "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_copy_data",
          "args": [
            "buffer",
            "entry",
            "*offset",
            "length"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "306-335",
          "snippet": "int squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_get",
          "args": [
            "sb",
            "msblk->block_cache",
            "*block",
            "0"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "65-180",
          "snippet": "struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_read_metadata [%llx:%x]\\n\"",
            "*block",
            "*offset"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
  },
  {
    "function_name": "squashfs_copy_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "306-335",
    "snippet": "int squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "buff",
            "bytes"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "buff",
            "remaining"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "entry->length - offset",
            "PAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "length",
            "entry->length - offset"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}"
  },
  {
    "function_name": "squashfs_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "236-298",
    "snippet": "struct squashfs_cache *squashfs_cache_init(char *name, int entries,\n\tint block_size)\n{\n\tint i, j;\n\tstruct squashfs_cache *cache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\n\tif (cache == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tcache->entry = kcalloc(entries, sizeof(*(cache->entry)), GFP_KERNEL);\n\tif (cache->entry == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\tgoto cleanup;\n\t}\n\n\tcache->curr_blk = 0;\n\tcache->next_blk = 0;\n\tcache->unused = entries;\n\tcache->entries = entries;\n\tcache->block_size = block_size;\n\tcache->pages = block_size >> PAGE_CACHE_SHIFT;\n\tcache->pages = cache->pages ? cache->pages : 1;\n\tcache->name = name;\n\tcache->num_waiters = 0;\n\tspin_lock_init(&cache->lock);\n\tinit_waitqueue_head(&cache->wait_queue);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct squashfs_cache_entry *entry = &cache->entry[i];\n\n\t\tinit_waitqueue_head(&cache->entry[i].wait_queue);\n\t\tentry->cache = cache;\n\t\tentry->block = SQUASHFS_INVALID_BLK;\n\t\tentry->data = kcalloc(cache->pages, sizeof(void *), GFP_KERNEL);\n\t\tif (entry->data == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfor (j = 0; j < cache->pages; j++) {\n\t\t\tentry->data[j] = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\t\tif (entry->data[j] == NULL) {\n\t\t\t\tERROR(\"Failed to allocate %s buffer\\n\", name);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tentry->actor = squashfs_page_actor_init(entry->data,\n\t\t\t\t\t\tcache->pages, 0);\n\t\tif (entry->actor == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn cache;\n\ncleanup:\n\tsquashfs_cache_delete(cache);\n\treturn NULL;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_delete",
          "args": [
            "cache"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "210-228",
          "snippet": "void squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate %s cache entry\\n\"",
            "name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_page_actor_init",
          "args": [
            "entry->data",
            "cache->pages",
            "0"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_page_actor_init_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.c",
          "lines": "83-100",
          "snippet": "struct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct squashfs_page_actor *squashfs_page_actor_init_special(struct page **page,\n\tint pages, int length)\n{\n\tstruct squashfs_page_actor *actor = kmalloc(sizeof(*actor), GFP_KERNEL);\n\n\tif (actor == NULL)\n\t\treturn NULL;\n\n\tactor->length = length ? : pages * PAGE_CACHE_SIZE;\n\tactor->page = page;\n\tactor->pages = pages;\n\tactor->next_page = 0;\n\tactor->pageaddr = NULL;\n\tactor->squashfs_first_page = direct_first_page;\n\tactor->squashfs_next_page = direct_next_page;\n\tactor->squashfs_finish_page = direct_finish_page;\n\treturn actor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate %s buffer\\n\"",
            "name"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate %s cache entry\\n\"",
            "name"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cache->pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cache->entry[i].wait_queue"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cache->wait_queue"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cache->lock"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate %s cache\\n\"",
            "name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "entries",
            "sizeof(*(cache->entry))",
            "GFP_KERNEL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate %s cache\\n\"",
            "name"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cache)",
            "GFP_KERNEL"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache *squashfs_cache_init(char *name, int entries,\n\tint block_size)\n{\n\tint i, j;\n\tstruct squashfs_cache *cache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\n\tif (cache == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tcache->entry = kcalloc(entries, sizeof(*(cache->entry)), GFP_KERNEL);\n\tif (cache->entry == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\tgoto cleanup;\n\t}\n\n\tcache->curr_blk = 0;\n\tcache->next_blk = 0;\n\tcache->unused = entries;\n\tcache->entries = entries;\n\tcache->block_size = block_size;\n\tcache->pages = block_size >> PAGE_CACHE_SHIFT;\n\tcache->pages = cache->pages ? cache->pages : 1;\n\tcache->name = name;\n\tcache->num_waiters = 0;\n\tspin_lock_init(&cache->lock);\n\tinit_waitqueue_head(&cache->wait_queue);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct squashfs_cache_entry *entry = &cache->entry[i];\n\n\t\tinit_waitqueue_head(&cache->entry[i].wait_queue);\n\t\tentry->cache = cache;\n\t\tentry->block = SQUASHFS_INVALID_BLK;\n\t\tentry->data = kcalloc(cache->pages, sizeof(void *), GFP_KERNEL);\n\t\tif (entry->data == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfor (j = 0; j < cache->pages; j++) {\n\t\t\tentry->data[j] = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\t\tif (entry->data[j] == NULL) {\n\t\t\t\tERROR(\"Failed to allocate %s buffer\\n\", name);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tentry->actor = squashfs_page_actor_init(entry->data,\n\t\t\t\t\t\tcache->pages, 0);\n\t\tif (entry->actor == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn cache;\n\ncleanup:\n\tsquashfs_cache_delete(cache);\n\treturn NULL;\n}"
  },
  {
    "function_name": "squashfs_cache_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "210-228",
    "snippet": "void squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache->entry"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache->entry[i].actor"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache->entry[i].data"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache->entry[i].data[j]"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}"
  },
  {
    "function_name": "squashfs_cache_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "186-205",
    "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cache->lock"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&cache->wait_queue"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->lock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
  },
  {
    "function_name": "squashfs_cache_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
    "lines": "65-180",
    "snippet": "struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/wait.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read %s cache entry [%llx]\\n\"",
            "cache->name",
            "block"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Got %s %d, start block %lld, refcount %d, error %d\\n\"",
            "cache->name",
            "i",
            "entry->block",
            "entry->refcount",
            "entry->error"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cache->lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "entry->wait_queue",
            "!entry->pending"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&entry->wait_queue"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_data",
          "args": [
            "sb",
            "block",
            "length",
            "&entry->next_index",
            "entry->actor"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
          "lines": "90-214",
          "snippet": "int squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "cache->wait_queue",
            "cache->unused"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}"
  }
]