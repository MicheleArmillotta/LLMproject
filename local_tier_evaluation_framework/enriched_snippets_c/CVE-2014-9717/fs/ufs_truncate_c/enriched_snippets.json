[
  {
    "function_name": "ufs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "493-519",
    "snippet": "int ufs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\n\t\tloff_t old_i_size = inode->i_size;\n\n\t\t/* XXX(truncate): truncate_setsize should be called last */\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\t\tlock_ufs(inode->i_sb);\n\t\terror = ufs_truncate(inode, old_i_size);\n\t\tunlock_ufs(inode->i_sb);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "inode->i_sb"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_truncate",
          "args": [
            "inode",
            "old_i_size"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "443-491",
          "snippet": "int ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nint ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint ufs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\n\t\tloff_t old_i_size = inode->i_size;\n\n\t\t/* XXX(truncate): truncate_setsize should be called last */\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\t\tlock_ufs(inode->i_sb);\n\t\terror = ufs_truncate(inode, old_i_size);\n\t\tunlock_ufs(inode->i_sb);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "443-491",
    "snippet": "int ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT: err %d\\n\"",
            "err"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_sync_inode",
          "args": [
            "inode"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "876-879",
          "snippet": "int ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_trunc_tindirect",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_tindirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "316-371",
          "snippet": "static int ufs_trunc_tindirect(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct ufs_buffer_head * tind_bh;\n\tu64 tindirect_block, tmp, i;\n\tvoid *tind, *p;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tretry = 0;\n\t\n\ttindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))\n\t\t? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;\n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);\n\tif (!(tmp = ufs_data_ptr_to_cpu(sb, p)))\n\t\treturn 0;\n\ttind_bh = ubh_bread (sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (tind_bh);\n\t\treturn 1;\n\t}\n\tif (!tind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = tindirect_block ; i < uspi->s_apb ; i++) {\n\t\ttind = ubh_get_data_ptr(uspi, tind_bh, i);\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_NDADDR + \n\t\t\tuspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);\n\t\tubh_mark_buffer_dirty(tind_bh);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, tind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(tind_bh);\n\t\ttind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))\n\t\tubh_sync_block(tind_bh);\n\tubh_brelse (tind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_tindirect(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct ufs_buffer_head * tind_bh;\n\tu64 tindirect_block, tmp, i;\n\tvoid *tind, *p;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tretry = 0;\n\t\n\ttindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))\n\t\t? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;\n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);\n\tif (!(tmp = ufs_data_ptr_to_cpu(sb, p)))\n\t\treturn 0;\n\ttind_bh = ubh_bread (sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (tind_bh);\n\t\treturn 1;\n\t}\n\tif (!tind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = tindirect_block ; i < uspi->s_apb ; i++) {\n\t\ttind = ubh_get_data_ptr(uspi, tind_bh, i);\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_NDADDR + \n\t\t\tuspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);\n\t\tubh_mark_buffer_dirty(tind_bh);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, tind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(tind_bh);\n\t\ttind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))\n\t\tubh_sync_block(tind_bh);\n\tubh_brelse (tind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_trunc_dindirect",
          "args": [
            "inode",
            "UFS_IND_BLOCK + uspi->s_apb",
            "ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_dindirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "254-314",
          "snippet": "static int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_direct_data_ptr",
          "args": [
            "uspi",
            "ufsi",
            "UFS_DIND_BLOCK"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_direct_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "551-559",
          "snippet": "static inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_trunc_indirect",
          "args": [
            "inode",
            "UFS_IND_BLOCK",
            "ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK)"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "171-252",
          "snippet": "static int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_trunc_direct",
          "args": [
            "inode"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "66-168",
          "snippet": "static int ufs_trunc_direct(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tvoid *p;\n\tu64 frag1, frag2, frag3, frag4, block1, block2;\n\tunsigned frag_to_free, free_count;\n\tunsigned i, tmp;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\tfrag1 = DIRECT_FRAGMENT;\n\tfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\n\tfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\n\tfrag3 = frag4 & ~uspi->s_fpbmask;\n\tblock1 = block2 = 0;\n\tif (frag2 > frag3) {\n\t\tfrag2 = frag4;\n\t\tfrag3 = frag4 = 0;\n\t} else if (frag2 < frag3) {\n\t\tblock1 = ufs_fragstoblks (frag2);\n\t\tblock2 = ufs_fragstoblks (frag3);\n\t}\n\n\tUFSD(\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\", inode->i_ino,\n\t     (unsigned long long)frag1, (unsigned long long)frag2,\n\t     (unsigned long long)block1, (unsigned long long)block2,\n\t     (unsigned long long)frag3, (unsigned long long)frag4);\n\n\tif (frag1 >= frag2)\n\t\tgoto next1;\t\t\n\n\t/*\n\t * Free first free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic (sb, \"ufs_trunc_direct\", \"internal error\");\n\tfrag2 -= frag1;\n\tfrag1 = ufs_fragnum (frag1);\n\n\tufs_free_fragments(inode, tmp + frag1, frag2);\n\tmark_inode_dirty(inode);\n\tfrag_to_free = tmp + frag1;\n\nnext1:\n\t/*\n\t * Free whole blocks\n\t */\n\tfor (i = block1 ; i < block2; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t\n\tif (free_count > 0)\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\n\tif (frag3 >= frag4)\n\t\tgoto next3;\n\n\t/*\n\t * Free last free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic(sb, \"ufs_truncate_direct\", \"internal error\");\n\tfrag4 = ufs_fragnum (frag4);\n\tufs_data_ptr_clear(uspi, p);\n\n\tufs_free_fragments (inode, tmp, frag4);\n\tmark_inode_dirty(inode);\n next3:\n\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nstatic int ufs_trunc_direct(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tvoid *p;\n\tu64 frag1, frag2, frag3, frag4, block1, block2;\n\tunsigned frag_to_free, free_count;\n\tunsigned i, tmp;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\tfrag1 = DIRECT_FRAGMENT;\n\tfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\n\tfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\n\tfrag3 = frag4 & ~uspi->s_fpbmask;\n\tblock1 = block2 = 0;\n\tif (frag2 > frag3) {\n\t\tfrag2 = frag4;\n\t\tfrag3 = frag4 = 0;\n\t} else if (frag2 < frag3) {\n\t\tblock1 = ufs_fragstoblks (frag2);\n\t\tblock2 = ufs_fragstoblks (frag3);\n\t}\n\n\tUFSD(\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\", inode->i_ino,\n\t     (unsigned long long)frag1, (unsigned long long)frag2,\n\t     (unsigned long long)block1, (unsigned long long)block2,\n\t     (unsigned long long)frag3, (unsigned long long)frag4);\n\n\tif (frag1 >= frag2)\n\t\tgoto next1;\t\t\n\n\t/*\n\t * Free first free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic (sb, \"ufs_trunc_direct\", \"internal error\");\n\tfrag2 -= frag1;\n\tfrag1 = ufs_fragnum (frag1);\n\n\tufs_free_fragments(inode, tmp + frag1, frag2);\n\tmark_inode_dirty(inode);\n\tfrag_to_free = tmp + frag1;\n\nnext1:\n\t/*\n\t * Free whole blocks\n\t */\n\tfor (i = block1 ; i < block2; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t\n\tif (free_count > 0)\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\n\tif (frag3 >= frag4)\n\t\tgoto next3;\n\n\t/*\n\t * Free last free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic(sb, \"ufs_truncate_direct\", \"internal error\");\n\tfrag4 = ufs_fragnum (frag4);\n\tufs_data_ptr_clear(uspi, p);\n\n\tufs_free_fragments (inode, tmp, frag4);\n\tmark_inode_dirty(inode);\n next3:\n\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "inode->i_size",
            "ufs_getfrag_block"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2806-2879",
          "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "old_i_size"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_alloc_lastblock",
          "args": [
            "inode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_alloc_lastblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "373-441",
          "snippet": "static int ufs_alloc_lastblock(struct inode *inode)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i, end;\n\tsector_t lastfrag;\n\tstruct page *lastpage;\n\tstruct buffer_head *bh;\n\tu64 phys64;\n\n\tlastfrag = (i_size_read(inode) + uspi->s_fsize - 1) >> uspi->s_fshift;\n\n\tif (!lastfrag)\n\t\tgoto out;\n\n\tlastfrag--;\n\n\tlastpage = ufs_get_locked_page(mapping, lastfrag >>\n\t\t\t\t       (PAGE_CACHE_SHIFT - inode->i_blkbits));\n       if (IS_ERR(lastpage)) {\n               err = -EIO;\n               goto out;\n       }\n\n       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);\n       bh = page_buffers(lastpage);\n       for (i = 0; i < end; ++i)\n               bh = bh->b_this_page;\n\n\n       err = ufs_getfrag_block(inode, lastfrag, bh, 1);\n\n       if (unlikely(err))\n\t       goto out_unlock;\n\n       if (buffer_new(bh)) {\n\t       clear_buffer_new(bh);\n\t       unmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t bh->b_blocknr);\n\t       /*\n\t\t* we do not zeroize fragment, because of\n\t\t* if it maped to hole, it already contains zeroes\n\t\t*/\n\t       set_buffer_uptodate(bh);\n\t       mark_buffer_dirty(bh);\n\t       set_page_dirty(lastpage);\n       }\n\n       if (lastfrag >= UFS_IND_FRAGMENT) {\n\t       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\n\t       phys64 = bh->b_blocknr + 1;\n\t       for (i = 0; i < end; ++i) {\n\t\t       bh = sb_getblk(sb, i + phys64);\n\t\t       lock_buffer(bh);\n\t\t       memset(bh->b_data, 0, sb->s_blocksize);\n\t\t       set_buffer_uptodate(bh);\n\t\t       mark_buffer_dirty(bh);\n\t\t       unlock_buffer(bh);\n\t\t       sync_dirty_buffer(bh);\n\t\t       brelse(bh);\n\t       }\n       }\nout_unlock:\n       ufs_put_locked_page(lastpage);\nout:\n       return err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ufs_alloc_lastblock(struct inode *inode)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i, end;\n\tsector_t lastfrag;\n\tstruct page *lastpage;\n\tstruct buffer_head *bh;\n\tu64 phys64;\n\n\tlastfrag = (i_size_read(inode) + uspi->s_fsize - 1) >> uspi->s_fshift;\n\n\tif (!lastfrag)\n\t\tgoto out;\n\n\tlastfrag--;\n\n\tlastpage = ufs_get_locked_page(mapping, lastfrag >>\n\t\t\t\t       (PAGE_CACHE_SHIFT - inode->i_blkbits));\n       if (IS_ERR(lastpage)) {\n               err = -EIO;\n               goto out;\n       }\n\n       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);\n       bh = page_buffers(lastpage);\n       for (i = 0; i < end; ++i)\n               bh = bh->b_this_page;\n\n\n       err = ufs_getfrag_block(inode, lastfrag, bh, 1);\n\n       if (unlikely(err))\n\t       goto out_unlock;\n\n       if (buffer_new(bh)) {\n\t       clear_buffer_new(bh);\n\t       unmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t bh->b_blocknr);\n\t       /*\n\t\t* we do not zeroize fragment, because of\n\t\t* if it maped to hole, it already contains zeroes\n\t\t*/\n\t       set_buffer_uptodate(bh);\n\t       mark_buffer_dirty(bh);\n\t       set_page_dirty(lastpage);\n       }\n\n       if (lastfrag >= UFS_IND_FRAGMENT) {\n\t       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\n\t       phys64 = bh->b_blocknr + 1;\n\t       for (i = 0; i < end; ++i) {\n\t\t       bh = sb_getblk(sb, i + phys64);\n\t\t       lock_buffer(bh);\n\t\t       memset(bh->b_data, 0, sb->s_blocksize);\n\t\t       set_buffer_uptodate(bh);\n\t\t       mark_buffer_dirty(bh);\n\t\t       unlock_buffer(bh);\n\t\t       sync_dirty_buffer(bh);\n\t\t       brelse(bh);\n\t       }\n       }\nout_unlock:\n       ufs_put_locked_page(lastpage);\nout:\n       return err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\"",
            "inode->i_ino",
            "(unsigned long long)i_size_read(inode)",
            "(unsigned long long)old_i_size"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nint ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_alloc_lastblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "373-441",
    "snippet": "static int ufs_alloc_lastblock(struct inode *inode)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i, end;\n\tsector_t lastfrag;\n\tstruct page *lastpage;\n\tstruct buffer_head *bh;\n\tu64 phys64;\n\n\tlastfrag = (i_size_read(inode) + uspi->s_fsize - 1) >> uspi->s_fshift;\n\n\tif (!lastfrag)\n\t\tgoto out;\n\n\tlastfrag--;\n\n\tlastpage = ufs_get_locked_page(mapping, lastfrag >>\n\t\t\t\t       (PAGE_CACHE_SHIFT - inode->i_blkbits));\n       if (IS_ERR(lastpage)) {\n               err = -EIO;\n               goto out;\n       }\n\n       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);\n       bh = page_buffers(lastpage);\n       for (i = 0; i < end; ++i)\n               bh = bh->b_this_page;\n\n\n       err = ufs_getfrag_block(inode, lastfrag, bh, 1);\n\n       if (unlikely(err))\n\t       goto out_unlock;\n\n       if (buffer_new(bh)) {\n\t       clear_buffer_new(bh);\n\t       unmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t bh->b_blocknr);\n\t       /*\n\t\t* we do not zeroize fragment, because of\n\t\t* if it maped to hole, it already contains zeroes\n\t\t*/\n\t       set_buffer_uptodate(bh);\n\t       mark_buffer_dirty(bh);\n\t       set_page_dirty(lastpage);\n       }\n\n       if (lastfrag >= UFS_IND_FRAGMENT) {\n\t       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\n\t       phys64 = bh->b_blocknr + 1;\n\t       for (i = 0; i < end; ++i) {\n\t\t       bh = sb_getblk(sb, i + phys64);\n\t\t       lock_buffer(bh);\n\t\t       memset(bh->b_data, 0, sb->s_blocksize);\n\t\t       set_buffer_uptodate(bh);\n\t\t       mark_buffer_dirty(bh);\n\t\t       unlock_buffer(bh);\n\t\t       sync_dirty_buffer(bh);\n\t\t       brelse(bh);\n\t       }\n       }\nout_unlock:\n       ufs_put_locked_page(lastpage);\nout:\n       return err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_put_locked_page",
          "args": [
            "lastpage"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "283-287",
          "snippet": "static inline void ufs_put_locked_page(struct page *page)\n{\n       unlock_page(page);\n       page_cache_release(page);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void ufs_put_locked_page(struct page *page)\n{\n       unlock_page(page);\n       page_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "i + phys64"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "lastfrag"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "lastpage"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_getfrag_block",
          "args": [
            "inode",
            "lastfrag",
            "bh",
            "1"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_getfrag_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "415-512",
          "snippet": "int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi = sbi->s_uspi;\n\tstruct buffer_head * bh;\n\tint ret, err, new;\n\tunsigned long ptr,phys;\n\tu64 phys64 = 0;\n\tbool needs_lock = (sbi->mutex_owner != current);\n\t\n\tif (!create) {\n\t\tphys64 = ufs_frag_map(inode, fragment, needs_lock);\n\t\tUFSD(\"phys64 = %llu\\n\", (unsigned long long)phys64);\n\t\tif (phys64)\n\t\t\tmap_bh(bh_result, sb, phys64);\n\t\treturn 0;\n\t}\n\n        /* This code entered only while writing ....? */\n\n\terr = -EIO;\n\tnew = 0;\n\tret = 0;\n\tbh = NULL;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu\\n\", inode->i_ino, (unsigned long long)fragment);\n\tif (fragment >\n\t    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)\n\t     << uspi->s_fpbshift))\n\t\tgoto abort_too_big;\n\n\terr = 0;\n\tptr = fragment;\n\t  \n\t/*\n\t * ok, these macros clean the logic up a bit and make\n\t * it much more readable:\n\t */\n#define GET_INODE_DATABLOCK(x) \\\n\tufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\\\n\t\t\t  bh_result->b_page)\n#define GET_INODE_PTR(x) \\\n\tufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\\\n\t\t\t  bh_result->b_page)\n#define GET_INDIRECT_DATABLOCK(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, &phys, &new, bh_result->b_page)\n#define GET_INDIRECT_PTR(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, NULL, NULL, NULL)\n\n\tif (ptr < UFS_NDIR_FRAGMENT) {\n\t\tbh = GET_INODE_DATABLOCK(ptr);\n\t\tgoto out;\n\t}\n\tptr -= UFS_NDIR_FRAGMENT;\n\tif (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));\n\t\tgoto get_indirect;\n\t}\n\tptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);\n\tif (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));\n\t\tgoto get_double;\n\t}\n\tptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);\n\tbh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);\nget_double:\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);\nget_indirect:\n\tbh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);\n\n#undef GET_INODE_DATABLOCK\n#undef GET_INODE_PTR\n#undef GET_INDIRECT_DATABLOCK\n#undef GET_INDIRECT_PTR\n\nout:\n\tif (err)\n\t\tgoto abort;\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\nabort:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\n\treturn err;\n\nabort_too_big:\n\tufs_warning(sb, \"ufs_get_block\", \"block > big\");\n\tgoto abort;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);\n\nint ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi = sbi->s_uspi;\n\tstruct buffer_head * bh;\n\tint ret, err, new;\n\tunsigned long ptr,phys;\n\tu64 phys64 = 0;\n\tbool needs_lock = (sbi->mutex_owner != current);\n\t\n\tif (!create) {\n\t\tphys64 = ufs_frag_map(inode, fragment, needs_lock);\n\t\tUFSD(\"phys64 = %llu\\n\", (unsigned long long)phys64);\n\t\tif (phys64)\n\t\t\tmap_bh(bh_result, sb, phys64);\n\t\treturn 0;\n\t}\n\n        /* This code entered only while writing ....? */\n\n\terr = -EIO;\n\tnew = 0;\n\tret = 0;\n\tbh = NULL;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu\\n\", inode->i_ino, (unsigned long long)fragment);\n\tif (fragment >\n\t    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)\n\t     << uspi->s_fpbshift))\n\t\tgoto abort_too_big;\n\n\terr = 0;\n\tptr = fragment;\n\t  \n\t/*\n\t * ok, these macros clean the logic up a bit and make\n\t * it much more readable:\n\t */\n#define GET_INODE_DATABLOCK(x) \\\n\tufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\\\n\t\t\t  bh_result->b_page)\n#define GET_INODE_PTR(x) \\\n\tufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\\\n\t\t\t  bh_result->b_page)\n#define GET_INDIRECT_DATABLOCK(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, &phys, &new, bh_result->b_page)\n#define GET_INDIRECT_PTR(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, NULL, NULL, NULL)\n\n\tif (ptr < UFS_NDIR_FRAGMENT) {\n\t\tbh = GET_INODE_DATABLOCK(ptr);\n\t\tgoto out;\n\t}\n\tptr -= UFS_NDIR_FRAGMENT;\n\tif (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));\n\t\tgoto get_indirect;\n\t}\n\tptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);\n\tif (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));\n\t\tgoto get_double;\n\t}\n\tptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);\n\tbh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);\nget_double:\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);\nget_indirect:\n\tbh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);\n\n#undef GET_INODE_DATABLOCK\n#undef GET_INODE_PTR\n#undef GET_INDIRECT_DATABLOCK\n#undef GET_INDIRECT_PTR\n\nout:\n\tif (err)\n\t\tgoto abort;\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\nabort:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\n\treturn err;\n\nabort_too_big:\n\tufs_warning(sb, \"ufs_get_block\", \"block > big\");\n\tgoto abort;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "lastpage"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lastpage"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_locked_page",
          "args": [
            "mapping",
            "lastfrag >>\n\t\t\t\t       (PAGE_CACHE_SHIFT - inode->i_blkbits)"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "243-282",
          "snippet": "struct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t pgoff_t index)\n{\n\tstruct page *page;\n\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"read_mapping_page error: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping == NULL)) {\n\t\t\t/* Truncate got there first */\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!PageUptodate(page) || PageError(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"can not read page: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t pgoff_t index)\n{\n\tstruct page *page;\n\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"read_mapping_page error: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping == NULL)) {\n\t\t\t/* Truncate got there first */\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!PageUptodate(page) || PageError(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"can not read page: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ufs_alloc_lastblock(struct inode *inode)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i, end;\n\tsector_t lastfrag;\n\tstruct page *lastpage;\n\tstruct buffer_head *bh;\n\tu64 phys64;\n\n\tlastfrag = (i_size_read(inode) + uspi->s_fsize - 1) >> uspi->s_fshift;\n\n\tif (!lastfrag)\n\t\tgoto out;\n\n\tlastfrag--;\n\n\tlastpage = ufs_get_locked_page(mapping, lastfrag >>\n\t\t\t\t       (PAGE_CACHE_SHIFT - inode->i_blkbits));\n       if (IS_ERR(lastpage)) {\n               err = -EIO;\n               goto out;\n       }\n\n       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);\n       bh = page_buffers(lastpage);\n       for (i = 0; i < end; ++i)\n               bh = bh->b_this_page;\n\n\n       err = ufs_getfrag_block(inode, lastfrag, bh, 1);\n\n       if (unlikely(err))\n\t       goto out_unlock;\n\n       if (buffer_new(bh)) {\n\t       clear_buffer_new(bh);\n\t       unmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t bh->b_blocknr);\n\t       /*\n\t\t* we do not zeroize fragment, because of\n\t\t* if it maped to hole, it already contains zeroes\n\t\t*/\n\t       set_buffer_uptodate(bh);\n\t       mark_buffer_dirty(bh);\n\t       set_page_dirty(lastpage);\n       }\n\n       if (lastfrag >= UFS_IND_FRAGMENT) {\n\t       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\n\t       phys64 = bh->b_blocknr + 1;\n\t       for (i = 0; i < end; ++i) {\n\t\t       bh = sb_getblk(sb, i + phys64);\n\t\t       lock_buffer(bh);\n\t\t       memset(bh->b_data, 0, sb->s_blocksize);\n\t\t       set_buffer_uptodate(bh);\n\t\t       mark_buffer_dirty(bh);\n\t\t       unlock_buffer(bh);\n\t\t       sync_dirty_buffer(bh);\n\t\t       brelse(bh);\n\t       }\n       }\nout_unlock:\n       ufs_put_locked_page(lastpage);\nout:\n       return err;\n}"
  },
  {
    "function_name": "ufs_trunc_tindirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "316-371",
    "snippet": "static int ufs_trunc_tindirect(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct ufs_buffer_head * tind_bh;\n\tu64 tindirect_block, tmp, i;\n\tvoid *tind, *p;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tretry = 0;\n\t\n\ttindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))\n\t\t? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;\n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);\n\tif (!(tmp = ufs_data_ptr_to_cpu(sb, p)))\n\t\treturn 0;\n\ttind_bh = ubh_bread (sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (tind_bh);\n\t\treturn 1;\n\t}\n\tif (!tind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = tindirect_block ; i < uspi->s_apb ; i++) {\n\t\ttind = ubh_get_data_ptr(uspi, tind_bh, i);\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_NDADDR + \n\t\t\tuspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);\n\t\tubh_mark_buffer_dirty(tind_bh);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, tind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(tind_bh);\n\t\ttind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))\n\t\tubh_sync_block(tind_bh);\n\tubh_brelse (tind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_brelse",
          "args": [
            "tind_bh"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "tind_bh"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_buffer_dirty",
          "args": [
            "tind_bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "137-146",
          "snippet": "int ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nint ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bforget",
          "args": [
            "tind_bh"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "128-135",
          "snippet": "void ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_free_blocks",
          "args": [
            "inode",
            "tmp",
            "uspi->s_fpb"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "132-223",
          "snippet": "void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_clear",
          "args": [
            "uspi",
            "p"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "576-583",
          "snippet": "static inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_is_data_ptr_zero",
          "args": [
            "uspi",
            "ubh_get_data_ptr(uspi, tind_bh, i)"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_is_data_ptr_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "585-592",
          "snippet": "static inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_data_ptr",
          "args": [
            "uspi",
            "tind_bh",
            "i"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_get_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "340-348",
          "snippet": "static inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);",
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "tind_bh"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_trunc_dindirect",
          "args": [
            "inode",
            "UFS_NDADDR + \n\t\t\tuspi->s_apb + ((i + 1) << uspi->s_2apbshift)",
            "tind"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_dindirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "254-314",
          "snippet": "static int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_bread",
          "args": [
            "sb",
            "tmp",
            "uspi->s_bsize"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_direct_data_ptr",
          "args": [
            "uspi",
            "ufsi",
            "UFS_TIND_BLOCK"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_direct_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "551-559",
          "snippet": "static inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_tindirect(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct ufs_buffer_head * tind_bh;\n\tu64 tindirect_block, tmp, i;\n\tvoid *tind, *p;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tretry = 0;\n\t\n\ttindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))\n\t\t? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;\n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);\n\tif (!(tmp = ufs_data_ptr_to_cpu(sb, p)))\n\t\treturn 0;\n\ttind_bh = ubh_bread (sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (tind_bh);\n\t\treturn 1;\n\t}\n\tif (!tind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = tindirect_block ; i < uspi->s_apb ; i++) {\n\t\ttind = ubh_get_data_ptr(uspi, tind_bh, i);\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_NDADDR + \n\t\t\tuspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);\n\t\tubh_mark_buffer_dirty(tind_bh);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, tind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(tind_bh);\n\t\ttind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))\n\t\tubh_sync_block(tind_bh);\n\tubh_brelse (tind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}"
  },
  {
    "function_name": "ufs_trunc_dindirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "254-314",
    "snippet": "static int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_brelse",
          "args": [
            "dind_bh"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "dind_bh"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_buffer_dirty",
          "args": [
            "dind_bh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "137-146",
          "snippet": "int ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nint ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bforget",
          "args": [
            "dind_bh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "128-135",
          "snippet": "void ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_free_blocks",
          "args": [
            "inode",
            "tmp",
            "uspi->s_fpb"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "132-223",
          "snippet": "void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_clear",
          "args": [
            "uspi",
            "p"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "576-583",
          "snippet": "static inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_is_data_ptr_zero",
          "args": [
            "uspi",
            "ubh_get_data_ptr(uspi, dind_bh, i)"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_is_data_ptr_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "585-592",
          "snippet": "static inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_data_ptr",
          "args": [
            "uspi",
            "dind_bh",
            "i"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_get_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "340-348",
          "snippet": "static inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);",
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "dind_bh"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_trunc_indirect",
          "args": [
            "inode",
            "offset + (i << uspi->s_apbshift)",
            "dind"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_trunc_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "171-252",
          "snippet": "static int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_bread",
          "args": [
            "sb",
            "tmp",
            "uspi->s_bsize"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head *dind_bh;\n\tu64 i, tmp, dindirect_block;\n\tvoid *dind;\n\tint retry = 0;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tdindirect_block = (DIRECT_BLOCK > offset) \n\t\t? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tdind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (dind_bh);\n\t\treturn 1;\n\t}\n\tif (!dind_bh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\n\t\tdind = ubh_get_data_ptr(uspi, dind_bh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, dind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\n\t\tubh_mark_buffer_dirty(dind_bh);\n\t}\n\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, dind_bh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks(inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(dind_bh);\n\t\tdind_bh = NULL;\n\t}\n\tif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\n\t\tubh_sync_block(dind_bh);\n\tubh_brelse (dind_bh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
  },
  {
    "function_name": "ufs_trunc_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "171-252",
    "snippet": "static int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_brelse",
          "args": [
            "ind_ubh"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "ind_ubh"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_buffer_dirty",
          "args": [
            "ind_ubh"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "137-146",
          "snippet": "int ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nint ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bforget",
          "args": [
            "ind_ubh"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "128-135",
          "snippet": "void ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_free_blocks",
          "args": [
            "inode",
            "tmp",
            "uspi->s_fpb"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "132-223",
          "snippet": "void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_clear",
          "args": [
            "uspi",
            "p"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "576-583",
          "snippet": "static inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_is_data_ptr_zero",
          "args": [
            "uspi",
            "ubh_get_data_ptr(uspi, ind_ubh, i)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_is_data_ptr_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "585-592",
          "snippet": "static inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_data_ptr",
          "args": [
            "uspi",
            "ind_ubh",
            "i"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_get_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "340-348",
          "snippet": "static inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);",
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "ind_ubh"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_bread",
          "args": [
            "sb",
            "tmp",
            "uspi->s_bsize"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!p"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER: ino %lu, offset %llu, p: %p\\n\"",
            "inode->i_ino",
            "(unsigned long long)offset",
            "p"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)\n\nstatic int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_buffer_head * ind_ubh;\n\tvoid *ind;\n\tu64 tmp, indirect_block, i, frag_to_free;\n\tunsigned free_count;\n\tint retry;\n\n\tUFSD(\"ENTER: ino %lu, offset %llu, p: %p\\n\",\n\t     inode->i_ino, (unsigned long long)offset, p);\n\n\tBUG_ON(!p);\n\t\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp)\n\t\treturn 0;\n\tind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\n\tif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\n\t\tubh_brelse (ind_ubh);\n\t\treturn 1;\n\t}\n\tif (!ind_ubh) {\n\t\tufs_data_ptr_clear(uspi, p);\n\t\treturn 0;\n\t}\n\n\tindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\n\tfor (i = indirect_block; i < uspi->s_apb; i++) {\n\t\tind = ubh_get_data_ptr(uspi, ind_ubh, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, ind);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tufs_data_ptr_clear(uspi, ind);\n\t\tubh_mark_buffer_dirty(ind_ubh);\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (free_count > 0) {\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t}\n\tfor (i = 0; i < uspi->s_apb; i++)\n\t\tif (!ufs_is_data_ptr_zero(uspi,\n\t\t\t\t\t  ubh_get_data_ptr(uspi, ind_ubh, i)))\n\t\t\tbreak;\n\tif (i >= uspi->s_apb) {\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tufs_free_blocks (inode, tmp, uspi->s_fpb);\n\t\tmark_inode_dirty(inode);\n\t\tubh_bforget(ind_ubh);\n\t\tind_ubh = NULL;\n\t}\n\tif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\n\t\tubh_sync_block(ind_ubh);\n\tubh_brelse (ind_ubh);\n\t\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\t\n\treturn retry;\n}"
  },
  {
    "function_name": "ufs_trunc_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
    "lines": "66-168",
    "snippet": "static int ufs_trunc_direct(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tvoid *p;\n\tu64 frag1, frag2, frag3, frag4, block1, block2;\n\tunsigned frag_to_free, free_count;\n\tunsigned i, tmp;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\tfrag1 = DIRECT_FRAGMENT;\n\tfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\n\tfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\n\tfrag3 = frag4 & ~uspi->s_fpbmask;\n\tblock1 = block2 = 0;\n\tif (frag2 > frag3) {\n\t\tfrag2 = frag4;\n\t\tfrag3 = frag4 = 0;\n\t} else if (frag2 < frag3) {\n\t\tblock1 = ufs_fragstoblks (frag2);\n\t\tblock2 = ufs_fragstoblks (frag3);\n\t}\n\n\tUFSD(\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\", inode->i_ino,\n\t     (unsigned long long)frag1, (unsigned long long)frag2,\n\t     (unsigned long long)block1, (unsigned long long)block2,\n\t     (unsigned long long)frag3, (unsigned long long)frag4);\n\n\tif (frag1 >= frag2)\n\t\tgoto next1;\t\t\n\n\t/*\n\t * Free first free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic (sb, \"ufs_trunc_direct\", \"internal error\");\n\tfrag2 -= frag1;\n\tfrag1 = ufs_fragnum (frag1);\n\n\tufs_free_fragments(inode, tmp + frag1, frag2);\n\tmark_inode_dirty(inode);\n\tfrag_to_free = tmp + frag1;\n\nnext1:\n\t/*\n\t * Free whole blocks\n\t */\n\tfor (i = block1 ; i < block2; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t\n\tif (free_count > 0)\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\n\tif (frag3 >= frag4)\n\t\tgoto next3;\n\n\t/*\n\t * Free last free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic(sb, \"ufs_truncate_direct\", \"internal error\");\n\tfrag4 = ufs_fragnum (frag4);\n\tufs_data_ptr_clear(uspi, p);\n\n\tufs_free_fragments (inode, tmp, frag4);\n\tmark_inode_dirty(inode);\n next3:\n\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_free_fragments",
          "args": [
            "inode",
            "tmp",
            "frag4"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "37-127",
          "snippet": "void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_clear",
          "args": [
            "uspi",
            "p"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "576-583",
          "snippet": "static inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "frag4"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_truncate_direct\"",
            "\"internal error\""
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_direct_data_ptr",
          "args": [
            "uspi",
            "ufsi",
            "ufs_fragstoblks(frag3)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_direct_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "551-559",
          "snippet": "static inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "frag3"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_free_blocks",
          "args": [
            "inode",
            "frag_to_free",
            "free_count"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "132-223",
          "snippet": "void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "frag1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "frag1"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\"",
            "inode->i_ino",
            "(unsigned long long)frag1",
            "(unsigned long long)frag2",
            "(unsigned long long)block1",
            "(unsigned long long)block2",
            "(unsigned long long)frag3",
            "(unsigned long long)frag4"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "frag3"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "frag2"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "UFS_NDIR_FRAGMENT",
            "ufsi->i_lastfrag"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER: ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nstatic int ufs_trunc_direct(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tvoid *p;\n\tu64 frag1, frag2, frag3, frag4, block1, block2;\n\tunsigned frag_to_free, free_count;\n\tunsigned i, tmp;\n\tint retry;\n\t\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfrag_to_free = 0;\n\tfree_count = 0;\n\tretry = 0;\n\t\n\tfrag1 = DIRECT_FRAGMENT;\n\tfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\n\tfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\n\tfrag3 = frag4 & ~uspi->s_fpbmask;\n\tblock1 = block2 = 0;\n\tif (frag2 > frag3) {\n\t\tfrag2 = frag4;\n\t\tfrag3 = frag4 = 0;\n\t} else if (frag2 < frag3) {\n\t\tblock1 = ufs_fragstoblks (frag2);\n\t\tblock2 = ufs_fragstoblks (frag3);\n\t}\n\n\tUFSD(\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\", inode->i_ino,\n\t     (unsigned long long)frag1, (unsigned long long)frag2,\n\t     (unsigned long long)block1, (unsigned long long)block2,\n\t     (unsigned long long)frag3, (unsigned long long)frag4);\n\n\tif (frag1 >= frag2)\n\t\tgoto next1;\t\t\n\n\t/*\n\t * Free first free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic (sb, \"ufs_trunc_direct\", \"internal error\");\n\tfrag2 -= frag1;\n\tfrag1 = ufs_fragnum (frag1);\n\n\tufs_free_fragments(inode, tmp + frag1, frag2);\n\tmark_inode_dirty(inode);\n\tfrag_to_free = tmp + frag1;\n\nnext1:\n\t/*\n\t * Free whole blocks\n\t */\n\tfor (i = block1 ; i < block2; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tufs_data_ptr_clear(uspi, p);\n\n\t\tif (free_count == 0) {\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t} else if (free_count > 0 && frag_to_free == tmp - free_count)\n\t\t\tfree_count += uspi->s_fpb;\n\t\telse {\n\t\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\t\t\tfrag_to_free = tmp;\n\t\t\tfree_count = uspi->s_fpb;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t\n\tif (free_count > 0)\n\t\tufs_free_blocks (inode, frag_to_free, free_count);\n\n\tif (frag3 >= frag4)\n\t\tgoto next3;\n\n\t/*\n\t * Free last free fragments\n\t */\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic(sb, \"ufs_truncate_direct\", \"internal error\");\n\tfrag4 = ufs_fragnum (frag4);\n\tufs_data_ptr_clear(uspi, p);\n\n\tufs_free_fragments (inode, tmp, frag4);\n\tmark_inode_dirty(inode);\n next3:\n\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n\treturn retry;\n}"
  }
]