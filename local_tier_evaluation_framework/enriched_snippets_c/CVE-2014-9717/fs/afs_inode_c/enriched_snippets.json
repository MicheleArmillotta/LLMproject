[
  {
    "function_name": "afs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "459-498",
    "snippet": "int afs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},{n=%pd},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t       attr->ia_valid);\n\n\tif (!(attr->ia_valid & (ATTR_SIZE | ATTR_MODE | ATTR_UID | ATTR_GID |\n\t\t\t\tATTR_MTIME))) {\n\t\t_leave(\" = 0 [unsupported]\");\n\t\treturn 0;\n\t}\n\n\t/* flush any dirty data outstanding on a regular file */\n\tif (S_ISREG(vnode->vfs_inode.i_mode)) {\n\t\tfilemap_write_and_wait(vnode->vfs_inode.i_mapping);\n\t\tafs_writeback_all(vnode);\n\t}\n\n\tif (attr->ia_valid & ATTR_FILE) {\n\t\tkey = attr->ia_file->private_data;\n\t} else {\n\t\tkey = afs_request_key(vnode->volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\tret = PTR_ERR(key);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = afs_vnode_setattr(vnode, key, attr);\n\tif (!(attr->ia_valid & ATTR_FILE))\n\t\tkey_put(key);\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_setattr",
          "args": [
            "vnode",
            "key",
            "attr"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "824-871",
          "snippet": "int afs_vnode_setattr(struct afs_vnode *vnode, struct key *key,\n\t\t      struct iattr *attr)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_setattr(server, key, vnode, attr, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_setattr(struct afs_vnode *vnode, struct key *key,\n\t\t      struct iattr *attr)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_setattr(server, key, vnode, attr, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "vnode->volume->cell"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_writeback_all",
          "args": [
            "vnode"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "afs_writeback_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "659-676",
          "snippet": "int afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nint afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "vnode->vfs_inode.i_mapping"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "vnode->vfs_inode.i_mode"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [unsupported]\""
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{n=%pd},%x\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "dentry",
            "attr->ia_valid"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},{n=%pd},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t       attr->ia_valid);\n\n\tif (!(attr->ia_valid & (ATTR_SIZE | ATTR_MODE | ATTR_UID | ATTR_GID |\n\t\t\t\tATTR_MTIME))) {\n\t\t_leave(\" = 0 [unsupported]\");\n\t\treturn 0;\n\t}\n\n\t/* flush any dirty data outstanding on a regular file */\n\tif (S_ISREG(vnode->vfs_inode.i_mode)) {\n\t\tfilemap_write_and_wait(vnode->vfs_inode.i_mapping);\n\t\tafs_writeback_all(vnode);\n\t}\n\n\tif (attr->ia_valid & ATTR_FILE) {\n\t\tkey = attr->ia_file->private_data;\n\t} else {\n\t\tkey = afs_request_key(vnode->volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\tret = PTR_ERR(key);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = afs_vnode_setattr(vnode, key, attr);\n\tif (!(attr->ia_valid & ATTR_FILE))\n\t\tkey_put(key);\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "406-454",
    "snippet": "void afs_evict_inode(struct inode *inode)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_vnode *vnode;\n\n\tvnode = AFS_FS_I(inode);\n\n\t_enter(\"{%x:%u.%d} v=%u x=%u t=%u }\",\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       vnode->cb_version,\n\t       vnode->cb_expiry,\n\t       vnode->cb_type);\n\n\t_debug(\"CLEAR INODE %p\", inode);\n\n\tASSERTCMP(inode->i_ino, ==, vnode->fid.vnode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tafs_give_up_callback(vnode);\n\n\tif (vnode->server) {\n\t\tspin_lock(&vnode->server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &vnode->server->fs_vnodes);\n\t\tspin_unlock(&vnode->server->fs_lock);\n\t\tafs_put_server(vnode->server);\n\t\tvnode->server = NULL;\n\t}\n\n\tASSERT(list_empty(&vnode->writebacks));\n\tASSERT(!vnode->cb_promised);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\n\tmutex_lock(&vnode->permits_lock);\n\tpermits = vnode->permits;\n\trcu_assign_pointer(vnode->permits, NULL);\n\tmutex_unlock(&vnode->permits_lock);\n\tif (permits)\n\t\tcall_rcu(&permits->rcu, afs_zap_permits);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&permits->rcu",
            "afs_zap_permits"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vnode->permits_lock"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "vnode->permits",
            "NULL"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vnode->permits_lock"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "vnode->cache",
            "0"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!vnode->cb_promised"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&vnode->writebacks)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vnode->writebacks"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "vnode->server"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->server->fs_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&vnode->server_rb",
            "&vnode->server->fs_vnodes"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->server->fs_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_give_up_callback",
          "args": [
            "vnode"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "afs_give_up_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "289-329",
          "snippet": "void afs_give_up_callback(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server = vnode->server;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%d\", vnode->cb_promised);\n\n\t_debug(\"GIVE UP INODE %p\", &vnode->vfs_inode);\n\n\tif (!vnode->cb_promised) {\n\t\t_leave(\" [not promised]\");\n\t\treturn;\n\t}\n\n\tASSERT(server != NULL);\n\n\tspin_lock(&server->cb_lock);\n\tif (vnode->cb_promised && afs_breakring_space(server) == 0) {\n\t\tadd_wait_queue(&server->cb_break_waitq, &myself);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!vnode->cb_promised ||\n\t\t\t    afs_breakring_space(server) != 0)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&server->cb_lock);\n\t\t}\n\t\tremove_wait_queue(&server->cb_break_waitq, &myself);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\n\t/* of course, it's always possible for the server to break this vnode's\n\t * callback first... */\n\tif (vnode->cb_promised)\n\t\tafs_do_give_up_callback(server, vnode);\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_give_up_callback(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server = vnode->server;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%d\", vnode->cb_promised);\n\n\t_debug(\"GIVE UP INODE %p\", &vnode->vfs_inode);\n\n\tif (!vnode->cb_promised) {\n\t\t_leave(\" [not promised]\");\n\t\treturn;\n\t}\n\n\tASSERT(server != NULL);\n\n\tspin_lock(&server->cb_lock);\n\tif (vnode->cb_promised && afs_breakring_space(server) == 0) {\n\t\tadd_wait_queue(&server->cb_break_waitq, &myself);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!vnode->cb_promised ||\n\t\t\t    afs_breakring_space(server) != 0)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&server->cb_lock);\n\t\t}\n\t\tremove_wait_queue(&server->cb_break_waitq, &myself);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\n\t/* of course, it's always possible for the server to break this vnode's\n\t * callback first... */\n\tif (vnode->cb_promised)\n\t\tafs_do_give_up_callback(server, vnode);\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "inode->i_ino",
            "==,vnode->fid.vnode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CLEAR INODE %p\"",
            "inode"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "518-533",
          "snippet": "static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u.%d} v=%u x=%u t=%u }\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->cb_version",
            "vnode->cb_expiry",
            "vnode->cb_type"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_evict_inode(struct inode *inode)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_vnode *vnode;\n\n\tvnode = AFS_FS_I(inode);\n\n\t_enter(\"{%x:%u.%d} v=%u x=%u t=%u }\",\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       vnode->cb_version,\n\t       vnode->cb_expiry,\n\t       vnode->cb_type);\n\n\t_debug(\"CLEAR INODE %p\", inode);\n\n\tASSERTCMP(inode->i_ino, ==, vnode->fid.vnode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tafs_give_up_callback(vnode);\n\n\tif (vnode->server) {\n\t\tspin_lock(&vnode->server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &vnode->server->fs_vnodes);\n\t\tspin_unlock(&vnode->server->fs_lock);\n\t\tafs_put_server(vnode->server);\n\t\tvnode->server = NULL;\n\t}\n\n\tASSERT(list_empty(&vnode->writebacks));\n\tASSERT(!vnode->cb_promised);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\n\tmutex_lock(&vnode->permits_lock);\n\tpermits = vnode->permits;\n\trcu_assign_pointer(vnode->permits, NULL);\n\tmutex_unlock(&vnode->permits_lock);\n\tif (permits)\n\t\tcall_rcu(&permits->rcu, afs_zap_permits);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "393-401",
    "snippet": "int afs_drop_inode(struct inode *inode)\n{\n\t_enter(\"\");\n\n\tif (test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(inode)->flags))\n\t\treturn generic_delete_inode(inode);\n\telse\n\t\treturn generic_drop_inode(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_delete_inode",
          "args": [
            "inode"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "generic_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1409-1412",
          "snippet": "int generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_PSEUDODIR",
            "&AFS_FS_I(inode)->flags"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_drop_inode(struct inode *inode)\n{\n\t_enter(\"\");\n\n\tif (test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(inode)->flags))\n\t\treturn generic_delete_inode(inode);\n\telse\n\t\treturn generic_drop_inode(inode);\n}"
  },
  {
    "function_name": "afs_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "377-388",
    "snippet": "int afs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t      struct kstat *stat)\n{\n\tstruct inode *inode;\n\n\tinode = dentry->d_inode;\n\n\t_enter(\"{ ino=%lu v=%u }\", inode->i_ino, inode->i_generation);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{ ino=%lu v=%u }\"",
            "inode->i_ino",
            "inode->i_generation"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t      struct kstat *stat)\n{\n\tstruct inode *inode;\n\n\tinode = dentry->d_inode;\n\n\t_enter(\"{ ino=%lu v=%u }\", inode->i_ino, inode->i_generation);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "313-372",
    "snippet": "int afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vnode->validate_lock"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vnode->validate_lock"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_MODIFIED",
            "&vnode->flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_zap_data",
          "args": [
            "vnode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "afs_zap_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "291-302",
          "snippet": "void afs_zap_data(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\t/* nuke all the non-dirty pages that aren't locked, mapped or being\n\t * written back in a regular file and completely discard the pages in a\n\t * directory or symlink */\n\tif (S_ISREG(vnode->vfs_inode.i_mode))\n\t\tinvalidate_remote_inode(&vnode->vfs_inode);\n\telse\n\t\tinvalidate_inode_pages2(vnode->vfs_inode.i_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_zap_data(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\t/* nuke all the non-dirty pages that aren't locked, mapped or being\n\t * written back in a regular file and completely discard the pages in a\n\t * directory or symlink */\n\tif (S_ISREG(vnode->vfs_inode.i_mode))\n\t\tinvalidate_remote_inode(&vnode->vfs_inode);\n\telse\n\t\tinvalidate_inode_pages2(vnode->vfs_inode.i_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AFS_VNODE_ZAP_DATA",
            "&vnode->flags"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"file already deleted\""
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"new promise [fl=%lx]\"",
            "vnode->flags"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "518-533",
          "snippet": "static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "NULL",
            "key"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vnode->validate_lock"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{v={%x:%u} fl=%lx},%x\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->flags",
            "key_serial(key)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_zap_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "291-302",
    "snippet": "void afs_zap_data(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\t/* nuke all the non-dirty pages that aren't locked, mapped or being\n\t * written back in a regular file and completely discard the pages in a\n\t * directory or symlink */\n\tif (S_ISREG(vnode->vfs_inode.i_mode))\n\t\tinvalidate_remote_inode(&vnode->vfs_inode);\n\telse\n\t\tinvalidate_inode_pages2(vnode->vfs_inode.i_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "vnode->vfs_inode.i_mapping"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_remote_inode",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "vnode->vfs_inode.i_mode"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_zap_data(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\t/* nuke all the non-dirty pages that aren't locked, mapped or being\n\t * written back in a regular file and completely discard the pages in a\n\t * directory or symlink */\n\tif (S_ISREG(vnode->vfs_inode.i_mode))\n\t\tinvalidate_remote_inode(&vnode->vfs_inode);\n\telse\n\t\tinvalidate_inode_pages2(vnode->vfs_inode.i_mapping);\n}"
  },
  {
    "function_name": "afs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "198-285",
    "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [bad]\"",
            "ret"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "vnode->cache",
            "0"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p [CB { v=%u t=%u }]\"",
            "inode",
            "vnode->cb_version",
            "vnode->cb_type"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "679-690",
          "snippet": "static int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_UNSET",
            "&vnode->flags"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_inode_map_status",
          "args": [
            "vnode",
            "key"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "afs_inode_map_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "34-94",
          "snippet": "static int afs_inode_map_status(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct inode *inode = AFS_VNODE_TO_I(vnode);\n\n\t_debug(\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\",\n\t       vnode->status.type,\n\t       vnode->status.nlink,\n\t       (unsigned long long) vnode->status.size,\n\t       vnode->status.data_version,\n\t       vnode->status.mode);\n\n\tswitch (vnode->status.type) {\n\tcase AFS_FTYPE_FILE:\n\t\tinode->i_mode\t= S_IFREG | vnode->status.mode;\n\t\tinode->i_op\t= &afs_file_inode_operations;\n\t\tinode->i_fop\t= &afs_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_DIR:\n\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\tinode->i_op\t= &afs_dir_inode_operations;\n\t\tinode->i_fop\t= &afs_dir_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_SYMLINK:\n\t\tinode->i_mode\t= S_IFLNK | vnode->status.mode;\n\t\tinode->i_op\t= &page_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"kAFS: AFS vnode with undefined type\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\tif (vnode->status.size != inode->i_size)\n\t\tfscache_attr_changed(vnode->cache);\n#endif\n\n\tset_nlink(inode, vnode->status.nlink);\n\tinode->i_uid\t\t= vnode->status.owner;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_size\t\t= vnode->status.size;\n\tinode->i_ctime.tv_sec\t= vnode->status.mtime_server;\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_generation\t= vnode->fid.unique;\n\tinode->i_version\t= vnode->status.data_version;\n\tinode->i_mapping->a_ops\t= &afs_fs_aops;\n\n\t/* check to see whether a symbolic link is really a mountpoint */\n\tif (vnode->status.type == AFS_FTYPE_SYMLINK) {\n\t\tafs_mntpt_check_symlink(vnode, key);\n\n\t\tif (test_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags)) {\n\t\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\t\tinode->i_op\t= &afs_mntpt_inode_operations;\n\t\t\tinode->i_fop\t= &afs_mntpt_file_operations;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_inode_map_status(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct inode *inode = AFS_VNODE_TO_I(vnode);\n\n\t_debug(\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\",\n\t       vnode->status.type,\n\t       vnode->status.nlink,\n\t       (unsigned long long) vnode->status.size,\n\t       vnode->status.data_version,\n\t       vnode->status.mode);\n\n\tswitch (vnode->status.type) {\n\tcase AFS_FTYPE_FILE:\n\t\tinode->i_mode\t= S_IFREG | vnode->status.mode;\n\t\tinode->i_op\t= &afs_file_inode_operations;\n\t\tinode->i_fop\t= &afs_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_DIR:\n\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\tinode->i_op\t= &afs_dir_inode_operations;\n\t\tinode->i_fop\t= &afs_dir_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_SYMLINK:\n\t\tinode->i_mode\t= S_IFLNK | vnode->status.mode;\n\t\tinode->i_op\t= &page_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"kAFS: AFS vnode with undefined type\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\tif (vnode->status.size != inode->i_size)\n\t\tfscache_attr_changed(vnode->cache);\n#endif\n\n\tset_nlink(inode, vnode->status.nlink);\n\tinode->i_uid\t\t= vnode->status.owner;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_size\t\t= vnode->status.size;\n\tinode->i_ctime.tv_sec\t= vnode->status.mtime_server;\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_generation\t= vnode->fid.unique;\n\tinode->i_version\t= vnode->status.data_version;\n\tinode->i_mapping->a_ops\t= &afs_fs_aops;\n\n\t/* check to see whether a symbolic link is really a mountpoint */\n\tif (vnode->status.type == AFS_FTYPE_SYMLINK) {\n\t\tafs_mntpt_check_symlink(vnode, key);\n\n\t\tif (test_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags)) {\n\t\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\t\tinode->i_op\t= &afs_mntpt_inode_operations;\n\t\t\tinode->i_fop\t= &afs_mntpt_file_operations;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "vnode->volume->cache",
            "&afs_vnode_cache_index_def",
            "vnode",
            "true"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vnode->status",
            "status",
            "sizeof(vnode->status)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "NULL",
            "key"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"GOT INODE %p { vl=%x vn=%x, u=%x }\"",
            "inode",
            "fid->vid",
            "fid->vnode",
            "fid->unique"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "fid->vnode",
            "afs_iget5_test",
            "afs_iget5_set",
            "&data"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%x:%u.%u},,\"",
            "fid->vid",
            "fid->vnode",
            "fid->unique"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "afs_iget_autocell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "136-193",
    "snippet": "struct inode *afs_iget_autocell(struct inode *dir, const char *dev_name,\n\t\t\t\tint namesz, struct key *key)\n{\n\tstruct afs_iget_data data;\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tstatic atomic_t afs_autocell_ino;\n\n\t_enter(\"{%x:%u},%*.*s,\",\n\t       AFS_FS_I(dir)->fid.vid, AFS_FS_I(dir)->fid.vnode,\n\t       namesz, namesz, dev_name ?: \"\");\n\n\tsb = dir->i_sb;\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\tdata.fid.vid = as->volume->vid;\n\tdata.fid.unique = 0;\n\tdata.fid.vnode = 0;\n\n\tinode = iget5_locked(sb, atomic_inc_return(&afs_autocell_ino),\n\t\t\t     afs_iget5_autocell_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }\",\n\t       inode, inode->i_ino, data.fid.vid, data.fid.vnode,\n\t       data.fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* there shouldn't be an existing inode */\n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tinode->i_size\t\t= 0;\n\tinode->i_mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_op\t\t= &afs_autocell_inode_operations;\n\tset_nlink(inode, 2);\n\tinode->i_uid\t\t= GLOBAL_ROOT_UID;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_ctime.tv_sec\t= get_seconds();\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_version\t= 0;\n\tinode->i_generation\t= 0;\n\n\tset_bit(AFS_VNODE_PSEUDODIR, &vnode->flags);\n\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\tinode->i_flags |= S_AUTOMOUNT | S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p\"",
            "inode"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_MOUNTPOINT",
            "&vnode->flags"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(inode->i_state & I_NEW)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }\"",
            "inode",
            "inode->i_ino",
            "data.fid.vid",
            "data.fid.vnode",
            "data.fid.unique"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "atomic_inc_return(&afs_autocell_ino)",
            "afs_iget5_autocell_test",
            "afs_iget5_set",
            "&data"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&afs_autocell_ino"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%*.*s,\"",
            "AFS_FS_I(dir)->fid.vid",
            "AFS_FS_I(dir)->fid.vnode",
            "namesz",
            "namesz",
            "dev_name ?: \"\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget_autocell(struct inode *dir, const char *dev_name,\n\t\t\t\tint namesz, struct key *key)\n{\n\tstruct afs_iget_data data;\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tstatic atomic_t afs_autocell_ino;\n\n\t_enter(\"{%x:%u},%*.*s,\",\n\t       AFS_FS_I(dir)->fid.vid, AFS_FS_I(dir)->fid.vnode,\n\t       namesz, namesz, dev_name ?: \"\");\n\n\tsb = dir->i_sb;\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\tdata.fid.vid = as->volume->vid;\n\tdata.fid.unique = 0;\n\tdata.fid.vnode = 0;\n\n\tinode = iget5_locked(sb, atomic_inc_return(&afs_autocell_ino),\n\t\t\t     afs_iget5_autocell_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }\",\n\t       inode, inode->i_ino, data.fid.vid, data.fid.vnode,\n\t       data.fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* there shouldn't be an existing inode */\n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tinode->i_size\t\t= 0;\n\tinode->i_mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_op\t\t= &afs_autocell_inode_operations;\n\tset_nlink(inode, 2);\n\tinode->i_uid\t\t= GLOBAL_ROOT_UID;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_ctime.tv_sec\t= get_seconds();\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_version\t= 0;\n\tinode->i_generation\t= 0;\n\n\tset_bit(AFS_VNODE_PSEUDODIR, &vnode->flags);\n\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\tinode->i_flags |= S_AUTOMOUNT | S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "afs_iget5_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "120-131",
    "snippet": "static int afs_iget5_set(struct inode *inode, void *opaque)\n{\n\tstruct afs_iget_data *data = opaque;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\tinode->i_ino = data->fid.vnode;\n\tinode->i_generation = data->fid.unique;\n\tvnode->fid = data->fid;\n\tvnode->volume = data->volume;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_iget5_set(struct inode *inode, void *opaque)\n{\n\tstruct afs_iget_data *data = opaque;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\tinode->i_ino = data->fid.vnode;\n\tinode->i_generation = data->fid.unique;\n\tvnode->fid = data->fid;\n\tvnode->volume = data->volume;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_iget5_autocell_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "112-115",
    "snippet": "static int afs_iget5_autocell_test(struct inode *inode, void *opaque)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_iget5_autocell_test(struct inode *inode, void *opaque)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_iget5_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "99-105",
    "snippet": "static int afs_iget5_test(struct inode *inode, void *opaque)\n{\n\tstruct afs_iget_data *data = opaque;\n\n\treturn inode->i_ino == data->fid.vnode &&\n\t\tinode->i_generation == data->fid.unique;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_iget5_test(struct inode *inode, void *opaque)\n{\n\tstruct afs_iget_data *data = opaque;\n\n\treturn inode->i_ino == data->fid.vnode &&\n\t\tinode->i_generation == data->fid.unique;\n}"
  },
  {
    "function_name": "afs_inode_map_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
    "lines": "34-94",
    "snippet": "static int afs_inode_map_status(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct inode *inode = AFS_VNODE_TO_I(vnode);\n\n\t_debug(\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\",\n\t       vnode->status.type,\n\t       vnode->status.nlink,\n\t       (unsigned long long) vnode->status.size,\n\t       vnode->status.data_version,\n\t       vnode->status.mode);\n\n\tswitch (vnode->status.type) {\n\tcase AFS_FTYPE_FILE:\n\t\tinode->i_mode\t= S_IFREG | vnode->status.mode;\n\t\tinode->i_op\t= &afs_file_inode_operations;\n\t\tinode->i_fop\t= &afs_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_DIR:\n\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\tinode->i_op\t= &afs_dir_inode_operations;\n\t\tinode->i_fop\t= &afs_dir_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_SYMLINK:\n\t\tinode->i_mode\t= S_IFLNK | vnode->status.mode;\n\t\tinode->i_op\t= &page_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"kAFS: AFS vnode with undefined type\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\tif (vnode->status.size != inode->i_size)\n\t\tfscache_attr_changed(vnode->cache);\n#endif\n\n\tset_nlink(inode, vnode->status.nlink);\n\tinode->i_uid\t\t= vnode->status.owner;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_size\t\t= vnode->status.size;\n\tinode->i_ctime.tv_sec\t= vnode->status.mtime_server;\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_generation\t= vnode->fid.unique;\n\tinode->i_version\t= vnode->status.data_version;\n\tinode->i_mapping->a_ops\t= &afs_fs_aops;\n\n\t/* check to see whether a symbolic link is really a mountpoint */\n\tif (vnode->status.type == AFS_FTYPE_SYMLINK) {\n\t\tafs_mntpt_check_symlink(vnode, key);\n\n\t\tif (test_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags)) {\n\t\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\t\tinode->i_op\t= &afs_mntpt_inode_operations;\n\t\t\tinode->i_fop\t= &afs_mntpt_file_operations;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_MOUNTPOINT",
            "&vnode->flags"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_mntpt_check_symlink",
          "args": [
            "vnode",
            "key"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "afs_mntpt_check_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/mntpt.c",
          "lines": "53-100",
          "snippet": "int afs_mntpt_check_symlink(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct page *page;\n\tsize_t size;\n\tchar *buf;\n\tint ret;\n\n\t_enter(\"{%x:%u,%u}\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\t/* read the contents of the symlink into the pagecache */\n\tpage = read_cache_page(AFS_VNODE_TO_I(vnode)->i_mapping, 0,\n\t\t\t       afs_page_filler, key);\n\tif (IS_ERR(page)) {\n\t\tret = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\tif (PageError(page))\n\t\tgoto out_free;\n\n\tbuf = kmap(page);\n\n\t/* examine the symlink's contents */\n\tsize = vnode->status.size;\n\t_debug(\"symlink to %*.*s\", (int) size, (int) size, buf);\n\n\tif (size > 2 &&\n\t    (buf[0] == '%' || buf[0] == '#') &&\n\t    buf[size - 1] == '.'\n\t    ) {\n\t\t_debug(\"symlink is a mountpoint\");\n\t\tspin_lock(&vnode->lock);\n\t\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\t\tvnode->vfs_inode.i_flags |= S_AUTOMOUNT;\n\t\tspin_unlock(&vnode->lock);\n\t}\n\n\tret = 0;\n\n\tkunmap(page);\nout_free:\n\tpage_cache_release(page);\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_mntpt_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_mntpt_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags);\n\nint afs_mntpt_check_symlink(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct page *page;\n\tsize_t size;\n\tchar *buf;\n\tint ret;\n\n\t_enter(\"{%x:%u,%u}\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\t/* read the contents of the symlink into the pagecache */\n\tpage = read_cache_page(AFS_VNODE_TO_I(vnode)->i_mapping, 0,\n\t\t\t       afs_page_filler, key);\n\tif (IS_ERR(page)) {\n\t\tret = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\tif (PageError(page))\n\t\tgoto out_free;\n\n\tbuf = kmap(page);\n\n\t/* examine the symlink's contents */\n\tsize = vnode->status.size;\n\t_debug(\"symlink to %*.*s\", (int) size, (int) size, buf);\n\n\tif (size > 2 &&\n\t    (buf[0] == '%' || buf[0] == '#') &&\n\t    buf[size - 1] == '.'\n\t    ) {\n\t\t_debug(\"symlink is a mountpoint\");\n\t\tspin_lock(&vnode->lock);\n\t\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\t\tvnode->vfs_inode.i_flags |= S_AUTOMOUNT;\n\t\tspin_unlock(&vnode->lock);\n\t}\n\n\tret = 0;\n\n\tkunmap(page);\nout_free:\n\tpage_cache_release(page);\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "vnode->status.nlink"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_attr_changed",
          "args": [
            "vnode->cache"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_attr_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "197-248",
          "snippet": "int __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: AFS vnode with undefined type\\n\""
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\"",
            "vnode->status.type",
            "vnode->status.nlink",
            "(unsigned long long) vnode->status.size",
            "vnode->status.data_version",
            "vnode->status.mode"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_VNODE_TO_I",
          "args": [
            "vnode"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_VNODE_TO_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "692-695",
          "snippet": "static inline struct inode *AFS_VNODE_TO_I(struct afs_vnode *vnode)\n{\n\treturn &vnode->vfs_inode;\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct inode *AFS_VNODE_TO_I(struct afs_vnode *vnode)\n{\n\treturn &vnode->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_inode_map_status(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct inode *inode = AFS_VNODE_TO_I(vnode);\n\n\t_debug(\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\",\n\t       vnode->status.type,\n\t       vnode->status.nlink,\n\t       (unsigned long long) vnode->status.size,\n\t       vnode->status.data_version,\n\t       vnode->status.mode);\n\n\tswitch (vnode->status.type) {\n\tcase AFS_FTYPE_FILE:\n\t\tinode->i_mode\t= S_IFREG | vnode->status.mode;\n\t\tinode->i_op\t= &afs_file_inode_operations;\n\t\tinode->i_fop\t= &afs_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_DIR:\n\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\tinode->i_op\t= &afs_dir_inode_operations;\n\t\tinode->i_fop\t= &afs_dir_file_operations;\n\t\tbreak;\n\tcase AFS_FTYPE_SYMLINK:\n\t\tinode->i_mode\t= S_IFLNK | vnode->status.mode;\n\t\tinode->i_op\t= &page_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"kAFS: AFS vnode with undefined type\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\tif (vnode->status.size != inode->i_size)\n\t\tfscache_attr_changed(vnode->cache);\n#endif\n\n\tset_nlink(inode, vnode->status.nlink);\n\tinode->i_uid\t\t= vnode->status.owner;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_size\t\t= vnode->status.size;\n\tinode->i_ctime.tv_sec\t= vnode->status.mtime_server;\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_generation\t= vnode->fid.unique;\n\tinode->i_version\t= vnode->status.data_version;\n\tinode->i_mapping->a_ops\t= &afs_fs_aops;\n\n\t/* check to see whether a symbolic link is really a mountpoint */\n\tif (vnode->status.type == AFS_FTYPE_SYMLINK) {\n\t\tafs_mntpt_check_symlink(vnode, key);\n\n\t\tif (test_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags)) {\n\t\t\tinode->i_mode\t= S_IFDIR | vnode->status.mode;\n\t\t\tinode->i_op\t= &afs_mntpt_inode_operations;\n\t\t\tinode->i_fop\t= &afs_mntpt_file_operations;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  }
]