[
  {
    "function_name": "leaf_paste_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "1314-1427",
    "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb_from_bi(bi)",
            "\"vs-10250\"",
            "\"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\"",
            "ih",
            "i",
            "deh + i",
            "deh + i + 1"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_from_bi",
          "args": [
            "bi"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "sb_from_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2602-2605",
          "snippet": "static inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void store_print_tb(struct tree_balance *tb);",
            "void make_empty_node(struct buffer_info *);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid store_print_tb(struct tree_balance *tb);\nvoid make_empty_node(struct buffer_info *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i - 1]"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i + 1]"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "ih",
            "deh_offset(new_dehs)"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "new_dehs"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "&deh[i]",
            "deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&new_dehs[new_entry_count - 1]"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "deh",
            "new_dehs",
            "DEH_SIZE * new_entry_count"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)(deh + new_entry_count)",
            "deh",
            "insert_point - (char *)deh"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "insert_point + DEH_SIZE * new_entry_count",
            "records",
            "paste_size - DEH_SIZE * new_entry_count"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "insert_point + paste_size",
            "insert_point",
            "item + (ih_item_len(ih) - paste_size) - insert_point"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_entry_count",
          "args": [
            "ih",
            "ih_entry_count(ih) + new_entry_count"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "&deh[i]",
            "deh_location(&deh[i]) + paste_size"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "&deh[i]",
            "deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[before - 1]"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_entry_count(ih) < before",
            "\"10230: there are no entry we paste entries before. entry_count = %d, before = %d\"",
            "ih_entry_count(ih)",
            "before"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!is_direntry_le_ih(ih)",
            "\"10225: item is not directory item\""
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "item_num"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
  },
  {
    "function_name": "leaf_delete_items_entirely",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "1240-1308",
    "snippet": "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr;\n\tint i, j;\n\tint last_loc, last_removed_loc;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(bh == NULL, \"10210: buffer is 0\");\n\tRFALSE(del_num < 0, \"10215: del_num less than 0 (%d)\", del_num);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(first < 0 || first + del_num > nr,\n\t       \"10220: first=%d, number=%d, there is %d items\", first, del_num,\n\t       nr);\n\n\tif (first == 0 && del_num == nr) {\n\t\t/* this does not work */\n\t\tmake_empty_node(bi);\n\n\t\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tih = item_head(bh, first);\n\n\t/* location of unmovable item */\n\tj = (first == 0) ? bh->b_size : ih_location(ih - 1);\n\n\t/* delete items */\n\tlast_loc = ih_location(&ih[nr - 1 - first]);\n\tlast_removed_loc = ih_location(&ih[del_num - 1]);\n\n\tmemmove(bh->b_data + last_loc + j - last_removed_loc,\n\t\tbh->b_data + last_loc, last_removed_loc - last_loc);\n\n\t/* delete item headers */\n\tmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\n\n\t/* change item location */\n\tfor (i = first; i < nr - del_num; i++)\n\t\tput_ih_location(&ih[i - first],\n\t\t\t\tih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num));\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "bi->tb",
            "bi->bi_parent",
            "0"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num)"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bi->bi_parent",
            "bi->bi_position"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "bi->tb",
            "bh",
            "0"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) - del_num"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_location",
          "args": [
            "&ih[i - first]",
            "ih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc)"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[i - first]"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ih",
            "ih + del_num",
            "(nr - first - del_num) * IH_SIZE"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + last_loc + j - last_removed_loc",
            "bh->b_data + last_loc",
            "last_removed_loc - last_loc"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[del_num - 1]"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[nr - 1 - first]"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih - 1"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "first"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_node",
          "args": [
            "bi"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1479-1491",
          "snippet": "void make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "first < 0 || first + del_num > nr",
            "\"10220: first=%d, number=%d, there is %d items\"",
            "first",
            "del_num",
            "nr"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bh"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "del_num < 0",
            "\"10215: del_num less than 0 (%d)\"",
            "del_num"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bh == NULL",
            "\"10210: buffer is 0\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr;\n\tint i, j;\n\tint last_loc, last_removed_loc;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(bh == NULL, \"10210: buffer is 0\");\n\tRFALSE(del_num < 0, \"10215: del_num less than 0 (%d)\", del_num);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(first < 0 || first + del_num > nr,\n\t       \"10220: first=%d, number=%d, there is %d items\", first, del_num,\n\t       nr);\n\n\tif (first == 0 && del_num == nr) {\n\t\t/* this does not work */\n\t\tmake_empty_node(bi);\n\n\t\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tih = item_head(bh, first);\n\n\t/* location of unmovable item */\n\tj = (first == 0) ? bh->b_size : ih_location(ih - 1);\n\n\t/* delete items */\n\tlast_loc = ih_location(&ih[nr - 1 - first]);\n\tlast_removed_loc = ih_location(&ih[del_num - 1]);\n\n\tmemmove(bh->b_data + last_loc + j - last_removed_loc,\n\t\tbh->b_data + last_loc, last_removed_loc - last_loc);\n\n\t/* delete item headers */\n\tmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\n\n\t/* change item location */\n\tfor (i = first; i < nr - del_num; i++)\n\t\tput_ih_location(&ih[i - first],\n\t\t\t\tih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num));\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
  },
  {
    "function_name": "leaf_cut_from_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "1145-1237",
    "snippet": "void leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "bi->tb",
            "bi->bi_parent",
            "0"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) - cut_size"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bi->bi_parent",
            "bi->bi_position"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "bi->tb",
            "bh",
            "0"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) + cut_size"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_location",
          "args": [
            "&ih[i - cut_item_num]",
            "ih_location(&ih[i - cut_item_num]) + cut_size"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[i - cut_item_num]"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "ih",
            "0"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "ih_item_len(ih) - cut_size"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + last_loc + cut_size",
            "bh->b_data + last_loc",
            "unmoved_loc - last_loc - cut_size"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih - 1"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[nr - cut_item_num - 1]"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih)",
            "\"10205: invalid ih_free_space (%h)\"",
            "ih"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "ih",
            "le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + ih_location(ih)",
            "bh->b_data + ih_location(ih) + cut_size",
            "ih_item_len(ih) - cut_size"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "pos_in_item && pos_in_item + cut_size != ih_item_len(ih)",
            "\"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\"",
            "(long unsigned)pos_in_item",
            "(long unsigned)cut_size",
            "(long unsigned)ih_item_len(ih)"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "is_statdata_le_ih(ih)",
            "\"10195: item is stat data\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "ih"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "B_I_DEH(bh, ih)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cut_item_num",
            "\"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\"",
            "cut_item_num"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_cut_entries",
          "args": [
            "bh",
            "ih",
            "pos_in_item",
            "cut_size"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_cut_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1072-1134",
          "snippet": "static int leaf_cut_entries(struct buffer_head *bh,\n\t\t\t    struct item_head *ih, int from, int del_count)\n{\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tint prev_record_offset;\t/* offset of record, that is (from-1)th */\n\tchar *prev_record;\t/* */\n\tint cut_records_len;\t/* length of all removed records */\n\tint i;\n\n\t/*\n\t * make sure that item is directory and there are enough entries to\n\t * remove\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10180: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < from + del_count,\n\t       \"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\",\n\t       ih_entry_count(ih), from, del_count);\n\n\tif (del_count == 0)\n\t\treturn 0;\n\n\t/* first byte of item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/*\n\t * first byte of remaining entries, those are BEFORE cut entries\n\t * (prev_record) and length of all removed records (cut_records_len)\n\t */\n\tprev_record_offset =\n\t    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\n\tcut_records_len = prev_record_offset /*from_record */  -\n\t    deh_location(&deh[from + del_count - 1]);\n\tprev_record = item + prev_record_offset;\n\n\t/* adjust locations of remaining entries */\n\tfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count));\n\n\tfor (i = 0; i < from; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len));\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\n\n\t/* shift entry head array and entries those are AFTER removed entries */\n\tmemmove((char *)(deh + from),\n\t\tdeh + from + del_count,\n\t\tprev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count));\n\n\t/* shift records, those are BEFORE removed entries */\n\tmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\n\t\tprev_record, item + ih_item_len(ih) - prev_record);\n\n\treturn DEH_SIZE * del_count + cut_records_len;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_cut_entries(struct buffer_head *bh,\n\t\t\t    struct item_head *ih, int from, int del_count)\n{\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tint prev_record_offset;\t/* offset of record, that is (from-1)th */\n\tchar *prev_record;\t/* */\n\tint cut_records_len;\t/* length of all removed records */\n\tint i;\n\n\t/*\n\t * make sure that item is directory and there are enough entries to\n\t * remove\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10180: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < from + del_count,\n\t       \"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\",\n\t       ih_entry_count(ih), from, del_count);\n\n\tif (del_count == 0)\n\t\treturn 0;\n\n\t/* first byte of item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/*\n\t * first byte of remaining entries, those are BEFORE cut entries\n\t * (prev_record) and length of all removed records (cut_records_len)\n\t */\n\tprev_record_offset =\n\t    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\n\tcut_records_len = prev_record_offset /*from_record */  -\n\t    deh_location(&deh[from + del_count - 1]);\n\tprev_record = item + prev_record_offset;\n\n\t/* adjust locations of remaining entries */\n\tfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count));\n\n\tfor (i = 0; i < from; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len));\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\n\n\t/* shift entry head array and entries those are AFTER removed entries */\n\tmemmove((char *)(deh + from),\n\t\tdeh + from + del_count,\n\t\tprev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count));\n\n\t/* shift records, those are BEFORE removed entries */\n\tmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\n\t\tprev_record, item + ih_item_len(ih) - prev_record);\n\n\treturn DEH_SIZE * del_count + cut_records_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "cut_item_num"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bh"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
  },
  {
    "function_name": "leaf_cut_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "1072-1134",
    "snippet": "static int leaf_cut_entries(struct buffer_head *bh,\n\t\t\t    struct item_head *ih, int from, int del_count)\n{\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tint prev_record_offset;\t/* offset of record, that is (from-1)th */\n\tchar *prev_record;\t/* */\n\tint cut_records_len;\t/* length of all removed records */\n\tint i;\n\n\t/*\n\t * make sure that item is directory and there are enough entries to\n\t * remove\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10180: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < from + del_count,\n\t       \"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\",\n\t       ih_entry_count(ih), from, del_count);\n\n\tif (del_count == 0)\n\t\treturn 0;\n\n\t/* first byte of item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/*\n\t * first byte of remaining entries, those are BEFORE cut entries\n\t * (prev_record) and length of all removed records (cut_records_len)\n\t */\n\tprev_record_offset =\n\t    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\n\tcut_records_len = prev_record_offset /*from_record */  -\n\t    deh_location(&deh[from + del_count - 1]);\n\tprev_record = item + prev_record_offset;\n\n\t/* adjust locations of remaining entries */\n\tfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count));\n\n\tfor (i = 0; i < from; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len));\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\n\n\t/* shift entry head array and entries those are AFTER removed entries */\n\tmemmove((char *)(deh + from),\n\t\tdeh + from + del_count,\n\t\tprev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count));\n\n\t/* shift records, those are BEFORE removed entries */\n\tmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\n\t\tprev_record, item + ih_item_len(ih) - prev_record);\n\n\treturn DEH_SIZE * del_count + cut_records_len;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "prev_record - cut_records_len - DEH_SIZE * del_count",
            "prev_record",
            "item + ih_item_len(ih) - prev_record"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)(deh + from)",
            "deh + from + del_count",
            "prev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_entry_count",
          "args": [
            "ih",
            "ih_entry_count(ih) - del_count"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "&deh[i]",
            "deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "&deh[i]",
            "deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[i]"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[from + del_count - 1]"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[from - 1]"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_entry_count(ih) < from + del_count",
            "\"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\"",
            "ih_entry_count(ih)",
            "from",
            "del_count"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!is_direntry_le_ih(ih)",
            "\"10180: item is not directory item\""
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_cut_entries(struct buffer_head *bh,\n\t\t\t    struct item_head *ih, int from, int del_count)\n{\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tint prev_record_offset;\t/* offset of record, that is (from-1)th */\n\tchar *prev_record;\t/* */\n\tint cut_records_len;\t/* length of all removed records */\n\tint i;\n\n\t/*\n\t * make sure that item is directory and there are enough entries to\n\t * remove\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10180: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < from + del_count,\n\t       \"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\",\n\t       ih_entry_count(ih), from, del_count);\n\n\tif (del_count == 0)\n\t\treturn 0;\n\n\t/* first byte of item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/*\n\t * first byte of remaining entries, those are BEFORE cut entries\n\t * (prev_record) and length of all removed records (cut_records_len)\n\t */\n\tprev_record_offset =\n\t    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\n\tcut_records_len = prev_record_offset /*from_record */  -\n\t    deh_location(&deh[from + del_count - 1]);\n\tprev_record = item + prev_record_offset;\n\n\t/* adjust locations of remaining entries */\n\tfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count));\n\n\tfor (i = 0; i < from; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len));\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\n\n\t/* shift entry head array and entries those are AFTER removed entries */\n\tmemmove((char *)(deh + from),\n\t\tdeh + from + del_count,\n\t\tprev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count));\n\n\t/* shift records, those are BEFORE removed entries */\n\tmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\n\t\tprev_record, item + ih_item_len(ih) - prev_record);\n\n\treturn DEH_SIZE * del_count + cut_records_len;\n}"
  },
  {
    "function_name": "leaf_paste_in_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "978-1064",
    "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "bi->tb",
            "bi->bi_parent",
            "0"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + paste_size"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bi->bi_parent",
            "bi->bi_position"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "bi->tb",
            "bh",
            "0"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "free_space - paste_size"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "ih_item_len(ih) + paste_size"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + unmoved_loc - paste_size",
            "'\\0'",
            "paste_size"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number",
            "body",
            "paste_size - zeros_number"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + unmoved_loc - paste_size",
            "0",
            "zeros_number"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number",
            "body",
            "paste_size - zeros_number"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + ih_location(ih)",
            "0",
            "zeros_number"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size",
            "bh->b_data + ih_location(ih)",
            "ih_item_len(ih)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_location",
          "args": [
            "&ih[i - affected_item_num]",
            "ih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[i - affected_item_num]"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + last_loc - paste_size",
            "bh->b_data + last_loc",
            "unmoved_loc - last_loc"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih - 1"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[nr - affected_item_num - 1]"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "affected_item_num"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"vs-10177\"",
            "\"zeros_number == %d, paste_size == %d\"",
            "zeros_number",
            "paste_size"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"10177\""
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "free_space < paste_size",
            "\"vs-10175: not enough free space: needed %d, available %d\"",
            "paste_size",
            "free_space"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bh"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
  },
  {
    "function_name": "leaf_insert_into_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "901-972",
    "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "bi->tb",
            "bi->bi_parent",
            "0"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih))"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bi->bi_parent",
            "bi->bi_position"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "bi->tb",
            "bh",
            "1"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih))"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) + 1"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_location",
          "args": [
            "&ih[i - before]",
            "unmoved_loc"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "&ih[i - before]"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ih",
            "inserted_item_ih",
            "IH_SIZE"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ih + 1",
            "ih",
            "IH_SIZE * (nr - before)"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "to",
            "'\\0'",
            "ih_item_len(inserted_item_ih) - zeros_number"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "inserted_item_body",
            "ih_item_len(inserted_item_ih) - zeros_number"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "to",
            "0",
            "zeros_number"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bh->b_data + last_loc - ih_item_len(inserted_item_ih)",
            "bh->b_data + last_loc",
            "unmoved_loc - last_loc"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih - 1"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[nr - before - 1]"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "before"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "zeros_number > ih_item_len(inserted_item_ih)",
            "\"vs-10172: zero number == %d, item length == %d\"",
            "zeros_number",
            "ih_item_len(inserted_item_ih)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "free_space < ih_item_len(inserted_item_ih) + IH_SIZE",
            "\"vs-10170: not enough free space in block %z, new item %h\"",
            "bh",
            "inserted_item_ih"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "inserted_item_ih"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bh"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
  },
  {
    "function_name": "leaf_delete_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "827-898",
    "snippet": "void leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_cut_from_buffer",
          "args": [
            "cur_bi",
            "B_NR_ITEMS(bh) - 1",
            "len - del_bytes",
            "del_bytes"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_cut_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1145-1237",
          "snippet": "void leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "B_NR_ITEMS(bh) - 1"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_delete_items_entirely",
          "args": [
            "cur_bi",
            "first + 1",
            "del_num - 1"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_delete_items_entirely",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1240-1308",
          "snippet": "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr;\n\tint i, j;\n\tint last_loc, last_removed_loc;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(bh == NULL, \"10210: buffer is 0\");\n\tRFALSE(del_num < 0, \"10215: del_num less than 0 (%d)\", del_num);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(first < 0 || first + del_num > nr,\n\t       \"10220: first=%d, number=%d, there is %d items\", first, del_num,\n\t       nr);\n\n\tif (first == 0 && del_num == nr) {\n\t\t/* this does not work */\n\t\tmake_empty_node(bi);\n\n\t\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tih = item_head(bh, first);\n\n\t/* location of unmovable item */\n\tj = (first == 0) ? bh->b_size : ih_location(ih - 1);\n\n\t/* delete items */\n\tlast_loc = ih_location(&ih[nr - 1 - first]);\n\tlast_removed_loc = ih_location(&ih[del_num - 1]);\n\n\tmemmove(bh->b_data + last_loc + j - last_removed_loc,\n\t\tbh->b_data + last_loc, last_removed_loc - last_loc);\n\n\t/* delete item headers */\n\tmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\n\n\t/* change item location */\n\tfor (i = first; i < nr - del_num; i++)\n\t\tput_ih_location(&ih[i - first],\n\t\t\t\tih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num));\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr;\n\tint i, j;\n\tint last_loc, last_removed_loc;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(bh == NULL, \"10210: buffer is 0\");\n\tRFALSE(del_num < 0, \"10215: del_num less than 0 (%d)\", del_num);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(first < 0 || first + del_num > nr,\n\t       \"10220: first=%d, number=%d, there is %d items\", first, del_num,\n\t       nr);\n\n\tif (first == 0 && del_num == nr) {\n\t\t/* this does not work */\n\t\tmake_empty_node(bi);\n\n\t\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tih = item_head(bh, first);\n\n\t/* location of unmovable item */\n\tj = (first == 0) ? bh->b_size : ih_location(ih - 1);\n\n\t/* delete items */\n\tlast_loc = ih_location(&ih[nr - 1 - first]);\n\tlast_removed_loc = ih_location(&ih[del_num - 1]);\n\n\tmemmove(bh->b_data + last_loc + j - last_removed_loc,\n\t\tbh->b_data + last_loc, last_removed_loc - last_loc);\n\n\t/* delete item headers */\n\tmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\n\n\t/* change item location */\n\tfor (i = first; i < nr - del_num; i++)\n\t\tput_ih_location(&ih[i - first],\n\t\t\t\tih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num));\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "cur_bi->tb",
            "bh",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_node",
          "args": [
            "cur_bi"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1479-1491",
          "snippet": "void make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "first < 0\n\t       || first + del_num > item_amount",
            "\"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\"",
            "first",
            "first + del_num",
            "item_amount"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "del_num < 0",
            "\"10160: del_num can not be < 0. del_num==%d\"",
            "del_num"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!bh",
            "\"10155: bh is not defined\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh = cur_bi->bi_bh"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n\nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "leaf_shift_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "794-812",
    "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFR[0]",
            "tb->rkey[0]",
            "tb->R[0]",
            "0"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_R",
            "tb",
            "shift_num",
            "shift_bytes",
            "NULL"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
  },
  {
    "function_name": "leaf_shift_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "741-786",
    "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size))",
            "\"vs-10280: item must be mergeable\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "leaf_key(S0, 0)",
            "S0->b_size"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "S0",
            "0"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "item_head(S0, 0)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "S0",
            "0"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "item_head(S0, 0)"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFL[0]",
            "tb->lkey[0]",
            "S0",
            "0"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-10275\"",
            "\"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\"",
            "tb->tb_mode"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"vs-10275\""
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "shift_bytes != -1",
            "\"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\"",
            "shift_bytes"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "S0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_L",
            "tb",
            "shift_num",
            "shift_bytes",
            "NULL"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "leaf_move_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "715-735",
    "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_delete_items",
          "args": [
            "&src_bi",
            "first_last",
            "(first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num)",
            "mov_num",
            "mov_bytes"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_delete_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "827-898",
          "snippet": "void leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n\nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src_bi.bi_bh"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_copy_items",
          "args": [
            "&dest_bi",
            "src_bi.bi_bh",
            "first_last",
            "mov_num",
            "mov_bytes"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_copy_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "521-622",
          "snippet": "static int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\n\t\t\t   int last_first, int cpy_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest;\n\tint pos, i, src_nr_item, bytes;\n\n\tdest = dest_bi->bi_bh;\n\tRFALSE(!dest || !src, \"vs-10210: !dest || !src\");\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\");\n\tRFALSE(B_NR_ITEMS(src) < cpy_num,\n\t       \"vs-10230: No enough items: %d, req. %d\", B_NR_ITEMS(src),\n\t       cpy_num);\n\tRFALSE(cpy_num < 0, \"vs-10240: cpy_num < 0 (%d)\", cpy_num);\n\n\tif (cpy_num == 0)\n\t\treturn 0;\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/* copy items to left */\n\t\tpos = 0;\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the first item or it part or nothing to the end of\n\t\t * the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes))\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\t\tpos += i;\n\t\tif (cpy_bytes == -1)\n\t\t\t/*\n\t\t\t * copy first cpy_num items starting from position\n\t\t\t * 'pos' of SOURCE to end of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\telse {\n\t\t\t/*\n\t\t\t * copy first cpy_num-1 items starting from position\n\t\t\t * 'pos-1' of the SOURCE to the end of the DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is\n\t\t\t * cpy_num+pos-1 to the end of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t cpy_num + pos - 1, cpy_bytes);\n\t\t}\n\t} else {\n\t\t/* copy items to right */\n\t\tsrc_nr_item = B_NR_ITEMS(src);\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the last item or it part or nothing to the\n\t\t * begin of the DEST\n\t\t * (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes));\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\n\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\n\t\tpos = src_nr_item - cpy_num - i;\n\t\tif (cpy_bytes == -1) {\n\t\t\t/*\n\t\t\t * starting from position 'pos' copy last cpy_num\n\t\t\t * items of SOURCE to begin of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\t} else {\n\t\t\t/*\n\t\t\t * copy last cpy_num-1 items starting from position\n\t\t\t * 'pos+1' of the SOURCE to the begin of the DEST;\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos + 1, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is pos to\n\t\t\t * the begin of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\n\t\t\t\t\t cpy_bytes);\n\t\t}\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\n\t\t\t   int last_first, int cpy_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest;\n\tint pos, i, src_nr_item, bytes;\n\n\tdest = dest_bi->bi_bh;\n\tRFALSE(!dest || !src, \"vs-10210: !dest || !src\");\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\");\n\tRFALSE(B_NR_ITEMS(src) < cpy_num,\n\t       \"vs-10230: No enough items: %d, req. %d\", B_NR_ITEMS(src),\n\t       cpy_num);\n\tRFALSE(cpy_num < 0, \"vs-10240: cpy_num < 0 (%d)\", cpy_num);\n\n\tif (cpy_num == 0)\n\t\treturn 0;\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/* copy items to left */\n\t\tpos = 0;\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the first item or it part or nothing to the end of\n\t\t * the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes))\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\t\tpos += i;\n\t\tif (cpy_bytes == -1)\n\t\t\t/*\n\t\t\t * copy first cpy_num items starting from position\n\t\t\t * 'pos' of SOURCE to end of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\telse {\n\t\t\t/*\n\t\t\t * copy first cpy_num-1 items starting from position\n\t\t\t * 'pos-1' of the SOURCE to the end of the DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is\n\t\t\t * cpy_num+pos-1 to the end of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t cpy_num + pos - 1, cpy_bytes);\n\t\t}\n\t} else {\n\t\t/* copy items to right */\n\t\tsrc_nr_item = B_NR_ITEMS(src);\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the last item or it part or nothing to the\n\t\t * begin of the DEST\n\t\t * (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes));\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\n\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\n\t\tpos = src_nr_item - cpy_num - i;\n\t\tif (cpy_bytes == -1) {\n\t\t\t/*\n\t\t\t * starting from position 'pos' copy last cpy_num\n\t\t\t * items of SOURCE to begin of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\t} else {\n\t\t\t/*\n\t\t\t * copy last cpy_num-1 items starting from position\n\t\t\t * 'pos+1' of the SOURCE to the begin of the DEST;\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos + 1, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is pos to\n\t\t\t * the begin of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\n\t\t\t\t\t cpy_bytes);\n\t\t}\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_define_dest_src_infos",
          "args": [
            "shift_mode",
            "tb",
            "&dest_bi",
            "&src_bi",
            "&first_last",
            "Snew"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_define_dest_src_infos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "629-709",
          "snippet": "static void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\n\t\t\t\t       struct buffer_info *dest_bi,\n\t\t\t\t       struct buffer_info *src_bi,\n\t\t\t\t       int *first_last,\n\t\t\t\t       struct buffer_head *Snew)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\tcase LEAF_FROM_S_TO_L:\t/* it is used in leaf_shift_left */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\n\t\t/* src->b_item_order */\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_R:\t/* it is used in leaf_shift_right */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_R_TO_L:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[0];\n\t\tsrc_bi->bi_parent = tb->FR[0];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_L_TO_R:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[0];\n\t\tsrc_bi->bi_parent = tb->FL[0];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_SNEW:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = Snew;\n\t\tdest_bi->bi_parent = NULL;\n\t\tdest_bi->bi_position = 0;\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(sb_from_bi(src_bi), \"vs-10250\",\n\t\t\t       \"shift type is unknown (%d)\", shift_mode);\n\t}\n\tRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\n\t       \"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\",\n\t       shift_mode, src_bi->bi_bh, dest_bi->bi_bh);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\n\t\t\t\t       struct buffer_info *dest_bi,\n\t\t\t\t       struct buffer_info *src_bi,\n\t\t\t\t       int *first_last,\n\t\t\t\t       struct buffer_head *Snew)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\tcase LEAF_FROM_S_TO_L:\t/* it is used in leaf_shift_left */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\n\t\t/* src->b_item_order */\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_R:\t/* it is used in leaf_shift_right */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_R_TO_L:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[0];\n\t\tsrc_bi->bi_parent = tb->FR[0];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_L_TO_R:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[0];\n\t\tsrc_bi->bi_parent = tb->FL[0];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_SNEW:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = Snew;\n\t\tdest_bi->bi_parent = NULL;\n\t\tdest_bi->bi_position = 0;\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(sb_from_bi(src_bi), \"vs-10250\",\n\t\t\t       \"shift type is unknown (%d)\", shift_mode);\n\t}\n\tRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\n\t       \"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\",\n\t       shift_mode, src_bi->bi_bh, dest_bi->bi_bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
  },
  {
    "function_name": "leaf_define_dest_src_infos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "629-709",
    "snippet": "static void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\n\t\t\t\t       struct buffer_info *dest_bi,\n\t\t\t\t       struct buffer_info *src_bi,\n\t\t\t\t       int *first_last,\n\t\t\t\t       struct buffer_head *Snew)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\tcase LEAF_FROM_S_TO_L:\t/* it is used in leaf_shift_left */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\n\t\t/* src->b_item_order */\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_R:\t/* it is used in leaf_shift_right */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_R_TO_L:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[0];\n\t\tsrc_bi->bi_parent = tb->FR[0];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_L_TO_R:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[0];\n\t\tsrc_bi->bi_parent = tb->FL[0];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_SNEW:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = Snew;\n\t\tdest_bi->bi_parent = NULL;\n\t\tdest_bi->bi_position = 0;\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(sb_from_bi(src_bi), \"vs-10250\",\n\t\t\t       \"shift type is unknown (%d)\", shift_mode);\n\t}\n\tRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\n\t       \"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\",\n\t       shift_mode, src_bi->bi_bh, dest_bi->bi_bh);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!src_bi->bi_bh || !dest_bi->bi_bh",
            "\"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\"",
            "shift_mode",
            "src_bi->bi_bh",
            "dest_bi->bi_bh"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb_from_bi(src_bi)",
            "\"vs-10250\"",
            "\"shift type is unknown (%d)\"",
            "shift_mode"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_from_bi",
          "args": [
            "src_bi"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "sb_from_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2602-2605",
          "snippet": "static inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void store_print_tb(struct tree_balance *tb);",
            "void make_empty_node(struct buffer_info *);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid store_print_tb(struct tree_balance *tb);\nvoid make_empty_node(struct buffer_info *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_right_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "get_right_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1604-1616",
          "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_left_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1590-1602",
          "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src_bi",
            "0",
            "sizeof(struct buffer_info)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest_bi",
            "0",
            "sizeof(struct buffer_info)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\n\t\t\t\t       struct buffer_info *dest_bi,\n\t\t\t\t       struct buffer_info *src_bi,\n\t\t\t\t       int *first_last,\n\t\t\t\t       struct buffer_head *Snew)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\tcase LEAF_FROM_S_TO_L:\t/* it is used in leaf_shift_left */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\n\t\t/* src->b_item_order */\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_R:\t/* it is used in leaf_shift_right */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_R_TO_L:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[0];\n\t\tsrc_bi->bi_parent = tb->FR[0];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_L_TO_R:\t/* it is used in balance_leaf_when_delete */\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[0];\n\t\tsrc_bi->bi_parent = tb->FL[0];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_SNEW:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = Snew;\n\t\tdest_bi->bi_parent = NULL;\n\t\tdest_bi->bi_position = 0;\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(sb_from_bi(src_bi), \"vs-10250\",\n\t\t\t       \"shift type is unknown (%d)\", shift_mode);\n\t}\n\tRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\n\t       \"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\",\n\t       shift_mode, src_bi->bi_bh, dest_bi->bi_bh);\n}"
  },
  {
    "function_name": "leaf_copy_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "521-622",
    "snippet": "static int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\n\t\t\t   int last_first, int cpy_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest;\n\tint pos, i, src_nr_item, bytes;\n\n\tdest = dest_bi->bi_bh;\n\tRFALSE(!dest || !src, \"vs-10210: !dest || !src\");\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\");\n\tRFALSE(B_NR_ITEMS(src) < cpy_num,\n\t       \"vs-10230: No enough items: %d, req. %d\", B_NR_ITEMS(src),\n\t       cpy_num);\n\tRFALSE(cpy_num < 0, \"vs-10240: cpy_num < 0 (%d)\", cpy_num);\n\n\tif (cpy_num == 0)\n\t\treturn 0;\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/* copy items to left */\n\t\tpos = 0;\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the first item or it part or nothing to the end of\n\t\t * the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes))\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\t\tpos += i;\n\t\tif (cpy_bytes == -1)\n\t\t\t/*\n\t\t\t * copy first cpy_num items starting from position\n\t\t\t * 'pos' of SOURCE to end of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\telse {\n\t\t\t/*\n\t\t\t * copy first cpy_num-1 items starting from position\n\t\t\t * 'pos-1' of the SOURCE to the end of the DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is\n\t\t\t * cpy_num+pos-1 to the end of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t cpy_num + pos - 1, cpy_bytes);\n\t\t}\n\t} else {\n\t\t/* copy items to right */\n\t\tsrc_nr_item = B_NR_ITEMS(src);\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the last item or it part or nothing to the\n\t\t * begin of the DEST\n\t\t * (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes));\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\n\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\n\t\tpos = src_nr_item - cpy_num - i;\n\t\tif (cpy_bytes == -1) {\n\t\t\t/*\n\t\t\t * starting from position 'pos' copy last cpy_num\n\t\t\t * items of SOURCE to begin of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\t} else {\n\t\t\t/*\n\t\t\t * copy last cpy_num-1 items starting from position\n\t\t\t * 'pos+1' of the SOURCE to the begin of the DEST;\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos + 1, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is pos to\n\t\t\t * the begin of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\n\t\t\t\t\t cpy_bytes);\n\t\t}\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_item_bottle",
          "args": [
            "dest_bi",
            "src",
            "LAST_TO_FIRST",
            "pos",
            "cpy_bytes"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_item_bottle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "414-513",
          "snippet": "static void leaf_item_bottle(struct buffer_info *dest_bi,\n\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t     int item_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tstruct item_head *ih;\n\n\tRFALSE(cpy_bytes == -1,\n\t       \"vs-10170: bytes == - 1 means: do not split item\");\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer SOURCE\n\t\t * is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t      item_num, 0, cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the end of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header; change old\n\t\t\t * item_header (????); n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, IH_SIZE);\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\t\t\tif (is_indirect_le_ih(ih)) {\n\t\t\t\tRFALSE(cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\",\n\t\t\t\t       (long unsigned)get_ih_free_space(ih));\n\t\t\t\tset_ih_free_space(&n_ih, 0);\n\t\t\t}\n\n\t\t\tRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\n\t\t\t       \"vs-10190: bad mergeability of item %h\", ih);\n\t\t\tn_ih.ih_version = ih->ih_version;\t/* JDM Endian safe, both le */\n\t\t\tleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\n\t\t\t\t\t     item_body(src, item_num), 0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer\n\t\t * SOURCE is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t      item_num,\n\t\t\t\t\t      ih_entry_count(ih) - cpy_bytes,\n\t\t\t\t\t      cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the begin of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header;\n\t\t\t * n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, SHORT_KEY_SIZE);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tif (is_direct_le_ih(ih)) {\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   ih_item_len(ih) - cpy_bytes);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_DIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, MAX_US_INT);\n\t\t\t} else {\n\t\t\t\t/* indirect item */\n\t\t\t\tRFALSE(!cpy_bytes && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\");\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, get_ih_free_space(ih));\n\t\t\t}\n\n\t\t\t/* set item length */\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tleaf_insert_into_buf(dest_bi, 0, &n_ih,\n\t\t\t\t\t     item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_item_bottle(struct buffer_info *dest_bi,\n\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t     int item_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tstruct item_head *ih;\n\n\tRFALSE(cpy_bytes == -1,\n\t       \"vs-10170: bytes == - 1 means: do not split item\");\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer SOURCE\n\t\t * is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t      item_num, 0, cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the end of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header; change old\n\t\t\t * item_header (????); n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, IH_SIZE);\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\t\t\tif (is_indirect_le_ih(ih)) {\n\t\t\t\tRFALSE(cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\",\n\t\t\t\t       (long unsigned)get_ih_free_space(ih));\n\t\t\t\tset_ih_free_space(&n_ih, 0);\n\t\t\t}\n\n\t\t\tRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\n\t\t\t       \"vs-10190: bad mergeability of item %h\", ih);\n\t\t\tn_ih.ih_version = ih->ih_version;\t/* JDM Endian safe, both le */\n\t\t\tleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\n\t\t\t\t\t     item_body(src, item_num), 0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer\n\t\t * SOURCE is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t      item_num,\n\t\t\t\t\t      ih_entry_count(ih) - cpy_bytes,\n\t\t\t\t\t      cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the begin of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header;\n\t\t\t * n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, SHORT_KEY_SIZE);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tif (is_direct_le_ih(ih)) {\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   ih_item_len(ih) - cpy_bytes);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_DIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, MAX_US_INT);\n\t\t\t} else {\n\t\t\t\t/* indirect item */\n\t\t\t\tRFALSE(!cpy_bytes && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\");\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, get_ih_free_space(ih));\n\t\t\t}\n\n\t\t\t/* set item length */\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tleaf_insert_into_buf(dest_bi, 0, &n_ih,\n\t\t\t\t\t     item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_copy_items_entirely",
          "args": [
            "dest_bi",
            "src",
            "LAST_TO_FIRST",
            "pos + 1",
            "cpy_num - 1"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_copy_items_entirely",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "310-408",
          "snippet": "static void leaf_copy_items_entirely(struct buffer_info *dest_bi,\n\t\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t\t     int first, int cpy_num)\n{\n\tstruct buffer_head *dest;\n\tint nr, free_space;\n\tint dest_before;\n\tint last_loc, last_inserted_loc, location;\n\tint i, j;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\n\t       \"vs-10090: bad last_first parameter %d\", last_first);\n\tRFALSE(B_NR_ITEMS(src) - first < cpy_num,\n\t       \"vs-10100: too few items in source %d, required %d from %d\",\n\t       B_NR_ITEMS(src), cpy_num, first);\n\tRFALSE(cpy_num < 0, \"vs-10110: can not copy negative amount of items\");\n\tRFALSE(!dest_bi, \"vs-10120: can not copy negative amount of items\");\n\n\tdest = dest_bi->bi_bh;\n\n\tRFALSE(!dest, \"vs-10130: can not copy negative amount of items\");\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/*\n\t * we will insert items before 0-th or nr-th item in dest buffer.\n\t * It depends of last_first parameter\n\t */\n\tdest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\n\n\t/* location of head of first new item */\n\tih = item_head(dest, dest_before);\n\n\tRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\n\t       \"vs-10140: not enough free space for headers %d (needed %d)\",\n\t       B_FREE_SPACE(dest), cpy_num * IH_SIZE);\n\n\t/* prepare space for headers */\n\tmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\n\n\t/* copy item headers */\n\tmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\n\n\tfree_space -= (IH_SIZE * cpy_num);\n\tset_blkh_free_space(blkh, free_space);\n\n\t/* location of unmovable item */\n\tj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\n\tfor (i = dest_before; i < nr + cpy_num; i++) {\n\t\tlocation -= ih_item_len(ih + i - dest_before);\n\t\tput_ih_location(ih + i - dest_before, location);\n\t}\n\n\t/* prepare space for items */\n\tlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\n\tlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\n\n\t/* check free space */\n\tRFALSE(free_space < j - last_inserted_loc,\n\t       \"vs-10150: not enough free space for items %d (needed %d)\",\n\t       free_space, j - last_inserted_loc);\n\n\tmemmove(dest->b_data + last_loc,\n\t\tdest->b_data + last_loc + j - last_inserted_loc,\n\t\tlast_inserted_loc - last_loc);\n\n\t/* copy items */\n\tmemcpy(dest->b_data + last_inserted_loc,\n\t       item_body(src, (first + cpy_num - 1)),\n\t       j - last_inserted_loc);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, nr + cpy_num);\n\tset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\n\n\tdo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\n\t\t       \"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\",\n\t\t       (long unsigned)dest->b_blocknr,\n\t\t       (long unsigned)dc_block_number(t_dc));\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_copy_items_entirely(struct buffer_info *dest_bi,\n\t\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t\t     int first, int cpy_num)\n{\n\tstruct buffer_head *dest;\n\tint nr, free_space;\n\tint dest_before;\n\tint last_loc, last_inserted_loc, location;\n\tint i, j;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\n\t       \"vs-10090: bad last_first parameter %d\", last_first);\n\tRFALSE(B_NR_ITEMS(src) - first < cpy_num,\n\t       \"vs-10100: too few items in source %d, required %d from %d\",\n\t       B_NR_ITEMS(src), cpy_num, first);\n\tRFALSE(cpy_num < 0, \"vs-10110: can not copy negative amount of items\");\n\tRFALSE(!dest_bi, \"vs-10120: can not copy negative amount of items\");\n\n\tdest = dest_bi->bi_bh;\n\n\tRFALSE(!dest, \"vs-10130: can not copy negative amount of items\");\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/*\n\t * we will insert items before 0-th or nr-th item in dest buffer.\n\t * It depends of last_first parameter\n\t */\n\tdest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\n\n\t/* location of head of first new item */\n\tih = item_head(dest, dest_before);\n\n\tRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\n\t       \"vs-10140: not enough free space for headers %d (needed %d)\",\n\t       B_FREE_SPACE(dest), cpy_num * IH_SIZE);\n\n\t/* prepare space for headers */\n\tmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\n\n\t/* copy item headers */\n\tmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\n\n\tfree_space -= (IH_SIZE * cpy_num);\n\tset_blkh_free_space(blkh, free_space);\n\n\t/* location of unmovable item */\n\tj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\n\tfor (i = dest_before; i < nr + cpy_num; i++) {\n\t\tlocation -= ih_item_len(ih + i - dest_before);\n\t\tput_ih_location(ih + i - dest_before, location);\n\t}\n\n\t/* prepare space for items */\n\tlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\n\tlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\n\n\t/* check free space */\n\tRFALSE(free_space < j - last_inserted_loc,\n\t       \"vs-10150: not enough free space for items %d (needed %d)\",\n\t       free_space, j - last_inserted_loc);\n\n\tmemmove(dest->b_data + last_loc,\n\t\tdest->b_data + last_loc + j - last_inserted_loc,\n\t\tlast_inserted_loc - last_loc);\n\n\t/* copy items */\n\tmemcpy(dest->b_data + last_inserted_loc,\n\t       item_body(src, (first + cpy_num - 1)),\n\t       j - last_inserted_loc);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, nr + cpy_num);\n\tset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\n\n\tdo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\n\t\t       \"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\",\n\t\t       (long unsigned)dest->b_blocknr,\n\t\t       (long unsigned)dc_block_number(t_dc));\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_copy_boundary_item",
          "args": [
            "dest_bi",
            "src",
            "LAST_TO_FIRST",
            "bytes"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_copy_boundary_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "134-301",
          "snippet": "static int leaf_copy_boundary_item(struct buffer_info *dest_bi,\n\t\t\t\t   struct buffer_head *src, int last_first,\n\t\t\t\t   int bytes_or_entries)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/* number of items in the source and destination buffers */\n\tint dest_nr_item, src_nr_item;\n\tstruct item_head *ih;\n\tstruct item_head *dih;\n\n\tdest_nr_item = B_NR_ITEMS(dest);\n\n\t/*\n\t * if ( DEST is empty or first item of SOURCE and last item of\n\t * DEST are the items of different objects or of different types )\n\t * then there is no need to treat this item differently from the\n\t * other items that we copy, so we return\n\t */\n\tif (last_first == FIRST_TO_LAST) {\n\t\tih = item_head(src, 0);\n\t\tdih = item_head(dest, dest_nr_item - 1);\n\n\t\t/* there is nothing to merge */\n\t\tif (!dest_nr_item\n\t\t    || (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\n\t\t\treturn 0;\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"vs-10010: item can not have empty length\");\n\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (bytes_or_entries == -1)\n\t\t\t\t/* copy all entries to dest */\n\t\t\t\tbytes_or_entries = ih_entry_count(ih);\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\n\t\t\t\t\t      bytes_or_entries);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * copy part of the body of the first item of SOURCE\n\t\t * to the end of the body of the last item of the DEST\n\t\t * part defined by 'bytes_or_entries'; if bytes_or_entries\n\t\t * == -1 copy whole body; don't create new item header\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_item_len(ih);\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\telse {\n\t\t\tif (bytes_or_entries == ih_item_len(ih)\n\t\t\t    && is_indirect_le_ih(ih))\n\t\t\t\tif (get_ih_free_space(ih))\n\t\t\t\t\treiserfs_panic(sb_from_bi(dest_bi),\n\t\t\t\t\t\t       \"vs-10020\",\n\t\t\t\t\t\t       \"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\", ih);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * merge first item (or its part) of src buffer with the last\n\t\t * item of dest buffer. Both are of the same file\n\t\t */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     dest_nr_item - 1, ih_item_len(dih),\n\t\t\t\t     bytes_or_entries, ih_item_body(src, ih), 0);\n\n\t\tif (is_indirect_le_ih(dih)) {\n\t\t\tRFALSE(get_ih_free_space(dih),\n\t\t\t       \"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\",\n\t\t\t       ih);\n\t\t\tif (bytes_or_entries == ih_item_len(ih))\n\t\t\t\tset_ih_free_space(dih, get_ih_free_space(ih));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\t/* copy boundary item to right (last_first == LAST_TO_FIRST) */\n\n\t/*\n\t * (DEST is empty or last item of SOURCE and first item of DEST\n\t * are the items of different object or of different types)\n\t */\n\tsrc_nr_item = B_NR_ITEMS(src);\n\tih = item_head(src, src_nr_item - 1);\n\tdih = item_head(dest, 0);\n\n\tif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\n\t\treturn 0;\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * bytes_or_entries = entries number in last\n\t\t * item body of SOURCE\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_entry_count(ih);\n\n\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t      src_nr_item - 1,\n\t\t\t\t      ih_entry_count(ih) - bytes_or_entries,\n\t\t\t\t      bytes_or_entries);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * copy part of the body of the last item of SOURCE to the\n\t * begin of the body of the first item of the DEST; part defined\n\t * by 'bytes_or_entries'; if byte_or_entriess == -1 copy whole body;\n\t * change first item key of the DEST; don't create new item header\n\t */\n\n\tRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\n\t       \"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\",\n\t       ih);\n\n\tif (bytes_or_entries == -1) {\n\t\t/* bytes_or_entries = length of last item body of SOURCE */\n\t\tbytes_or_entries = ih_item_len(ih);\n\n\t\tRFALSE(le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\n\t\t       \"vs-10050: items %h and %h do not match\", ih, dih);\n\n\t\t/* change first item key of the DEST */\n\t\tset_le_ih_k_offset(dih, le_ih_k_offset(ih));\n\n\t\t/* item becomes non-mergeable */\n\t\t/* or mergeable if left item was */\n\t\tset_le_ih_k_type(dih, le_ih_k_type(ih));\n\t} else {\n\t\t/* merge to right only part of item */\n\t\tRFALSE(ih_item_len(ih) <= bytes_or_entries,\n\t\t       \"vs-10060: no so much bytes %lu (needed %lu)\",\n\t\t       (unsigned long)ih_item_len(ih),\n\t\t       (unsigned long)bytes_or_entries);\n\n\t\t/* change first item key of the DEST */\n\t\tif (is_direct_le_ih(dih)) {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries,\n\t\t\t       \"vs-10070: dih %h, bytes_or_entries(%d)\", dih,\n\t\t\t       bytes_or_entries);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   bytes_or_entries);\n\t\t} else {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\n\t\t\t       \"vs-10080: dih %h, bytes_or_entries(%d)\",\n\t\t\t       dih,\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size));\n\t\t}\n\t}\n\n\tleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\n\t\t\t     ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries,\n\t\t\t     0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_copy_boundary_item(struct buffer_info *dest_bi,\n\t\t\t\t   struct buffer_head *src, int last_first,\n\t\t\t\t   int bytes_or_entries)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/* number of items in the source and destination buffers */\n\tint dest_nr_item, src_nr_item;\n\tstruct item_head *ih;\n\tstruct item_head *dih;\n\n\tdest_nr_item = B_NR_ITEMS(dest);\n\n\t/*\n\t * if ( DEST is empty or first item of SOURCE and last item of\n\t * DEST are the items of different objects or of different types )\n\t * then there is no need to treat this item differently from the\n\t * other items that we copy, so we return\n\t */\n\tif (last_first == FIRST_TO_LAST) {\n\t\tih = item_head(src, 0);\n\t\tdih = item_head(dest, dest_nr_item - 1);\n\n\t\t/* there is nothing to merge */\n\t\tif (!dest_nr_item\n\t\t    || (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\n\t\t\treturn 0;\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"vs-10010: item can not have empty length\");\n\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (bytes_or_entries == -1)\n\t\t\t\t/* copy all entries to dest */\n\t\t\t\tbytes_or_entries = ih_entry_count(ih);\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\n\t\t\t\t\t      bytes_or_entries);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * copy part of the body of the first item of SOURCE\n\t\t * to the end of the body of the last item of the DEST\n\t\t * part defined by 'bytes_or_entries'; if bytes_or_entries\n\t\t * == -1 copy whole body; don't create new item header\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_item_len(ih);\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\telse {\n\t\t\tif (bytes_or_entries == ih_item_len(ih)\n\t\t\t    && is_indirect_le_ih(ih))\n\t\t\t\tif (get_ih_free_space(ih))\n\t\t\t\t\treiserfs_panic(sb_from_bi(dest_bi),\n\t\t\t\t\t\t       \"vs-10020\",\n\t\t\t\t\t\t       \"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\", ih);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * merge first item (or its part) of src buffer with the last\n\t\t * item of dest buffer. Both are of the same file\n\t\t */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     dest_nr_item - 1, ih_item_len(dih),\n\t\t\t\t     bytes_or_entries, ih_item_body(src, ih), 0);\n\n\t\tif (is_indirect_le_ih(dih)) {\n\t\t\tRFALSE(get_ih_free_space(dih),\n\t\t\t       \"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\",\n\t\t\t       ih);\n\t\t\tif (bytes_or_entries == ih_item_len(ih))\n\t\t\t\tset_ih_free_space(dih, get_ih_free_space(ih));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\t/* copy boundary item to right (last_first == LAST_TO_FIRST) */\n\n\t/*\n\t * (DEST is empty or last item of SOURCE and first item of DEST\n\t * are the items of different object or of different types)\n\t */\n\tsrc_nr_item = B_NR_ITEMS(src);\n\tih = item_head(src, src_nr_item - 1);\n\tdih = item_head(dest, 0);\n\n\tif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\n\t\treturn 0;\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * bytes_or_entries = entries number in last\n\t\t * item body of SOURCE\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_entry_count(ih);\n\n\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t      src_nr_item - 1,\n\t\t\t\t      ih_entry_count(ih) - bytes_or_entries,\n\t\t\t\t      bytes_or_entries);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * copy part of the body of the last item of SOURCE to the\n\t * begin of the body of the first item of the DEST; part defined\n\t * by 'bytes_or_entries'; if byte_or_entriess == -1 copy whole body;\n\t * change first item key of the DEST; don't create new item header\n\t */\n\n\tRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\n\t       \"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\",\n\t       ih);\n\n\tif (bytes_or_entries == -1) {\n\t\t/* bytes_or_entries = length of last item body of SOURCE */\n\t\tbytes_or_entries = ih_item_len(ih);\n\n\t\tRFALSE(le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\n\t\t       \"vs-10050: items %h and %h do not match\", ih, dih);\n\n\t\t/* change first item key of the DEST */\n\t\tset_le_ih_k_offset(dih, le_ih_k_offset(ih));\n\n\t\t/* item becomes non-mergeable */\n\t\t/* or mergeable if left item was */\n\t\tset_le_ih_k_type(dih, le_ih_k_type(ih));\n\t} else {\n\t\t/* merge to right only part of item */\n\t\tRFALSE(ih_item_len(ih) <= bytes_or_entries,\n\t\t       \"vs-10060: no so much bytes %lu (needed %lu)\",\n\t\t       (unsigned long)ih_item_len(ih),\n\t\t       (unsigned long)bytes_or_entries);\n\n\t\t/* change first item key of the DEST */\n\t\tif (is_direct_le_ih(dih)) {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries,\n\t\t\t       \"vs-10070: dih %h, bytes_or_entries(%d)\", dih,\n\t\t\t       bytes_or_entries);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   bytes_or_entries);\n\t\t} else {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\n\t\t\t       \"vs-10080: dih %h, bytes_or_entries(%d)\",\n\t\t\t       dih,\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size));\n\t\t}\n\t}\n\n\tleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\n\t\t\t     ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries,\n\t\t\t     0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_num < 0",
            "\"vs-10240: cpy_num < 0 (%d)\"",
            "cpy_num"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_NR_ITEMS(src) < cpy_num",
            "\"vs-10230: No enough items: %d, req. %d\"",
            "B_NR_ITEMS(src)",
            "cpy_num"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST",
            "\"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!dest || !src",
            "\"vs-10210: !dest || !src\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\n\t\t\t   int last_first, int cpy_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest;\n\tint pos, i, src_nr_item, bytes;\n\n\tdest = dest_bi->bi_bh;\n\tRFALSE(!dest || !src, \"vs-10210: !dest || !src\");\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\");\n\tRFALSE(B_NR_ITEMS(src) < cpy_num,\n\t       \"vs-10230: No enough items: %d, req. %d\", B_NR_ITEMS(src),\n\t       cpy_num);\n\tRFALSE(cpy_num < 0, \"vs-10240: cpy_num < 0 (%d)\", cpy_num);\n\n\tif (cpy_num == 0)\n\t\treturn 0;\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/* copy items to left */\n\t\tpos = 0;\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the first item or it part or nothing to the end of\n\t\t * the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes))\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\t\tpos += i;\n\t\tif (cpy_bytes == -1)\n\t\t\t/*\n\t\t\t * copy first cpy_num items starting from position\n\t\t\t * 'pos' of SOURCE to end of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\telse {\n\t\t\t/*\n\t\t\t * copy first cpy_num-1 items starting from position\n\t\t\t * 'pos-1' of the SOURCE to the end of the DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is\n\t\t\t * cpy_num+pos-1 to the end of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t cpy_num + pos - 1, cpy_bytes);\n\t\t}\n\t} else {\n\t\t/* copy items to right */\n\t\tsrc_nr_item = B_NR_ITEMS(src);\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t/*\n\t\t * copy the last item or it part or nothing to the\n\t\t * begin of the DEST\n\t\t * (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes));\n\t\t */\n\t\ti = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\n\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\n\t\tpos = src_nr_item - cpy_num - i;\n\t\tif (cpy_bytes == -1) {\n\t\t\t/*\n\t\t\t * starting from position 'pos' copy last cpy_num\n\t\t\t * items of SOURCE to begin of DEST\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\t} else {\n\t\t\t/*\n\t\t\t * copy last cpy_num-1 items starting from position\n\t\t\t * 'pos+1' of the SOURCE to the begin of the DEST;\n\t\t\t */\n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos + 1, cpy_num - 1);\n\n\t\t\t/*\n\t\t\t * copy part of the item which number is pos to\n\t\t\t * the begin of the DEST\n\t\t\t */\n\t\t\tleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\n\t\t\t\t\t cpy_bytes);\n\t\t}\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "leaf_item_bottle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "414-513",
    "snippet": "static void leaf_item_bottle(struct buffer_info *dest_bi,\n\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t     int item_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tstruct item_head *ih;\n\n\tRFALSE(cpy_bytes == -1,\n\t       \"vs-10170: bytes == - 1 means: do not split item\");\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer SOURCE\n\t\t * is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t      item_num, 0, cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the end of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header; change old\n\t\t\t * item_header (????); n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, IH_SIZE);\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\t\t\tif (is_indirect_le_ih(ih)) {\n\t\t\t\tRFALSE(cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\",\n\t\t\t\t       (long unsigned)get_ih_free_space(ih));\n\t\t\t\tset_ih_free_space(&n_ih, 0);\n\t\t\t}\n\n\t\t\tRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\n\t\t\t       \"vs-10190: bad mergeability of item %h\", ih);\n\t\t\tn_ih.ih_version = ih->ih_version;\t/* JDM Endian safe, both le */\n\t\t\tleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\n\t\t\t\t\t     item_body(src, item_num), 0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer\n\t\t * SOURCE is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t      item_num,\n\t\t\t\t\t      ih_entry_count(ih) - cpy_bytes,\n\t\t\t\t\t      cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the begin of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header;\n\t\t\t * n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, SHORT_KEY_SIZE);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tif (is_direct_le_ih(ih)) {\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   ih_item_len(ih) - cpy_bytes);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_DIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, MAX_US_INT);\n\t\t\t} else {\n\t\t\t\t/* indirect item */\n\t\t\t\tRFALSE(!cpy_bytes && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\");\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, get_ih_free_space(ih));\n\t\t\t}\n\n\t\t\t/* set item length */\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tleaf_insert_into_buf(dest_bi, 0, &n_ih,\n\t\t\t\t\t     item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "dest_bi",
            "0",
            "&n_ih",
            "item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes",
            "0"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_body",
          "args": [
            "src",
            "item_num"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2220-2223",
          "snippet": "static inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "&n_ih",
            "cpy_bytes"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "&n_ih",
            "get_ih_free_space(ih)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_type",
          "args": [
            "&n_ih",
            "TYPE_INDIRECT"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1536-1539",
          "snippet": "static inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "&n_ih",
            "le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!cpy_bytes && get_ih_free_space(ih)",
            "\"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "&n_ih",
            "MAX_US_INT"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&n_ih",
            "ih",
            "SHORT_KEY_SIZE"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_copy_dir_entries",
          "args": [
            "dest_bi",
            "src",
            "LAST_TO_FIRST",
            "item_num",
            "ih_entry_count(ih) - cpy_bytes",
            "cpy_bytes"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_copy_dir_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "15-125",
          "snippet": "static void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "src",
            "item_num"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "op_is_left_mergeable(&ih->ih_key, src->b_size)",
            "\"vs-10190: bad mergeability of item %h\"",
            "ih"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "&ih->ih_key",
            "src->b_size"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "&n_ih",
            "0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih)",
            "\"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\"",
            "(long unsigned)get_ih_free_space(ih)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "&n_ih",
            "cpy_bytes"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&n_ih",
            "ih",
            "IH_SIZE"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_bytes == -1",
            "\"vs-10170: bytes == - 1 means: do not split item\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_item_bottle(struct buffer_info *dest_bi,\n\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t     int item_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tstruct item_head *ih;\n\n\tRFALSE(cpy_bytes == -1,\n\t       \"vs-10170: bytes == - 1 means: do not split item\");\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer SOURCE\n\t\t * is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t      item_num, 0, cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the end of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header; change old\n\t\t\t * item_header (????); n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, IH_SIZE);\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\t\t\tif (is_indirect_le_ih(ih)) {\n\t\t\t\tRFALSE(cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\",\n\t\t\t\t       (long unsigned)get_ih_free_space(ih));\n\t\t\t\tset_ih_free_space(&n_ih, 0);\n\t\t\t}\n\n\t\t\tRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\n\t\t\t       \"vs-10190: bad mergeability of item %h\", ih);\n\t\t\tn_ih.ih_version = ih->ih_version;\t/* JDM Endian safe, both le */\n\t\t\tleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\n\t\t\t\t\t     item_body(src, item_num), 0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * if ( if item in position item_num in buffer\n\t\t * SOURCE is directory item )\n\t\t */\n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t      item_num,\n\t\t\t\t\t      ih_entry_count(ih) - cpy_bytes,\n\t\t\t\t\t      cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t/*\n\t\t\t * copy part of the body of the item number 'item_num'\n\t\t\t * of SOURCE to the begin of the DEST part defined by\n\t\t\t * 'cpy_bytes'; create new item header;\n\t\t\t * n_ih = new item_header;\n\t\t\t */\n\t\t\tmemcpy(&n_ih, ih, SHORT_KEY_SIZE);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tif (is_direct_le_ih(ih)) {\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   ih_item_len(ih) - cpy_bytes);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_DIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, MAX_US_INT);\n\t\t\t} else {\n\t\t\t\t/* indirect item */\n\t\t\t\tRFALSE(!cpy_bytes && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\");\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, get_ih_free_space(ih));\n\t\t\t}\n\n\t\t\t/* set item length */\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\n\t\t\t/* Endian safe, both le */\n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tleaf_insert_into_buf(dest_bi, 0, &n_ih,\n\t\t\t\t\t     item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "leaf_copy_items_entirely",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "310-408",
    "snippet": "static void leaf_copy_items_entirely(struct buffer_info *dest_bi,\n\t\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t\t     int first, int cpy_num)\n{\n\tstruct buffer_head *dest;\n\tint nr, free_space;\n\tint dest_before;\n\tint last_loc, last_inserted_loc, location;\n\tint i, j;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\n\t       \"vs-10090: bad last_first parameter %d\", last_first);\n\tRFALSE(B_NR_ITEMS(src) - first < cpy_num,\n\t       \"vs-10100: too few items in source %d, required %d from %d\",\n\t       B_NR_ITEMS(src), cpy_num, first);\n\tRFALSE(cpy_num < 0, \"vs-10110: can not copy negative amount of items\");\n\tRFALSE(!dest_bi, \"vs-10120: can not copy negative amount of items\");\n\n\tdest = dest_bi->bi_bh;\n\n\tRFALSE(!dest, \"vs-10130: can not copy negative amount of items\");\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/*\n\t * we will insert items before 0-th or nr-th item in dest buffer.\n\t * It depends of last_first parameter\n\t */\n\tdest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\n\n\t/* location of head of first new item */\n\tih = item_head(dest, dest_before);\n\n\tRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\n\t       \"vs-10140: not enough free space for headers %d (needed %d)\",\n\t       B_FREE_SPACE(dest), cpy_num * IH_SIZE);\n\n\t/* prepare space for headers */\n\tmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\n\n\t/* copy item headers */\n\tmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\n\n\tfree_space -= (IH_SIZE * cpy_num);\n\tset_blkh_free_space(blkh, free_space);\n\n\t/* location of unmovable item */\n\tj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\n\tfor (i = dest_before; i < nr + cpy_num; i++) {\n\t\tlocation -= ih_item_len(ih + i - dest_before);\n\t\tput_ih_location(ih + i - dest_before, location);\n\t}\n\n\t/* prepare space for items */\n\tlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\n\tlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\n\n\t/* check free space */\n\tRFALSE(free_space < j - last_inserted_loc,\n\t       \"vs-10150: not enough free space for items %d (needed %d)\",\n\t       free_space, j - last_inserted_loc);\n\n\tmemmove(dest->b_data + last_loc,\n\t\tdest->b_data + last_loc + j - last_inserted_loc,\n\t\tlast_inserted_loc - last_loc);\n\n\t/* copy items */\n\tmemcpy(dest->b_data + last_inserted_loc,\n\t       item_body(src, (first + cpy_num - 1)),\n\t       j - last_inserted_loc);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, nr + cpy_num);\n\tset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\n\n\tdo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\n\t\t       \"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\",\n\t\t       (long unsigned)dest->b_blocknr,\n\t\t       (long unsigned)dc_block_number(t_dc));\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "dest_bi->tb",
            "dest_bi->bi_parent",
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dc_block_number(t_dc) != dest->b_blocknr",
            "\"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\"",
            "(long unsigned)dest->b_blocknr",
            "(long unsigned)dc_block_number(t_dc)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_block_number",
          "args": [
            "t_dc"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_block_number",
          "args": [
            "t_dc"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "dest_bi->bi_parent",
            "dest_bi->bi_position"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_leaf_dirty",
          "args": [
            "dest_bi->tb",
            "dest",
            "0"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_mark_leaf_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "56-60",
          "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "free_space - (j - last_inserted_loc)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "nr + cpy_num"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->b_data + last_inserted_loc",
            "item_body(src, (first + cpy_num - 1))",
            "j - last_inserted_loc"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_body",
          "args": [
            "src",
            "(first + cpy_num - 1)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2220-2223",
          "snippet": "static inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dest->b_data + last_loc",
            "dest->b_data + last_loc + j - last_inserted_loc",
            "last_inserted_loc - last_loc"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "free_space < j - last_inserted_loc",
            "\"vs-10150: not enough free space for items %d (needed %d)\"",
            "free_space",
            "j - last_inserted_loc"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[cpy_num - 1]"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "&ih[nr + cpy_num - 1 - dest_before]"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_location",
          "args": [
            "ih + i - dest_before",
            "location"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih + i - dest_before"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih - 1"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "free_space"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ih",
            "item_head(src, first)",
            "cpy_num * IH_SIZE"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "src",
            "first"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ih + cpy_num",
            "ih",
            "(nr - dest_before) * IH_SIZE"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "blkh_free_space(blkh) < cpy_num * IH_SIZE",
            "\"vs-10140: not enough free space for headers %d (needed %d)\"",
            "B_FREE_SPACE(dest)",
            "cpy_num * IH_SIZE"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "dest"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "dest"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!dest",
            "\"vs-10130: can not copy negative amount of items\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!dest_bi",
            "\"vs-10120: can not copy negative amount of items\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_num < 0",
            "\"vs-10110: can not copy negative amount of items\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_NR_ITEMS(src) - first < cpy_num",
            "\"vs-10100: too few items in source %d, required %d from %d\"",
            "B_NR_ITEMS(src)",
            "cpy_num",
            "first"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST",
            "\"vs-10090: bad last_first parameter %d\"",
            "last_first"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_copy_items_entirely(struct buffer_info *dest_bi,\n\t\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t\t     int first, int cpy_num)\n{\n\tstruct buffer_head *dest;\n\tint nr, free_space;\n\tint dest_before;\n\tint last_loc, last_inserted_loc, location;\n\tint i, j;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\n\t       \"vs-10090: bad last_first parameter %d\", last_first);\n\tRFALSE(B_NR_ITEMS(src) - first < cpy_num,\n\t       \"vs-10100: too few items in source %d, required %d from %d\",\n\t       B_NR_ITEMS(src), cpy_num, first);\n\tRFALSE(cpy_num < 0, \"vs-10110: can not copy negative amount of items\");\n\tRFALSE(!dest_bi, \"vs-10120: can not copy negative amount of items\");\n\n\tdest = dest_bi->bi_bh;\n\n\tRFALSE(!dest, \"vs-10130: can not copy negative amount of items\");\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/*\n\t * we will insert items before 0-th or nr-th item in dest buffer.\n\t * It depends of last_first parameter\n\t */\n\tdest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\n\n\t/* location of head of first new item */\n\tih = item_head(dest, dest_before);\n\n\tRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\n\t       \"vs-10140: not enough free space for headers %d (needed %d)\",\n\t       B_FREE_SPACE(dest), cpy_num * IH_SIZE);\n\n\t/* prepare space for headers */\n\tmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\n\n\t/* copy item headers */\n\tmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\n\n\tfree_space -= (IH_SIZE * cpy_num);\n\tset_blkh_free_space(blkh, free_space);\n\n\t/* location of unmovable item */\n\tj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\n\tfor (i = dest_before; i < nr + cpy_num; i++) {\n\t\tlocation -= ih_item_len(ih + i - dest_before);\n\t\tput_ih_location(ih + i - dest_before, location);\n\t}\n\n\t/* prepare space for items */\n\tlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\n\tlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\n\n\t/* check free space */\n\tRFALSE(free_space < j - last_inserted_loc,\n\t       \"vs-10150: not enough free space for items %d (needed %d)\",\n\t       free_space, j - last_inserted_loc);\n\n\tmemmove(dest->b_data + last_loc,\n\t\tdest->b_data + last_loc + j - last_inserted_loc,\n\t\tlast_inserted_loc - last_loc);\n\n\t/* copy items */\n\tmemcpy(dest->b_data + last_inserted_loc,\n\t       item_body(src, (first + cpy_num - 1)),\n\t       j - last_inserted_loc);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, nr + cpy_num);\n\tset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\n\n\tdo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\n\t\t       \"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\",\n\t\t       (long unsigned)dest->b_blocknr,\n\t\t       (long unsigned)dc_block_number(t_dc));\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
  },
  {
    "function_name": "leaf_copy_boundary_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "134-301",
    "snippet": "static int leaf_copy_boundary_item(struct buffer_info *dest_bi,\n\t\t\t\t   struct buffer_head *src, int last_first,\n\t\t\t\t   int bytes_or_entries)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/* number of items in the source and destination buffers */\n\tint dest_nr_item, src_nr_item;\n\tstruct item_head *ih;\n\tstruct item_head *dih;\n\n\tdest_nr_item = B_NR_ITEMS(dest);\n\n\t/*\n\t * if ( DEST is empty or first item of SOURCE and last item of\n\t * DEST are the items of different objects or of different types )\n\t * then there is no need to treat this item differently from the\n\t * other items that we copy, so we return\n\t */\n\tif (last_first == FIRST_TO_LAST) {\n\t\tih = item_head(src, 0);\n\t\tdih = item_head(dest, dest_nr_item - 1);\n\n\t\t/* there is nothing to merge */\n\t\tif (!dest_nr_item\n\t\t    || (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\n\t\t\treturn 0;\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"vs-10010: item can not have empty length\");\n\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (bytes_or_entries == -1)\n\t\t\t\t/* copy all entries to dest */\n\t\t\t\tbytes_or_entries = ih_entry_count(ih);\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\n\t\t\t\t\t      bytes_or_entries);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * copy part of the body of the first item of SOURCE\n\t\t * to the end of the body of the last item of the DEST\n\t\t * part defined by 'bytes_or_entries'; if bytes_or_entries\n\t\t * == -1 copy whole body; don't create new item header\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_item_len(ih);\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\telse {\n\t\t\tif (bytes_or_entries == ih_item_len(ih)\n\t\t\t    && is_indirect_le_ih(ih))\n\t\t\t\tif (get_ih_free_space(ih))\n\t\t\t\t\treiserfs_panic(sb_from_bi(dest_bi),\n\t\t\t\t\t\t       \"vs-10020\",\n\t\t\t\t\t\t       \"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\", ih);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * merge first item (or its part) of src buffer with the last\n\t\t * item of dest buffer. Both are of the same file\n\t\t */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     dest_nr_item - 1, ih_item_len(dih),\n\t\t\t\t     bytes_or_entries, ih_item_body(src, ih), 0);\n\n\t\tif (is_indirect_le_ih(dih)) {\n\t\t\tRFALSE(get_ih_free_space(dih),\n\t\t\t       \"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\",\n\t\t\t       ih);\n\t\t\tif (bytes_or_entries == ih_item_len(ih))\n\t\t\t\tset_ih_free_space(dih, get_ih_free_space(ih));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\t/* copy boundary item to right (last_first == LAST_TO_FIRST) */\n\n\t/*\n\t * (DEST is empty or last item of SOURCE and first item of DEST\n\t * are the items of different object or of different types)\n\t */\n\tsrc_nr_item = B_NR_ITEMS(src);\n\tih = item_head(src, src_nr_item - 1);\n\tdih = item_head(dest, 0);\n\n\tif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\n\t\treturn 0;\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * bytes_or_entries = entries number in last\n\t\t * item body of SOURCE\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_entry_count(ih);\n\n\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t      src_nr_item - 1,\n\t\t\t\t      ih_entry_count(ih) - bytes_or_entries,\n\t\t\t\t      bytes_or_entries);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * copy part of the body of the last item of SOURCE to the\n\t * begin of the body of the first item of the DEST; part defined\n\t * by 'bytes_or_entries'; if byte_or_entriess == -1 copy whole body;\n\t * change first item key of the DEST; don't create new item header\n\t */\n\n\tRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\n\t       \"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\",\n\t       ih);\n\n\tif (bytes_or_entries == -1) {\n\t\t/* bytes_or_entries = length of last item body of SOURCE */\n\t\tbytes_or_entries = ih_item_len(ih);\n\n\t\tRFALSE(le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\n\t\t       \"vs-10050: items %h and %h do not match\", ih, dih);\n\n\t\t/* change first item key of the DEST */\n\t\tset_le_ih_k_offset(dih, le_ih_k_offset(ih));\n\n\t\t/* item becomes non-mergeable */\n\t\t/* or mergeable if left item was */\n\t\tset_le_ih_k_type(dih, le_ih_k_type(ih));\n\t} else {\n\t\t/* merge to right only part of item */\n\t\tRFALSE(ih_item_len(ih) <= bytes_or_entries,\n\t\t       \"vs-10060: no so much bytes %lu (needed %lu)\",\n\t\t       (unsigned long)ih_item_len(ih),\n\t\t       (unsigned long)bytes_or_entries);\n\n\t\t/* change first item key of the DEST */\n\t\tif (is_direct_le_ih(dih)) {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries,\n\t\t\t       \"vs-10070: dih %h, bytes_or_entries(%d)\", dih,\n\t\t\t       bytes_or_entries);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   bytes_or_entries);\n\t\t} else {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\n\t\t\t       \"vs-10080: dih %h, bytes_or_entries(%d)\",\n\t\t\t       dih,\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size));\n\t\t}\n\t}\n\n\tleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\n\t\t\t     ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries,\n\t\t\t     0);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "dest_bi",
            "0",
            "0",
            "bytes_or_entries",
            "ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries",
            "0"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "src",
            "ih"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "dih",
            "le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size)"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "dih"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size",
            "\"vs-10080: dih %h, bytes_or_entries(%d)\"",
            "dih",
            "(bytes_or_entries / UNFM_P_SIZE) * dest->b_size"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries",
            "\"vs-10070: dih %h, bytes_or_entries(%d)\"",
            "dih",
            "bytes_or_entries"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "dih"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(ih) <= bytes_or_entries",
            "\"vs-10060: no so much bytes %lu (needed %lu)\"",
            "(unsigned long)ih_item_len(ih)",
            "(unsigned long)bytes_or_entries"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_type",
          "args": [
            "dih",
            "le_ih_k_type(ih)"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1536-1539",
          "snippet": "static inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_type",
          "args": [
            "ih"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1495-1498",
          "snippet": "static inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size)",
            "\"vs-10050: items %h and %h do not match\"",
            "ih",
            "dih"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "ih",
            "src->b_size"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "is_indirect_le_ih(ih) && get_ih_free_space(ih)",
            "\"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\"",
            "ih"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_copy_dir_entries",
          "args": [
            "dest_bi",
            "src",
            "LAST_TO_FIRST",
            "src_nr_item - 1",
            "ih_entry_count(ih) - bytes_or_entries",
            "bytes_or_entries"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_copy_dir_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "15-125",
          "snippet": "static void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "&dih->ih_key",
            "src->b_size"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "dest",
            "0"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "dih",
            "get_ih_free_space(ih)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "get_ih_free_space(dih)",
            "\"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\"",
            "ih"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "dih"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "dih"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb_from_bi(dest_bi)",
            "\"vs-10020\"",
            "\"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\"",
            "ih"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_from_bi",
          "args": [
            "dest_bi"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sb_from_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2602-2605",
          "snippet": "static inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void store_print_tb(struct tree_balance *tb);",
            "void make_empty_node(struct buffer_info *);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid store_print_tb(struct tree_balance *tb);\nvoid make_empty_node(struct buffer_info *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "ih"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!ih_item_len(ih)",
            "\"vs-10010: item can not have empty length\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "&ih->ih_key",
            "src->b_size"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic int leaf_copy_boundary_item(struct buffer_info *dest_bi,\n\t\t\t\t   struct buffer_head *src, int last_first,\n\t\t\t\t   int bytes_or_entries)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/* number of items in the source and destination buffers */\n\tint dest_nr_item, src_nr_item;\n\tstruct item_head *ih;\n\tstruct item_head *dih;\n\n\tdest_nr_item = B_NR_ITEMS(dest);\n\n\t/*\n\t * if ( DEST is empty or first item of SOURCE and last item of\n\t * DEST are the items of different objects or of different types )\n\t * then there is no need to treat this item differently from the\n\t * other items that we copy, so we return\n\t */\n\tif (last_first == FIRST_TO_LAST) {\n\t\tih = item_head(src, 0);\n\t\tdih = item_head(dest, dest_nr_item - 1);\n\n\t\t/* there is nothing to merge */\n\t\tif (!dest_nr_item\n\t\t    || (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\n\t\t\treturn 0;\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"vs-10010: item can not have empty length\");\n\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (bytes_or_entries == -1)\n\t\t\t\t/* copy all entries to dest */\n\t\t\t\tbytes_or_entries = ih_entry_count(ih);\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\n\t\t\t\t\t      bytes_or_entries);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * copy part of the body of the first item of SOURCE\n\t\t * to the end of the body of the last item of the DEST\n\t\t * part defined by 'bytes_or_entries'; if bytes_or_entries\n\t\t * == -1 copy whole body; don't create new item header\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_item_len(ih);\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\telse {\n\t\t\tif (bytes_or_entries == ih_item_len(ih)\n\t\t\t    && is_indirect_le_ih(ih))\n\t\t\t\tif (get_ih_free_space(ih))\n\t\t\t\t\treiserfs_panic(sb_from_bi(dest_bi),\n\t\t\t\t\t\t       \"vs-10020\",\n\t\t\t\t\t\t       \"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\", ih);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * merge first item (or its part) of src buffer with the last\n\t\t * item of dest buffer. Both are of the same file\n\t\t */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     dest_nr_item - 1, ih_item_len(dih),\n\t\t\t\t     bytes_or_entries, ih_item_body(src, ih), 0);\n\n\t\tif (is_indirect_le_ih(dih)) {\n\t\t\tRFALSE(get_ih_free_space(dih),\n\t\t\t       \"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\",\n\t\t\t       ih);\n\t\t\tif (bytes_or_entries == ih_item_len(ih))\n\t\t\t\tset_ih_free_space(dih, get_ih_free_space(ih));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\t/* copy boundary item to right (last_first == LAST_TO_FIRST) */\n\n\t/*\n\t * (DEST is empty or last item of SOURCE and first item of DEST\n\t * are the items of different object or of different types)\n\t */\n\tsrc_nr_item = B_NR_ITEMS(src);\n\tih = item_head(src, src_nr_item - 1);\n\tdih = item_head(dest, 0);\n\n\tif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\n\t\treturn 0;\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * bytes_or_entries = entries number in last\n\t\t * item body of SOURCE\n\t\t */\n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_entry_count(ih);\n\n\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t      src_nr_item - 1,\n\t\t\t\t      ih_entry_count(ih) - bytes_or_entries,\n\t\t\t\t      bytes_or_entries);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * copy part of the body of the last item of SOURCE to the\n\t * begin of the body of the first item of the DEST; part defined\n\t * by 'bytes_or_entries'; if byte_or_entriess == -1 copy whole body;\n\t * change first item key of the DEST; don't create new item header\n\t */\n\n\tRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\n\t       \"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\",\n\t       ih);\n\n\tif (bytes_or_entries == -1) {\n\t\t/* bytes_or_entries = length of last item body of SOURCE */\n\t\tbytes_or_entries = ih_item_len(ih);\n\n\t\tRFALSE(le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\n\t\t       \"vs-10050: items %h and %h do not match\", ih, dih);\n\n\t\t/* change first item key of the DEST */\n\t\tset_le_ih_k_offset(dih, le_ih_k_offset(ih));\n\n\t\t/* item becomes non-mergeable */\n\t\t/* or mergeable if left item was */\n\t\tset_le_ih_k_type(dih, le_ih_k_type(ih));\n\t} else {\n\t\t/* merge to right only part of item */\n\t\tRFALSE(ih_item_len(ih) <= bytes_or_entries,\n\t\t       \"vs-10060: no so much bytes %lu (needed %lu)\",\n\t\t       (unsigned long)ih_item_len(ih),\n\t\t       (unsigned long)bytes_or_entries);\n\n\t\t/* change first item key of the DEST */\n\t\tif (is_direct_le_ih(dih)) {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries,\n\t\t\t       \"vs-10070: dih %h, bytes_or_entries(%d)\", dih,\n\t\t\t       bytes_or_entries);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   bytes_or_entries);\n\t\t} else {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\n\t\t\t       \"vs-10080: dih %h, bytes_or_entries(%d)\",\n\t\t\t       dih,\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size));\n\t\t}\n\t}\n\n\tleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\n\t\t\t     ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries,\n\t\t\t     0);\n\treturn 1;\n}"
  },
  {
    "function_name": "leaf_copy_dir_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
    "lines": "15-125",
    "snippet": "static void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "dest_bi",
            "item_num_in_dest",
            "(last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0",
            "copy_count",
            "deh + from",
            "records",
            "DEH_SIZE * copy_count + copy_records_len"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "dest",
            "item_num_in_dest"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "dest_bi",
            "(last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0",
            "MAX_US_INT",
            "DEH_SIZE * copy_count + copy_records_len",
            "records",
            "0"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "dest_bi",
            "(last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest)",
            "&new_ih",
            "NULL",
            "0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_key_k_type",
          "args": [
            "KEY_FORMAT_3_5",
            "&new_ih.ih_key",
            "TYPE_DIRENTRY"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1526-1534",
          "snippet": "static inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "&new_ih",
            "U32_MAX"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "&deh[from]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_entry_count",
          "args": [
            "&new_ih",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "&new_ih",
            "DEH_SIZE * copy_count + copy_records_len"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_version",
          "args": [
            "&new_ih",
            "KEY_FORMAT_3_5"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_ih.ih_key",
            "&ih->ih_key",
            "KEY_SIZE"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_short_le_keys",
          "args": [
            "&ih->ih_key",
            "leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_le_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "97-112",
          "snippet": "inline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "dest",
            "item_num_in_dest"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[from + copy_count - 1]"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[from + copy_count - 1]"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "&deh[from - 1]"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "source",
            "ih"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!is_direntry_le_ih(ih)",
            "\"vs-10000: item must be directory item\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t/*\n\t * either the number of target item, or if we must create a\n\t * new item, the number of the item we will create it next to\n\t */\n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t/* length of all records in item to be copied */\n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t/*\n\t * length of all record to be copied and first byte of\n\t * the last of them\n\t */\n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t/* when copy last to first, dest buffer can contain 0 items */\n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t/*\n\t * if there are no items in dest or the first/last item in\n\t * dest is not item of the same directory\n\t */\n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys /*COMP_SHORT_KEYS */ (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t/* create new item in dest */\n\t\tstruct item_head new_ih;\n\n\t\t/* form item header */\n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t/* calculate item len */\n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t/* form key by the following way */\n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * no entries will be copied to this\n\t\t\t\t * item in this function\n\t\t\t\t */\n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t/*\n\t\t\t\t * this item is not yet valid, but we\n\t\t\t\t * want I_IS_DIRECTORY_ITEM to return 1\n\t\t\t\t * for it, so we -1\n\t\t\t\t */\n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t/* insert item into dest buffer */\n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t/* prepare space for entries */\n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}"
  }
]