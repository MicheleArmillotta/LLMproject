[
  {
    "function_name": "ocfs2_mv_orphaned_inode_to_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2760-2899",
    "snippet": "int ocfs2_mv_orphaned_inode_to_new(struct inode *dir,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_di_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *dir_di, *di;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_mv_orphaned_inode_to_new(dir, dentry,\n\t\t\t\tdentry->d_name.len, dentry->d_name.name,\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdir_di = (struct ocfs2_dinode *) parent_di_bh->b_data;\n\tif (!dir_di->i_links_count) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_di_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t  orphan_dir_bh, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_ORPHANED_FL);\n\tdi->i_orphaned_slot = 0;\n\tset_nlink(inode, 1);\n\tocfs2_set_links_count(di, inode->i_nlink);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_di_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nout_commit:\n\tocfs2_commit_trans(osb, handle);\norphan_unlock:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\nleave:\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(di_bh);\n\tbrelse(parent_di_bh);\n\tbrelse(orphan_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "orphan_dir_bh"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "1"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode",
            "OCFS2_I(inode)->ip_blkno",
            "parent_di_bh",
            "&lookup"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
          "lines": "69-78",
          "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "di",
            "inode->i_nlink"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_ORPHANED_FL"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_del",
          "args": [
            "osb",
            "handle",
            "orphan_dir_inode",
            "inode",
            "orphan_dir_bh",
            "false"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2292-2364",
          "snippet": "int ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nint ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_rename_credits(osb->sb)"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rename_credits",
          "args": [
            "osb->sb"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rename_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "483-486",
          "snippet": "static inline int ocfs2_rename_credits(struct super_block *sb)\n{\n\treturn 3 * OCFS2_INODE_UPDATE_CREDITS + 6 + ocfs2_unlink_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_rename_credits(struct super_block *sb)\n{\n\treturn 3 * OCFS2_INODE_UPDATE_CREDITS + 6 + ocfs2_unlink_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "orphan_dir_inode",
            "&orphan_dir_bh",
            "1"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ORPHAN_DIR_SYSTEM_INODE",
            "osb->slot_num"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "dir",
            "parent_di_bh",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&lookup"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_for_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2046-2067",
          "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mv_orphaned_inode_to_new",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mv_orphaned_inode_to_new(struct inode *dir,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_di_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *dir_di, *di;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_mv_orphaned_inode_to_new(dir, dentry,\n\t\t\t\tdentry->d_name.len, dentry->d_name.name,\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdir_di = (struct ocfs2_dinode *) parent_di_bh->b_data;\n\tif (!dir_di->i_links_count) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_di_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t  orphan_dir_bh, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_ORPHANED_FL);\n\tdi->i_orphaned_slot = 0;\n\tset_nlink(inode, 1);\n\tocfs2_set_links_count(di, inode->i_nlink);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_di_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nout_commit:\n\tocfs2_commit_trans(osb, handle);\norphan_unlock:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\nleave:\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(di_bh);\n\tbrelse(parent_di_bh);\n\tbrelse(orphan_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_del_inode_from_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2672-2758",
    "snippet": "int ocfs2_del_inode_from_orphan(struct ocfs2_super *osb,\n\t\tstruct inode *inode, int update_isize,\n\t\tloff_t end)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\tORPHAN_DIR_SYSTEM_INODE,\n\t\t\tle16_to_cpu(di->i_dio_orphaned_slot));\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_DEL_FROM_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tBUG_ON(!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)));\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode,\n\t\t\t\tinode, orphan_dir_bh, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(inode),\n\t\t\tdi_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\tdi->i_dio_orphaned_slot = 0;\n\n\tif (update_isize) {\n\t\tstatus = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\t} else\n\t\tocfs2_journal_dirty(handle, di_bh);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\n\tiput(orphan_dir_inode);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_size",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "end"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "298-317",
          "snippet": "int ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DIO_ORPHANED_FL"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_del",
          "args": [
            "osb",
            "handle",
            "orphan_dir_inode",
            "inode",
            "orphan_dir_bh",
            "true"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2292-2364",
          "snippet": "int ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nint ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL))"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DIO_ORPHANED_FL"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_DEL_FROM_ORPHAN_CREDITS"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "orphan_dir_inode",
            "&orphan_dir_bh",
            "1"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ORPHAN_DIR_SYSTEM_INODE",
            "le16_to_cpu(di->i_dio_orphaned_slot)"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_dio_orphaned_slot"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_del_inode_from_orphan(struct ocfs2_super *osb,\n\t\tstruct inode *inode, int update_isize,\n\t\tloff_t end)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\tORPHAN_DIR_SYSTEM_INODE,\n\t\t\tle16_to_cpu(di->i_dio_orphaned_slot));\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_DEL_FROM_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tBUG_ON(!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)));\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode,\n\t\t\t\tinode, orphan_dir_bh, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(inode),\n\t\t\tdi_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\tdi->i_dio_orphaned_slot = 0;\n\n\tif (update_isize) {\n\t\tstatus = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\t} else\n\t\tocfs2_journal_dirty(handle, di_bh);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\n\tiput(orphan_dir_inode);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_add_inode_to_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2601-2670",
    "snippet": "int ocfs2_add_inode_to_orphan(struct ocfs2_super *osb,\n\tstruct inode *inode)\n{\n\tchar orphan_name[OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct buffer_head *di_bh = NULL;\n\tint status = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\nrestart:\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\t/*\n\t * Another append dio crashed?\n\t * If so, wait for recovery first.\n\t */\n\tif (unlikely(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL))) {\n\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(di_bh);\n\t\twait_event_interruptible_timeout(OCFS2_I(inode)->append_dio_wq,\n\t\t\t\tocfs2_dio_orphan_recovered(inode),\n\t\t\t\tmsecs_to_jiffies(OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL));\n\t\tgoto restart;\n\t}\n\n\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir_inode,\n\t\t\tOCFS2_I(inode)->ip_blkno,\n\t\t\torphan_name,\n\t\t\t&orphan_insert,\n\t\t\ttrue);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_ADD_TO_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tstatus = ocfs2_orphan_add(osb, handle, inode, di_bh, orphan_name,\n\t\t\t&orphan_insert, orphan_dir_inode, true);\n\tif (status)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL 10000",
      "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
      "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&orphan_insert"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_add",
          "args": [
            "osb",
            "handle",
            "inode",
            "di_bh",
            "orphan_name",
            "&orphan_insert",
            "orphan_dir_inode",
            "true"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2190-2289",
          "snippet": "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_ADD_TO_ORPHAN_CREDITS"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_orphan_dir",
          "args": [
            "osb",
            "&orphan_dir_inode",
            "OCFS2_I(inode)->ip_blkno",
            "orphan_name",
            "&orphan_insert",
            "true"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2149-2188",
          "snippet": "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "OCFS2_I(inode)->append_dio_wq",
            "ocfs2_dio_orphan_recovered(inode)",
            "msecs_to_jiffies(OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL)"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dio_orphan_recovered",
          "args": [
            "inode"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dio_orphan_recovered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2580-2598",
          "snippet": "static int ocfs2_dio_orphan_recovered(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn 0;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tret = !(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL));\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dio_orphan_recovered(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn 0;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tret = !(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL));\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DIO_ORPHANED_FL"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL 10000\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nint ocfs2_add_inode_to_orphan(struct ocfs2_super *osb,\n\tstruct inode *inode)\n{\n\tchar orphan_name[OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct buffer_head *di_bh = NULL;\n\tint status = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\nrestart:\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\t/*\n\t * Another append dio crashed?\n\t * If so, wait for recovery first.\n\t */\n\tif (unlikely(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL))) {\n\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(di_bh);\n\t\twait_event_interruptible_timeout(OCFS2_I(inode)->append_dio_wq,\n\t\t\t\tocfs2_dio_orphan_recovered(inode),\n\t\t\t\tmsecs_to_jiffies(OCFS2_DIO_ORPHANED_FL_CHECK_INTERVAL));\n\t\tgoto restart;\n\t}\n\n\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir_inode,\n\t\t\tOCFS2_I(inode)->ip_blkno,\n\t\t\torphan_name,\n\t\t\t&orphan_insert,\n\t\t\ttrue);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_ADD_TO_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tstatus = ocfs2_orphan_add(osb, handle, inode, di_bh, orphan_name,\n\t\t\t&orphan_insert, orphan_dir_inode, true);\n\tif (status)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_dio_orphan_recovered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2580-2598",
    "snippet": "static int ocfs2_dio_orphan_recovered(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn 0;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tret = !(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL));\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DIO_ORPHANED_FL"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dio_orphan_recovered(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn 0;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tret = !(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL));\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_inode_in_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2460-2578",
    "snippet": "int ocfs2_create_inode_in_orphan(struct inode *dir,\n\t\t\t\t int mode,\n\t\t\t\t struct inode **new_inode)\n{\n\tint status, did_quota_inode = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *parent_di_bh = NULL;\n\tstruct buffer_head *new_di_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tu64 uninitialized_var(di_blkno), suballoc_loc;\n\tu16 suballoc_bit;\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_prep_new_orphaned_file(dir, parent_di_bh,\n\t\t\t\t\t      orphan_name, &orphan_dir,\n\t\t\t\t\t      &di_blkno, &orphan_insert, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb, 0, 0));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\tstatus = ocfs2_claim_new_inode_at_loc(handle, dir, inode_ac,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit, di_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tclear_nlink(inode);\n\t/* do the real work now. */\n\tstatus = __ocfs2_mknod_locked(dir, inode,\n\t\t\t\t      0, &new_di_bh, parent_di_bh, handle,\n\t\t\t\t      inode_ac, di_blkno, suballoc_loc,\n\t\t\t\t      suballoc_bit);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdi = (struct ocfs2_dinode *)new_di_bh->b_data;\n\tstatus = ocfs2_orphan_add(osb, handle, inode, new_di_bh, orphan_name,\n\t\t\t\t  &orphan_insert, orphan_dir, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get open lock so that only nodes can't remove it from orphan dir. */\n\tstatus = ocfs2_open_lock(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tinsert_inode_hash(inode);\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif ((status < 0) && inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tbrelse(new_di_bh);\n\n\tif (!status)\n\t\t*new_inode = inode;\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\n\tocfs2_inode_unlock(dir, 1);\n\tbrelse(parent_di_bh);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "parent_di_bh"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "1"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&orphan_insert"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "inode_ac"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir->i_mutex"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_open_lock",
          "args": [
            "inode"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_open_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1709-1732",
          "snippet": "int ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_add",
          "args": [
            "osb",
            "handle",
            "inode",
            "new_di_bh",
            "orphan_name",
            "&orphan_insert",
            "orphan_dir",
            "false"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2190-2289",
          "snippet": "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_mknod_locked",
          "args": [
            "dir",
            "inode",
            "0",
            "&new_di_bh",
            "parent_di_bh",
            "handle",
            "inode_ac",
            "di_blkno",
            "suballoc_loc",
            "suballoc_bit"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_mknod_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "516-626",
          "snippet": "static int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_new_inode_at_loc",
          "args": [
            "handle",
            "dir",
            "inode_ac",
            "&suballoc_loc",
            "&suballoc_bit",
            "di_blkno"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_new_inode_at_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2127-2196",
          "snippet": "int ocfs2_claim_new_inode_at_loc(handle_t *handle,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u64 *suballoc_loc,\n\t\t\t\t u16 *suballoc_bit,\n\t\t\t\t u64 di_blkno)\n{\n\tint ret;\n\tu16 chain;\n\tstruct ocfs2_suballoc_result *res = ac->ac_find_loc_priv;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/*\n\t * Since di_blkno is being passed back in, we check for any\n\t * inconsistencies which may have happened between\n\t * calls. These are code bugs as di_blkno is not expected to\n\t * change once returned from ocfs2_find_new_inode_loc()\n\t */\n\tBUG_ON(res->sr_blkno != di_blkno);\n\n\tret = ocfs2_read_group_descriptor(ac->ac_inode, di,\n\t\t\t\t\t  res->sr_bg_stable_blkno, &bg_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tchain = le16_to_cpu(bg->bg_chain);\n\n\tret = ocfs2_alloc_dinode_update_counts(ac->ac_inode, handle,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits,\n\t\t\t\t\t       chain);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t ac->ac_inode,\n\t\t\t\t\t bg,\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t res->sr_bit_offset,\n\t\t\t\t\t res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(ac->ac_inode,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_claim_new_inode_at_loc((unsigned long long)di_blkno,\n\t\t\t\t\t   res->sr_bits);\n\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res->sr_bits != 1);\n\n\t*suballoc_loc = res->sr_bg_blkno;\n\t*suballoc_bit = res->sr_bit_offset;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\nout:\n\tbrelse(bg_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_new_inode_at_loc(handle_t *handle,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u64 *suballoc_loc,\n\t\t\t\t u16 *suballoc_bit,\n\t\t\t\t u64 di_blkno)\n{\n\tint ret;\n\tu16 chain;\n\tstruct ocfs2_suballoc_result *res = ac->ac_find_loc_priv;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/*\n\t * Since di_blkno is being passed back in, we check for any\n\t * inconsistencies which may have happened between\n\t * calls. These are code bugs as di_blkno is not expected to\n\t * change once returned from ocfs2_find_new_inode_loc()\n\t */\n\tBUG_ON(res->sr_blkno != di_blkno);\n\n\tret = ocfs2_read_group_descriptor(ac->ac_inode, di,\n\t\t\t\t\t  res->sr_bg_stable_blkno, &bg_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tchain = le16_to_cpu(bg->bg_chain);\n\n\tret = ocfs2_alloc_dinode_update_counts(ac->ac_inode, handle,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits,\n\t\t\t\t\t       chain);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t ac->ac_inode,\n\t\t\t\t\t bg,\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t res->sr_bit_offset,\n\t\t\t\t\t res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(ac->ac_inode,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_claim_new_inode_at_loc((unsigned long long)di_blkno,\n\t\t\t\t\t   res->sr_bits);\n\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res->sr_bits != 1);\n\n\t*suballoc_loc = res->sr_bg_blkno;\n\t*suballoc_bit = res->sr_bit_offset;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\nout:\n\tbrelse(bg_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_mknod_credits(osb->sb, 0, 0)"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod_credits",
          "args": [
            "osb->sb",
            "0",
            "0"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "433-443",
          "snippet": "static inline int ocfs2_mknod_credits(struct super_block *sb, int is_dir,\n\t\t\t\t      int xattr_credits)\n{\n\tint dir_credits = OCFS2_DIR_LINK_ADDITIONAL_CREDITS;\n\n\tif (is_dir)\n\t\tdir_credits += ocfs2_add_dir_index_credits(sb);\n\n\treturn 4 + OCFS2_SUBALLOC_ALLOC + dir_credits + xattr_credits +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)",
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_mknod_credits(struct super_block *sb, int is_dir,\n\t\t\t\t      int xattr_credits)\n{\n\tint dir_credits = OCFS2_DIR_LINK_ADDITIONAL_CREDITS;\n\n\tif (is_dir)\n\t\tdir_credits += ocfs2_add_dir_index_credits(sb);\n\n\treturn 4 + OCFS2_SUBALLOC_ALLOC + dir_credits + xattr_credits +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_init_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "200-218",
          "snippet": "static struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prep_new_orphaned_file",
          "args": [
            "dir",
            "parent_di_bh",
            "orphan_name",
            "&orphan_dir",
            "&di_blkno",
            "&orphan_insert",
            "&inode_ac"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prep_new_orphaned_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2391-2458",
          "snippet": "static int ocfs2_prep_new_orphaned_file(struct inode *dir,\n\t\t\t\t\tstruct buffer_head *dir_bh,\n\t\t\t\t\tchar *orphan_name,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tu64 *ret_di_blkno,\n\t\t\t\t\tstruct ocfs2_dir_lookup_result *orphan_insert,\n\t\t\t\t\tstruct ocfs2_alloc_context **ret_inode_ac)\n{\n\tint ret;\n\tu64 di_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct inode *orphan_dir = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir, &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* reserve an inode spot */\n\tret = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_new_inode_loc(dir, dir_bh, inode_ac,\n\t\t\t\t       &di_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir, orphan_dir_bh,\n\t\t\t\t\t di_blkno, orphan_name, orphan_insert,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret == 0) {\n\t\t*ret_orphan_dir = orphan_dir;\n\t\t*ret_di_blkno = di_blkno;\n\t\t*ret_inode_ac = inode_ac;\n\t\t/*\n\t\t * orphan_name and orphan_insert are already up to\n\t\t * date via prepare_orphan_dir\n\t\t */\n\t} else {\n\t\t/* Unroll reserve_new_inode* */\n\t\tif (inode_ac)\n\t\t\tocfs2_free_alloc_context(inode_ac);\n\n\t\t/* Unroll orphan dir locking */\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(orphan_dir_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_prep_new_orphaned_file(struct inode *dir,\n\t\t\t\t\tstruct buffer_head *dir_bh,\n\t\t\t\t\tchar *orphan_name,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tu64 *ret_di_blkno,\n\t\t\t\t\tstruct ocfs2_dir_lookup_result *orphan_insert,\n\t\t\t\t\tstruct ocfs2_alloc_context **ret_inode_ac)\n{\n\tint ret;\n\tu64 di_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct inode *orphan_dir = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir, &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* reserve an inode spot */\n\tret = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_new_inode_loc(dir, dir_bh, inode_ac,\n\t\t\t\t       &di_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir, orphan_dir_bh,\n\t\t\t\t\t di_blkno, orphan_name, orphan_insert,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret == 0) {\n\t\t*ret_orphan_dir = orphan_dir;\n\t\t*ret_di_blkno = di_blkno;\n\t\t*ret_inode_ac = inode_ac;\n\t\t/*\n\t\t * orphan_name and orphan_insert are already up to\n\t\t * date via prepare_orphan_dir\n\t\t */\n\t} else {\n\t\t/* Unroll reserve_new_inode* */\n\t\tif (inode_ac)\n\t\t\tocfs2_free_alloc_context(inode_ac);\n\n\t\t/* Unroll orphan dir locking */\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(orphan_dir_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dir",
            "&parent_di_bh",
            "1"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nint ocfs2_create_inode_in_orphan(struct inode *dir,\n\t\t\t\t int mode,\n\t\t\t\t struct inode **new_inode)\n{\n\tint status, did_quota_inode = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *parent_di_bh = NULL;\n\tstruct buffer_head *new_di_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tu64 uninitialized_var(di_blkno), suballoc_loc;\n\tu16 suballoc_bit;\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_prep_new_orphaned_file(dir, parent_di_bh,\n\t\t\t\t\t      orphan_name, &orphan_dir,\n\t\t\t\t\t      &di_blkno, &orphan_insert, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb, 0, 0));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\tstatus = ocfs2_claim_new_inode_at_loc(handle, dir, inode_ac,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit, di_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tclear_nlink(inode);\n\t/* do the real work now. */\n\tstatus = __ocfs2_mknod_locked(dir, inode,\n\t\t\t\t      0, &new_di_bh, parent_di_bh, handle,\n\t\t\t\t      inode_ac, di_blkno, suballoc_loc,\n\t\t\t\t      suballoc_bit);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdi = (struct ocfs2_dinode *)new_di_bh->b_data;\n\tstatus = ocfs2_orphan_add(osb, handle, inode, new_di_bh, orphan_name,\n\t\t\t\t  &orphan_insert, orphan_dir, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get open lock so that only nodes can't remove it from orphan dir. */\n\tstatus = ocfs2_open_lock(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tinsert_inode_hash(inode);\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif ((status < 0) && inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tbrelse(new_di_bh);\n\n\tif (!status)\n\t\t*new_inode = inode;\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\n\tocfs2_inode_unlock(dir, 1);\n\tbrelse(parent_di_bh);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_prep_new_orphaned_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2391-2458",
    "snippet": "static int ocfs2_prep_new_orphaned_file(struct inode *dir,\n\t\t\t\t\tstruct buffer_head *dir_bh,\n\t\t\t\t\tchar *orphan_name,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tu64 *ret_di_blkno,\n\t\t\t\t\tstruct ocfs2_dir_lookup_result *orphan_insert,\n\t\t\t\t\tstruct ocfs2_alloc_context **ret_inode_ac)\n{\n\tint ret;\n\tu64 di_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct inode *orphan_dir = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir, &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* reserve an inode spot */\n\tret = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_new_inode_loc(dir, dir_bh, inode_ac,\n\t\t\t\t       &di_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir, orphan_dir_bh,\n\t\t\t\t\t di_blkno, orphan_name, orphan_insert,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret == 0) {\n\t\t*ret_orphan_dir = orphan_dir;\n\t\t*ret_di_blkno = di_blkno;\n\t\t*ret_inode_ac = inode_ac;\n\t\t/*\n\t\t * orphan_name and orphan_insert are already up to\n\t\t * date via prepare_orphan_dir\n\t\t */\n\t} else {\n\t\t/* Unroll reserve_new_inode* */\n\t\tif (inode_ac)\n\t\t\tocfs2_free_alloc_context(inode_ac);\n\n\t\t/* Unroll orphan dir locking */\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(orphan_dir_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "orphan_dir_bh"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir",
            "1"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir->i_mutex"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "inode_ac"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_prepare_orphan_dir",
          "args": [
            "orphan_dir",
            "orphan_dir_bh",
            "di_blkno",
            "orphan_name",
            "orphan_insert",
            "false"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_prepare_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2093-2133",
          "snippet": "static int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_new_inode_loc",
          "args": [
            "dir",
            "dir_bh",
            "inode_ac",
            "&di_blkno"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_new_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2066-2125",
          "snippet": "int ocfs2_find_new_inode_loc(struct inode *dir,\n\t\t\t     struct buffer_head *parent_fe_bh,\n\t\t\t     struct ocfs2_alloc_context *ac,\n\t\t\t     u64 *fe_blkno)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_suballoc_result *res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tres = kzalloc(sizeof(*res), GFP_NOFS);\n\tif (res == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\t/*\n\t * The handle started here is for chain relink. Alternatively,\n\t * we could just disable relink for these calls.\n\t */\n\thandle = ocfs2_start_trans(OCFS2_SB(dir->i_sb), OCFS2_SUBALLOC_ALLOC);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This will instruct ocfs2_claim_suballoc_bits and\n\t * ocfs2_search_one_group to search but save actual allocation\n\t * for later.\n\t */\n\tac->ac_find_loc_only = 1;\n\n\tret = ocfs2_claim_suballoc_bits(ac, handle, 1, 1, res);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac->ac_find_loc_priv = res;\n\t*fe_blkno = res->sr_blkno;\n\tocfs2_update_inode_fsync_trans(handle, dir, 0);\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(dir->i_sb), handle);\n\n\tif (ret)\n\t\tkfree(res);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_find_new_inode_loc(struct inode *dir,\n\t\t\t     struct buffer_head *parent_fe_bh,\n\t\t\t     struct ocfs2_alloc_context *ac,\n\t\t\t     u64 *fe_blkno)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_suballoc_result *res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tres = kzalloc(sizeof(*res), GFP_NOFS);\n\tif (res == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\t/*\n\t * The handle started here is for chain relink. Alternatively,\n\t * we could just disable relink for these calls.\n\t */\n\thandle = ocfs2_start_trans(OCFS2_SB(dir->i_sb), OCFS2_SUBALLOC_ALLOC);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This will instruct ocfs2_claim_suballoc_bits and\n\t * ocfs2_search_one_group to search but save actual allocation\n\t * for later.\n\t */\n\tac->ac_find_loc_only = 1;\n\n\tret = ocfs2_claim_suballoc_bits(ac, handle, 1, 1, res);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac->ac_find_loc_priv = res;\n\t*fe_blkno = res->sr_blkno;\n\tocfs2_update_inode_fsync_trans(handle, dir, 0);\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(dir->i_sb), handle);\n\n\tif (ret)\n\t\tkfree(res);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_inode",
          "args": [
            "osb",
            "&inode_ac"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1060-1150",
          "snippet": "int ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_lock_orphan_dir",
          "args": [
            "osb",
            "&orphan_dir",
            "&orphan_dir_bh"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_lock_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2059-2091",
          "snippet": "static int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_prep_new_orphaned_file(struct inode *dir,\n\t\t\t\t\tstruct buffer_head *dir_bh,\n\t\t\t\t\tchar *orphan_name,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tu64 *ret_di_blkno,\n\t\t\t\t\tstruct ocfs2_dir_lookup_result *orphan_insert,\n\t\t\t\t\tstruct ocfs2_alloc_context **ret_inode_ac)\n{\n\tint ret;\n\tu64 di_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct inode *orphan_dir = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir, &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* reserve an inode spot */\n\tret = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_new_inode_loc(dir, dir_bh, inode_ac,\n\t\t\t\t       &di_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir, orphan_dir_bh,\n\t\t\t\t\t di_blkno, orphan_name, orphan_insert,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret == 0) {\n\t\t*ret_orphan_dir = orphan_dir;\n\t\t*ret_di_blkno = di_blkno;\n\t\t*ret_inode_ac = inode_ac;\n\t\t/*\n\t\t * orphan_name and orphan_insert are already up to\n\t\t * date via prepare_orphan_dir\n\t\t */\n\t} else {\n\t\t/* Unroll reserve_new_inode* */\n\t\tif (inode_ac)\n\t\t\tocfs2_free_alloc_context(inode_ac);\n\n\t\t/* Unroll orphan dir locking */\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(orphan_dir_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_orphan_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2292-2364",
    "snippet": "int ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
      "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
      "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "orphan_dir_bh"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "orphan_dir_inode",
            "ocfs2_read_links_count(orphan_fe)"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "orphan_fe"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_links_count",
          "args": [
            "orphan_fe",
            "-1"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "575-582",
          "snippet": "static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(orphan_dir_inode)",
            "orphan_dir_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_entry",
          "args": [
            "handle",
            "orphan_dir_inode",
            "&lookup"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1414-1427",
          "snippet": "int ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry",
          "args": [
            "name",
            "namelen",
            "orphan_dir_inode",
            "&lookup"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1086-1111",
          "snippet": "int ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_orphan_del",
          "args": [
            "(unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno",
            "name",
            "namelen"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blkno_stringify",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "name"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blkno_stringify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2030-2057",
          "snippet": "static int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "OCFS2_DIO_ORPHAN_PREFIX_LEN + 1",
            "\"%s\"",
            "OCFS2_DIO_ORPHAN_PREFIX"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nint ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_orphan_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2190-2289",
    "snippet": "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
      "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "orphan_dir_bh"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "orphan_dir_inode",
            "ocfs2_read_links_count(orphan_fe)"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "orphan_fe"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_links_count",
          "args": [
            "orphan_fe",
            "-1"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "575-582",
          "snippet": "static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_orphan_add_end",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "osb->slot_num"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "fe_bh"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "osb->slot_num"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_ORPHANED_FL"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "osb->slot_num"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DIO_ORPHANED_FL"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_add_entry",
          "args": [
            "handle",
            "orphan_dir_inode",
            "name",
            "namelen",
            "inode",
            "OCFS2_I(inode)->ip_blkno",
            "orphan_dir_bh",
            "lookup"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1608-1760",
          "snippet": "int __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "orphan_dir_inode",
            "&orphan_dir_bh"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_orphan_add_begin",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_prepare_orphan_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2149-2188",
    "snippet": "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
      "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir_inode",
            "1"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "orphan_dir_bh"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_prepare_orphan_dir",
          "args": [
            "orphan_dir_inode",
            "orphan_dir_bh",
            "blkno",
            "name",
            "lookup",
            "dio"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_prepare_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2093-2133",
          "snippet": "static int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_lock_orphan_dir",
          "args": [
            "osb",
            "&orphan_dir_inode",
            "&orphan_dir_bh"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_lock_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2059-2091",
          "snippet": "static int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_prepare_orphan_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2093-2133",
    "snippet": "static int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
      "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
      "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "orphan_dir_inode",
            "orphan_dir_bh",
            "name",
            "namelen",
            "lookup"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blkno_stringify",
          "args": [
            "blkno",
            "name"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blkno_stringify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2030-2057",
          "snippet": "static int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "OCFS2_DIO_ORPHAN_PREFIX_LEN + 1",
            "\"%s\"",
            "OCFS2_DIO_ORPHAN_PREFIX"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "orphan_dir_inode->i_sb"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_lookup_lock_orphan_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2059-2091",
    "snippet": "static int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "orphan_dir_inode",
            "&orphan_dir_bh",
            "1"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ORPHAN_DIR_SYSTEM_INODE",
            "osb->slot_num"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_blkno_stringify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "2030-2057",
    "snippet": "static int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_blkno_stringify",
          "args": [
            "blkno",
            "name",
            "namelen"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "OCFS2_ORPHAN_NAMELEN + 1",
            "\"%016llx\"",
            "(long long)blkno"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1765-2028",
    "snippet": "static int ocfs2_symlink(struct inode *dir,\n\t\t\t struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tint status, l, credits;\n\tu64 newsize;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_dinode *dirfe;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *xattr_ac = NULL;\n\tint want_clusters = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota = 0, did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_symlink_begin(dir, dentry, symname,\n\t\t\t\t  dentry->d_name.len, dentry->d_name.name);\n\n\tdquot_initialize(dir);\n\n\tsb = dir->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tl = strlen(symname) + 1;\n\n\tcredits = ocfs2_calc_symlink_credits(sb);\n\n\t/* lock the parent directory */\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security xattr */\n\tif (si.enable) {\n\t\tstatus = ocfs2_calc_security_init(dir, &si, &want_clusters,\n\t\t\t\t\t\t  &xattr_credits, &xattr_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* don't reserve bitmap space for fast symlinks. */\n\tif (l > ocfs2_fast_symlink_chars(sb))\n\t\twant_clusters += 1;\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits + xattr_credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto bail;\n\tdid_quota_inode = 1;\n\n\ttrace_ocfs2_symlink_create(dir, dentry, dentry->d_name.len,\n\t\t\t\t   dentry->d_name.name,\n\t\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t   inode->i_mode);\n\n\tstatus = ocfs2_mknod_locked(osb, dir, inode,\n\t\t\t\t    0, &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfe = (struct ocfs2_dinode *) new_fe_bh->b_data;\n\tinode->i_rdev = 0;\n\tnewsize = l - 1;\n\tinode->i_op = &ocfs2_symlink_inode_operations;\n\tif (l > ocfs2_fast_symlink_chars(sb)) {\n\t\tu32 offset = 0;\n\n\t\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t    ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t\tstatus = ocfs2_add_inode_data(osb, inode, &offset, 1, 0,\n\t\t\t\t\t      new_fe_bh,\n\t\t\t\t\t      handle, data_ac, NULL,\n\t\t\t\t\t      NULL);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC && status != -EINTR) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Failed to extend file to %llu\\n\",\n\t\t\t\t     (unsigned long long)newsize);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t} else {\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t\tmemcpy((char *) fe->id2.i_symlink, symname, l);\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = 0;\n\t}\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, new_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (!ocfs2_inode_is_fast_symlink(inode)) {\n\t\tstatus = ocfs2_create_symlink_data(osb, handle, inode,\n\t\t\t\t\t\t   symname);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t xattr_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t le64_to_cpu(fe->i_blkno), parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\nbail:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\tocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\tocfs2_free_dir_lookup_result(&lookup);\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (xattr_ac)\n\t\tocfs2_free_alloc_context(xattr_ac);\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);",
      "static int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_add_entry_failure",
          "args": [
            "osb",
            "dentry",
            "inode"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_add_entry_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "220-233",
          "snippet": "static void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "xattr_ac"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "si.value"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "parent_fe_bh"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "1"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "osb->sb",
            "1"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode",
            "le64_to_cpu(fe->i_blkno)",
            "parent_fe_bh",
            "&lookup"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
          "lines": "69-78",
          "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_set",
          "args": [
            "handle",
            "inode",
            "new_fe_bh",
            "&si",
            "xattr_ac",
            "data_ac"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7299-7310",
          "snippet": "int ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_symlink_data",
          "args": [
            "osb",
            "handle",
            "inode",
            "symname"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_symlink_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1667-1763",
          "snippet": "static int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname)\n{\n\tstruct buffer_head **bhs = NULL;\n\tconst char *c;\n\tstruct super_block *sb = osb->sb;\n\tu64 p_blkno, p_blocks;\n\tint virtual, blocks, status, i, bytes_left;\n\n\tbytes_left = i_size_read(inode) + 1;\n\t/* we can't trust i_blocks because we're actually going to\n\t * write i_size + 1 bytes. */\n\tblocks = (bytes_left + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\ttrace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,\n\t\t\t\t\ti_size_read(inode), blocks);\n\n\t/* Sanity check -- make sure we're going to fit. */\n\tif (bytes_left >\n\t    ocfs2_clusters_to_bytes(sb, OCFS2_I(inode)->ip_clusters)) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbhs = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(inode, 0, &p_blkno, &p_blocks,\n\t\t\t\t\t     NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* links can never be larger than one cluster so we know this\n\t * is all going to be contiguous, but do a sanity check\n\t * anyway. */\n\tif ((p_blocks << sb->s_blocksize_bits) < bytes_left) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tvirtual = 0;\n\twhile(bytes_left > 0) {\n\t\tc = &symname[virtual * sb->s_blocksize];\n\n\t\tbhs[virtual] = sb_getblk(sb, p_blkno);\n\t\tif (!bhs[virtual]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual]);\n\n\t\tstatus = ocfs2_journal_access(handle, INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(bhs[virtual]->b_data, 0, sb->s_blocksize);\n\n\t\tmemcpy(bhs[virtual]->b_data, c,\n\t\t       (bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left);\n\n\t\tocfs2_journal_dirty(handle, bhs[virtual]);\n\n\t\tvirtual++;\n\t\tp_blkno++;\n\t\tbytes_left -= sb->s_blocksize;\n\t}\n\n\tstatus = 0;\nbail:\n\n\tif (bhs) {\n\t\tfor(i = 0; i < blocks; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tkfree(bhs);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);\n\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname)\n{\n\tstruct buffer_head **bhs = NULL;\n\tconst char *c;\n\tstruct super_block *sb = osb->sb;\n\tu64 p_blkno, p_blocks;\n\tint virtual, blocks, status, i, bytes_left;\n\n\tbytes_left = i_size_read(inode) + 1;\n\t/* we can't trust i_blocks because we're actually going to\n\t * write i_size + 1 bytes. */\n\tblocks = (bytes_left + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\ttrace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,\n\t\t\t\t\ti_size_read(inode), blocks);\n\n\t/* Sanity check -- make sure we're going to fit. */\n\tif (bytes_left >\n\t    ocfs2_clusters_to_bytes(sb, OCFS2_I(inode)->ip_clusters)) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbhs = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(inode, 0, &p_blkno, &p_blocks,\n\t\t\t\t\t     NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* links can never be larger than one cluster so we know this\n\t * is all going to be contiguous, but do a sanity check\n\t * anyway. */\n\tif ((p_blocks << sb->s_blocksize_bits) < bytes_left) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tvirtual = 0;\n\twhile(bytes_left > 0) {\n\t\tc = &symname[virtual * sb->s_blocksize];\n\n\t\tbhs[virtual] = sb_getblk(sb, p_blkno);\n\t\tif (!bhs[virtual]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual]);\n\n\t\tstatus = ocfs2_journal_access(handle, INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(bhs[virtual]->b_data, 0, sb->s_blocksize);\n\n\t\tmemcpy(bhs[virtual]->b_data, c,\n\t\t       (bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left);\n\n\t\tocfs2_journal_dirty(handle, bhs[virtual]);\n\n\t\tvirtual++;\n\t\tp_blkno++;\n\t\tbytes_left -= sb->s_blocksize;\n\t}\n\n\tstatus = 0;\nbail:\n\n\tif (bhs) {\n\t\tfor(i = 0; i < blocks; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tkfree(bhs);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "new_fe_bh"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) fe->id2.i_symlink",
            "symname",
            "l"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Failed to extend file to %llu\\n\"",
            "(unsigned long long)newsize"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_inode_data",
          "args": [
            "osb",
            "inode",
            "&offset",
            "1",
            "0",
            "new_fe_bh",
            "handle",
            "data_ac",
            "NULL",
            "NULL"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "538-558",
          "snippet": "int ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_fast_symlink_chars",
          "args": [
            "sb"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fast_symlink_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1480-1483",
          "snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod_locked",
          "args": [
            "osb",
            "dir",
            "inode",
            "0",
            "&new_fe_bh",
            "parent_fe_bh",
            "handle",
            "inode_ac"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "628-654",
          "snippet": "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_symlink_create",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "inode->i_mode"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits + xattr_credits"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "want_clusters",
            "&data_ac"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_security_init",
          "args": [
            "dir",
            "&si",
            "&want_clusters",
            "&xattr_credits",
            "&xattr_ac"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_security_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "593-629",
          "snippet": "int ocfs2_calc_security_init(struct inode *dir,\n\t\t\t     struct ocfs2_security_xattr_info *si,\n\t\t\t     int *want_clusters,\n\t\t\t     int *xattr_credits,\n\t\t\t     struct ocfs2_alloc_context **xattr_ac)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t si->value_len);\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * So reserve one metadata block for it is ok.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    s_size > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, xattr_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\t/* reserve clusters for xattr value which will be set in B tree*/\n\tif (si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tint new_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\t    si->value_len);\n\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)",
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nint ocfs2_calc_security_init(struct inode *dir,\n\t\t\t     struct ocfs2_security_xattr_info *si,\n\t\t\t     int *want_clusters,\n\t\t\t     int *xattr_credits,\n\t\t\t     struct ocfs2_alloc_context **xattr_ac)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t si->value_len);\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * So reserve one metadata block for it is ok.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    s_size > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, xattr_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\t/* reserve clusters for xattr value which will be set in B tree*/\n\tif (si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tint new_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\t    si->value_len);\n\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_get",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name",
            "&si"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7282-7297",
          "snippet": "int ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_init_inode",
          "args": [
            "dir",
            "S_IFLNK | S_IRWXUGO"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "200-218",
          "snippet": "static struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_inode",
          "args": [
            "osb",
            "&inode_ac"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1060-1150",
          "snippet": "int ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "dir",
            "parent_fe_bh",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&lookup"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_for_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2046-2067",
          "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "dirfe"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dir",
            "&parent_fe_bh",
            "1"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_symlink_credits",
          "args": [
            "sb"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_symlink_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "558-567",
          "snippet": "static inline int ocfs2_calc_symlink_credits(struct super_block *sb)\n{\n\tint blocks = ocfs2_mknod_credits(sb, 0, 0);\n\n\t/* links can be longer than one block so we may update many\n\t * within our single allocated extent. */\n\tblocks += ocfs2_clusters_to_blocks(sb, 1);\n\n\treturn blocks + ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_calc_symlink_credits(struct super_block *sb)\n{\n\tint blocks = ocfs2_mknod_credits(sb, 0, 0);\n\n\t/* links can be longer than one block so we may update many\n\t * within our single allocated extent. */\n\tblocks += ocfs2_clusters_to_blocks(sb, 1);\n\n\treturn blocks + ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_symlink_begin",
          "args": [
            "dir",
            "dentry",
            "symname",
            "dentry->d_name.len",
            "dentry->d_name.name"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);\n\nstatic int ocfs2_symlink(struct inode *dir,\n\t\t\t struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tint status, l, credits;\n\tu64 newsize;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_dinode *dirfe;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *xattr_ac = NULL;\n\tint want_clusters = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota = 0, did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_symlink_begin(dir, dentry, symname,\n\t\t\t\t  dentry->d_name.len, dentry->d_name.name);\n\n\tdquot_initialize(dir);\n\n\tsb = dir->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tl = strlen(symname) + 1;\n\n\tcredits = ocfs2_calc_symlink_credits(sb);\n\n\t/* lock the parent directory */\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security xattr */\n\tif (si.enable) {\n\t\tstatus = ocfs2_calc_security_init(dir, &si, &want_clusters,\n\t\t\t\t\t\t  &xattr_credits, &xattr_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* don't reserve bitmap space for fast symlinks. */\n\tif (l > ocfs2_fast_symlink_chars(sb))\n\t\twant_clusters += 1;\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits + xattr_credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto bail;\n\tdid_quota_inode = 1;\n\n\ttrace_ocfs2_symlink_create(dir, dentry, dentry->d_name.len,\n\t\t\t\t   dentry->d_name.name,\n\t\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t   inode->i_mode);\n\n\tstatus = ocfs2_mknod_locked(osb, dir, inode,\n\t\t\t\t    0, &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfe = (struct ocfs2_dinode *) new_fe_bh->b_data;\n\tinode->i_rdev = 0;\n\tnewsize = l - 1;\n\tinode->i_op = &ocfs2_symlink_inode_operations;\n\tif (l > ocfs2_fast_symlink_chars(sb)) {\n\t\tu32 offset = 0;\n\n\t\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t    ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t\tstatus = ocfs2_add_inode_data(osb, inode, &offset, 1, 0,\n\t\t\t\t\t      new_fe_bh,\n\t\t\t\t\t      handle, data_ac, NULL,\n\t\t\t\t\t      NULL);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC && status != -EINTR) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Failed to extend file to %llu\\n\",\n\t\t\t\t     (unsigned long long)newsize);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t} else {\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t\tmemcpy((char *) fe->id2.i_symlink, symname, l);\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = 0;\n\t}\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, new_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (!ocfs2_inode_is_fast_symlink(inode)) {\n\t\tstatus = ocfs2_create_symlink_data(osb, handle, inode,\n\t\t\t\t\t\t   symname);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t xattr_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t le64_to_cpu(fe->i_blkno), parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\nbail:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\tocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\tocfs2_free_dir_lookup_result(&lookup);\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (xattr_ac)\n\t\tocfs2_free_alloc_context(xattr_ac);\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_create_symlink_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1667-1763",
    "snippet": "static int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname)\n{\n\tstruct buffer_head **bhs = NULL;\n\tconst char *c;\n\tstruct super_block *sb = osb->sb;\n\tu64 p_blkno, p_blocks;\n\tint virtual, blocks, status, i, bytes_left;\n\n\tbytes_left = i_size_read(inode) + 1;\n\t/* we can't trust i_blocks because we're actually going to\n\t * write i_size + 1 bytes. */\n\tblocks = (bytes_left + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\ttrace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,\n\t\t\t\t\ti_size_read(inode), blocks);\n\n\t/* Sanity check -- make sure we're going to fit. */\n\tif (bytes_left >\n\t    ocfs2_clusters_to_bytes(sb, OCFS2_I(inode)->ip_clusters)) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbhs = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(inode, 0, &p_blkno, &p_blocks,\n\t\t\t\t\t     NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* links can never be larger than one cluster so we know this\n\t * is all going to be contiguous, but do a sanity check\n\t * anyway. */\n\tif ((p_blocks << sb->s_blocksize_bits) < bytes_left) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tvirtual = 0;\n\twhile(bytes_left > 0) {\n\t\tc = &symname[virtual * sb->s_blocksize];\n\n\t\tbhs[virtual] = sb_getblk(sb, p_blkno);\n\t\tif (!bhs[virtual]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual]);\n\n\t\tstatus = ocfs2_journal_access(handle, INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(bhs[virtual]->b_data, 0, sb->s_blocksize);\n\n\t\tmemcpy(bhs[virtual]->b_data, c,\n\t\t       (bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left);\n\n\t\tocfs2_journal_dirty(handle, bhs[virtual]);\n\n\t\tvirtual++;\n\t\tp_blkno++;\n\t\tbytes_left -= sb->s_blocksize;\n\t}\n\n\tstatus = 0;\nbail:\n\n\tif (bhs) {\n\t\tfor(i = 0; i < blocks; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tkfree(bhs);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bhs"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bhs[virtual]"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bhs[virtual]->b_data",
            "c",
            "(bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs[virtual]->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bhs[virtual]",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "765-769",
          "snippet": "int ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(inode)",
            "bhs[virtual]"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "p_blkno"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "inode",
            "0",
            "&p_blkno",
            "&p_blocks",
            "NULL"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "blocks",
            "sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "sb",
            "OCFS2_I(inode)->ip_clusters"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_create_symlink_data",
          "args": [
            "(unsigned long long)inode->i_blocks",
            "i_size_read(inode)",
            "blocks"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);\n\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname)\n{\n\tstruct buffer_head **bhs = NULL;\n\tconst char *c;\n\tstruct super_block *sb = osb->sb;\n\tu64 p_blkno, p_blocks;\n\tint virtual, blocks, status, i, bytes_left;\n\n\tbytes_left = i_size_read(inode) + 1;\n\t/* we can't trust i_blocks because we're actually going to\n\t * write i_size + 1 bytes. */\n\tblocks = (bytes_left + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\ttrace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,\n\t\t\t\t\ti_size_read(inode), blocks);\n\n\t/* Sanity check -- make sure we're going to fit. */\n\tif (bytes_left >\n\t    ocfs2_clusters_to_bytes(sb, OCFS2_I(inode)->ip_clusters)) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbhs = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(inode, 0, &p_blkno, &p_blocks,\n\t\t\t\t\t     NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* links can never be larger than one cluster so we know this\n\t * is all going to be contiguous, but do a sanity check\n\t * anyway. */\n\tif ((p_blocks << sb->s_blocksize_bits) < bytes_left) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tvirtual = 0;\n\twhile(bytes_left > 0) {\n\t\tc = &symname[virtual * sb->s_blocksize];\n\n\t\tbhs[virtual] = sb_getblk(sb, p_blkno);\n\t\tif (!bhs[virtual]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual]);\n\n\t\tstatus = ocfs2_journal_access(handle, INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(bhs[virtual]->b_data, 0, sb->s_blocksize);\n\n\t\tmemcpy(bhs[virtual]->b_data, c,\n\t\t       (bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left);\n\n\t\tocfs2_journal_dirty(handle, bhs[virtual]);\n\n\t\tvirtual++;\n\t\tp_blkno++;\n\t\tbytes_left -= sb->s_blocksize;\n\t}\n\n\tstatus = 0;\nbail:\n\n\tif (bhs) {\n\t\tfor(i = 0; i < blocks; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tkfree(bhs);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1205-1661",
    "snippet": "static int ocfs2_rename(struct inode *old_dir,\n\t\t\tstruct dentry *old_dentry,\n\t\t\tstruct inode *new_dir,\n\t\t\tstruct dentry *new_dentry)\n{\n\tint status = 0, rename_lock = 0, parents_locked = 0, target_exists = 0;\n\tint old_child_locked = 0, new_child_locked = 0, update_dot_dot = 0;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_dinode *newfe = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *newfe_bh = NULL;\n\tstruct buffer_head *old_inode_bh = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tu64 newfe_blkno, old_de_ino;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *new_dir_bh = NULL;\n\tu32 old_dir_nlink = old_dir->i_nlink;\n\tstruct ocfs2_dinode *old_di;\n\tstruct ocfs2_dir_lookup_result old_inode_dot_dot_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_lookup_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result old_entry_lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_insert = { NULL, };\n\tbool should_add_orphan = false;\n\n\t/* At some point it might be nice to break this function up a\n\t * bit. */\n\n\ttrace_ocfs2_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t   old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t   new_dentry->d_name.len, new_dentry->d_name.name);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\tosb = OCFS2_SB(old_dir->i_sb);\n\n\tif (new_inode) {\n\t\tif (!igrab(new_inode))\n\t\t\tBUG();\n\t}\n\n\t/* Assume a directory hierarchy thusly:\n\t * a/b/c\n\t * a/d\n\t * a,b,c, and d are all directories.\n\t *\n\t * from cwd of 'a' on both nodes:\n\t * node1: mv b/c d\n\t * node2: mv d   b/c\n\t *\n\t * And that's why, just like the VFS, we need a file system\n\t * rename lock. */\n\tif (old_dir != new_dir && S_ISDIR(old_inode->i_mode)) {\n\t\tstatus = ocfs2_rename_lock(osb);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\trename_lock = 1;\n\n\t\t/* here we cannot guarantee the inodes haven't just been\n\t\t * changed, so check if they are nested again */\n\t\tstatus = ocfs2_check_if_ancestor(osb, new_dir->i_ino,\n\t\t\t\told_inode->i_ino);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t} else if (status == 1) {\n\t\t\tstatus = -EPERM;\n\t\t\ttrace_ocfs2_rename_not_permitted(\n\t\t\t\t\t(unsigned long long)old_inode->i_ino,\n\t\t\t\t\t(unsigned long long)new_dir->i_ino);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* if old and new are the same, this'll just do one lock. */\n\tstatus = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t\t   &new_dir_bh, new_dir, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tparents_locked = 1;\n\n\t/* make sure both dirs have bhs\n\t * get an extra ref on old_dir_bh if old==new */\n\tif (!new_dir_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tnew_dir_bh = old_dir_bh;\n\t\t\tget_bh(new_dir_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"no old_dir_bh!\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/*\n\t * Aside from allowing a meta data update, the locking here\n\t * also ensures that the downconvert thread on other nodes\n\t * won't have to concurrently downconvert the inode and the\n\t * dentry locks.\n\t */\n\tstatus = ocfs2_inode_lock_nested(old_inode, &old_inode_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\told_child_locked = 1;\n\n\tstatus = ocfs2_remote_dentry_delete(old_dentry);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tu64 old_inode_parent;\n\n\t\tupdate_dot_dot = 1;\n\t\tstatus = ocfs2_find_files_on_disk(\"..\", 2, &old_inode_parent,\n\t\t\t\t\t\t  old_inode,\n\t\t\t\t\t\t  &old_inode_dot_dot_res);\n\t\tif (status) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (old_inode_parent != OCFS2_I(old_dir)->ip_blkno) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!new_inode && new_dir != old_dir &&\n\t\t    new_dir->i_nlink >= ocfs2_link_max(osb)) {\n\t\t\tstatus = -EMLINK;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de_ino);\n\tif (status) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tif (old_de_ino != OCFS2_I(old_inode)->ip_blkno) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/* check if the target already exists (in which case we need\n\t * to delete it */\n\tstatus = ocfs2_find_files_on_disk(new_dentry->d_name.name,\n\t\t\t\t\t  new_dentry->d_name.len,\n\t\t\t\t\t  &newfe_blkno, new_dir,\n\t\t\t\t\t  &target_lookup_res);\n\t/* The only error we allow here is -ENOENT because the new\n\t * file not existing is perfectly valid. */\n\tif ((status < 0) && (status != -ENOENT)) {\n\t\t/* If we cannot find the file specified we should just */\n\t\t/* return the error... */\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (status == 0)\n\t\ttarget_exists = 1;\n\n\tif (!target_exists && new_inode) {\n\t\t/*\n\t\t * Target was unlinked by another node while we were\n\t\t * waiting to get to ocfs2_rename(). There isn't\n\t\t * anything we can do here to help the situation, so\n\t\t * bubble up the appropriate error.\n\t\t */\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/* In case we need to overwrite an existing file, we blow it\n\t * away first */\n\tif (target_exists) {\n\t\t/* VFS didn't think there existed an inode here, but\n\t\t * someone else in the cluster must have raced our\n\t\t * rename to create one. Today we error cleanly, in\n\t\t * the future we should consider calling iget to build\n\t\t * a new struct inode for this entry. */\n\t\tif (!new_inode) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_target_exists(new_dentry->d_name.len,\n\t\t\t\t\t\tnew_dentry->d_name.name);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (OCFS2_I(new_inode)->ip_blkno != newfe_blkno) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_disagree(\n\t\t\t     (unsigned long long)OCFS2_I(new_inode)->ip_blkno,\n\t\t\t     (unsigned long long)newfe_blkno,\n\t\t\t     OCFS2_I(new_inode)->ip_flags);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_inode_lock(new_inode, &newfe_bh, 1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tnew_child_locked = 1;\n\n\t\tstatus = ocfs2_remote_dentry_delete(new_dentry);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tnewfe = (struct ocfs2_dinode *) newfe_bh->b_data;\n\n\t\ttrace_ocfs2_rename_over_existing(\n\t\t     (unsigned long long)newfe_blkno, newfe_bh, newfe_bh ?\n\t\t     (unsigned long long)newfe_bh->b_blocknr : 0ULL);\n\n\t\tif (S_ISDIR(new_inode->i_mode) || (new_inode->i_nlink == 1)) {\n\t\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\tOCFS2_I(new_inode)->ip_blkno,\n\t\t\t\t\t\torphan_name, &orphan_insert,\n\t\t\t\t\t\tfalse);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tshould_add_orphan = true;\n\t\t}\n\t} else {\n\t\tBUG_ON(new_dentry->d_parent->d_inode != new_dir);\n\n\t\tstatus = ocfs2_check_dir_for_entry(new_dir,\n\t\t\t\t\t\t   new_dentry->d_name.name,\n\t\t\t\t\t\t   new_dentry->d_name.len);\n\t\tif (status)\n\t\t\tgoto bail;\n\n\t\tstatus = ocfs2_prepare_dir_for_insert(osb, new_dir, new_dir_bh,\n\t\t\t\t\t\t      new_dentry->d_name.name,\n\t\t\t\t\t\t      new_dentry->d_name.len,\n\t\t\t\t\t\t      &target_insert);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (target_exists) {\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\tif (new_inode->i_nlink != 2 ||\n\t\t\t    !ocfs2_empty_dir(new_inode)) {\n\t\t\t\tstatus = -ENOTEMPTY;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(new_inode),\n\t\t\t\t\t\t newfe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* change the dirent to point to the correct inode */\n\t\tstatus = ocfs2_update_entry(new_dir, handle, &target_lookup_res,\n\t\t\t\t\t    old_inode);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tnew_dir->i_version++;\n\n\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\tocfs2_set_links_count(newfe, 0);\n\t\telse\n\t\t\tocfs2_add_links_count(newfe, -1);\n\t\tocfs2_journal_dirty(handle, newfe_bh);\n\t\tif (should_add_orphan) {\n\t\t\tstatus = ocfs2_orphan_add(osb, handle, new_inode,\n\t\t\t\t\tnewfe_bh, orphan_name,\n\t\t\t\t\t&orphan_insert, orphan_dir, false);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if the name was not found in new_dir, add it now */\n\t\tstatus = ocfs2_add_entry(handle, new_dentry, old_inode,\n\t\t\t\t\t OCFS2_I(old_inode)->ip_blkno,\n\t\t\t\t\t new_dir_bh, &target_insert);\n\t}\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(old_inode),\n\t\t\t\t\t old_inode_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status >= 0) {\n\t\told_di = (struct ocfs2_dinode *) old_inode_bh->b_data;\n\n\t\told_di->i_ctime = cpu_to_le64(old_inode->i_ctime.tv_sec);\n\t\told_di->i_ctime_nsec = cpu_to_le32(old_inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(handle, old_inode_bh);\n\t} else\n\t\tmlog_errno(status);\n\n\t/*\n\t * Now that the name has been added to new_dir, remove the old name.\n\t *\n\t * We don't keep any directory entry context around until now\n\t * because the insert might have changed the type of directory\n\t * we're dealing with.\n\t */\n\tstatus = ocfs2_find_entry(old_dentry->d_name.name,\n\t\t\t\t  old_dentry->d_name.len, old_dir,\n\t\t\t\t  &old_entry_lookup);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = ocfs2_delete_entry(handle, old_dir, &old_entry_lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;\n\n\tif (update_dot_dot) {\n\t\tstatus = ocfs2_update_entry(old_inode, handle,\n\t\t\t\t\t    &old_inode_dot_dot_res, new_dir);\n\t\tdrop_nlink(old_dir);\n\t\tif (new_inode) {\n\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\tmark_inode_dirty(old_dir);\n\tocfs2_mark_inode_dirty(handle, old_dir, old_dir_bh);\n\tif (new_inode) {\n\t\tmark_inode_dirty(new_inode);\n\t\tocfs2_mark_inode_dirty(handle, new_inode, newfe_bh);\n\t}\n\n\tif (old_dir != new_dir) {\n\t\t/* Keep the same times on both directories.*/\n\t\tnew_dir->i_ctime = new_dir->i_mtime = old_dir->i_ctime;\n\n\t\t/*\n\t\t * This will also pick up the i_nlink change from the\n\t\t * block above.\n\t\t */\n\t\tocfs2_mark_inode_dirty(handle, new_dir, new_dir_bh);\n\t}\n\n\tif (old_dir_nlink != old_dir->i_nlink) {\n\t\tif (!old_dir_bh) {\n\t\t\tmlog(ML_ERROR, \"need to change nlink for old dir \"\n\t\t\t     \"%llu from %d to %d but bh is NULL!\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(old_dir)->ip_blkno,\n\t\t\t     (int)old_dir_nlink, old_dir->i_nlink);\n\t\t} else {\n\t\t\tstruct ocfs2_dinode *fe;\n\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t INODE_CACHE(old_dir),\n\t\t\t\t\t\t\t old_dir_bh,\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tfe = (struct ocfs2_dinode *) old_dir_bh->b_data;\n\t\t\tocfs2_set_links_count(fe, old_dir->i_nlink);\n\t\t\tocfs2_journal_dirty(handle, old_dir_bh);\n\t\t}\n\t}\n\tocfs2_dentry_move(old_dentry, new_dentry, old_dir, new_dir);\n\tstatus = 0;\nbail:\n\tif (rename_lock)\n\t\tocfs2_rename_unlock(osb);\n\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (parents_locked)\n\t\tocfs2_double_unlock(old_dir, new_dir);\n\n\tif (old_child_locked)\n\t\tocfs2_inode_unlock(old_inode, 1);\n\n\tif (new_child_locked)\n\t\tocfs2_inode_unlock(new_inode, 1);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif (new_inode)\n\t\tsync_mapping_buffers(old_inode->i_mapping);\n\n\tif (new_inode)\n\t\tiput(new_inode);\n\n\tocfs2_free_dir_lookup_result(&target_lookup_res);\n\tocfs2_free_dir_lookup_result(&old_entry_lookup);\n\tocfs2_free_dir_lookup_result(&old_inode_dot_dot_res);\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&target_insert);\n\n\tbrelse(newfe_bh);\n\tbrelse(old_inode_bh);\n\tbrelse(old_dir_bh);\n\tbrelse(new_dir_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [
      "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_dir_bh"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&target_insert"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "new_inode"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "old_inode->i_mapping"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir->i_mutex"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir",
            "1"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_double_unlock",
          "args": [
            "old_dir",
            "new_dir"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_double_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1197-1203",
          "snippet": "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rename_unlock",
          "args": [
            "osb"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rename_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2615-2621",
          "snippet": "void ocfs2_rename_unlock(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rename_unlock(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_move",
          "args": [
            "old_dentry",
            "new_dentry",
            "old_dir",
            "new_dir"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "444-469",
          "snippet": "void ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\n\t\t       struct inode *old_dir, struct inode *new_dir)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * Move within the same directory, so the actual lock info won't\n\t * change.\n\t *\n\t * XXX: Is there any advantage to dropping the lock here?\n\t */\n\tif (old_dir == new_dir)\n\t\tgoto out_move;\n\n\tocfs2_dentry_lock_put(osb, dentry->d_fsdata);\n\n\tdentry->d_fsdata = NULL;\n\tret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_move:\n\td_move(dentry, target);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\n\t\t       struct inode *old_dir, struct inode *new_dir)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * Move within the same directory, so the actual lock info won't\n\t * change.\n\t *\n\t * XXX: Is there any advantage to dropping the lock here?\n\t */\n\tif (old_dir == new_dir)\n\t\tgoto out_move;\n\n\tocfs2_dentry_lock_put(osb, dentry->d_fsdata);\n\n\tdentry->d_fsdata = NULL;\n\tret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_move:\n\td_move(dentry, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "old_dir_bh"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "fe",
            "old_dir->i_nlink"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(old_dir)",
            "old_dir_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "old_dir"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"need to change nlink for old dir \"\n\t\t\t     \"%llu from %d to %d but bh is NULL!\\n\"",
            "(unsigned long long)OCFS2_I(old_dir)->ip_blkno",
            "(int)old_dir_nlink",
            "old_dir->i_nlink"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "old_dir"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "new_dir",
            "new_dir_bh"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "new_inode"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_entry",
          "args": [
            "old_inode",
            "handle",
            "&old_inode_dot_dot_res",
            "new_dir"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1116-1148",
          "snippet": "int ocfs2_update_entry(struct inode *dir, handle_t *handle,\n\t\t       struct ocfs2_dir_lookup_result *res,\n\t\t       struct inode *new_entry_inode)\n{\n\tint ret;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\tstruct ocfs2_dir_entry *de = res->dl_entry;\n\tstruct buffer_head *de_bh = res->dl_leaf_bh;\n\n\t/*\n\t * The same code works fine for both inline-data and extent\n\t * based directories, so no need to split this up.  The only\n\t * difference is the journal_access function.\n\t */\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\tret = access(handle, INODE_CACHE(dir), de_bh,\n\t\t     OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tde->inode = cpu_to_le64(OCFS2_I(new_entry_inode)->ip_blkno);\n\tocfs2_set_de_type(de, new_entry_inode->i_mode);\n\n\tocfs2_journal_dirty(handle, de_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_update_entry(struct inode *dir, handle_t *handle,\n\t\t       struct ocfs2_dir_lookup_result *res,\n\t\t       struct inode *new_entry_inode)\n{\n\tint ret;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\tstruct ocfs2_dir_entry *de = res->dl_entry;\n\tstruct buffer_head *de_bh = res->dl_leaf_bh;\n\n\t/*\n\t * The same code works fine for both inline-data and extent\n\t * based directories, so no need to split this up.  The only\n\t * difference is the journal_access function.\n\t */\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\tret = access(handle, INODE_CACHE(dir), de_bh,\n\t\t     OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tde->inode = cpu_to_le64(OCFS2_I(new_entry_inode)->ip_blkno);\n\tocfs2_set_de_type(de, new_entry_inode->i_mode);\n\n\tocfs2_journal_dirty(handle, de_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_entry",
          "args": [
            "handle",
            "old_dir",
            "&old_entry_lookup"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1414-1427",
          "snippet": "int ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry",
          "args": [
            "old_dentry->d_name.name",
            "old_dentry->d_name.len",
            "old_dir",
            "&old_entry_lookup"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1086-1111",
          "snippet": "int ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_inode->i_ctime.tv_nsec"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "old_inode->i_ctime.tv_sec"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_entry",
          "args": [
            "handle",
            "new_dentry",
            "old_inode",
            "OCFS2_I(old_inode)->ip_blkno",
            "new_dir_bh",
            "&target_insert"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
          "lines": "69-78",
          "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_add",
          "args": [
            "osb",
            "handle",
            "new_inode",
            "newfe_bh",
            "orphan_name",
            "&orphan_insert",
            "orphan_dir",
            "false"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2190-2289",
          "snippet": "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_links_count",
          "args": [
            "newfe",
            "-1"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "575-582",
          "snippet": "static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2154-2185",
          "snippet": "int ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_rename_credits(osb->sb)"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rename_credits",
          "args": [
            "osb->sb"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rename_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "483-486",
          "snippet": "static inline int ocfs2_rename_credits(struct super_block *sb)\n{\n\treturn 3 * OCFS2_INODE_UPDATE_CREDITS + 6 + ocfs2_unlink_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_rename_credits(struct super_block *sb)\n{\n\treturn 3 * OCFS2_INODE_UPDATE_CREDITS + 6 + ocfs2_unlink_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "new_dir",
            "new_dir_bh",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "&target_insert"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_for_entry",
          "args": [
            "new_dir",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2046-2067",
          "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_dentry->d_parent->d_inode != new_dir"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_orphan_dir",
          "args": [
            "osb",
            "&orphan_dir",
            "OCFS2_I(new_inode)->ip_blkno",
            "orphan_name",
            "&orphan_insert",
            "false"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2149-2188",
          "snippet": "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rename_over_existing",
          "args": [
            "(unsigned long long)newfe_blkno",
            "newfe_bh",
            "newfe_bh ?\n\t\t     (unsigned long long)newfe_bh->b_blocknr : 0ULL"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remote_dentry_delete",
          "args": [
            "new_dentry"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remote_dentry_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "850-861",
          "snippet": "static int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "new_inode",
            "&newfe_bh",
            "1"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rename_disagree",
          "args": [
            "(unsigned long long)OCFS2_I(new_inode)->ip_blkno",
            "(unsigned long long)newfe_blkno",
            "OCFS2_I(new_inode)->ip_flags"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rename_target_exists",
          "args": [
            "new_dentry->d_name.len",
            "new_dentry->d_name.name"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_files_on_disk",
          "args": [
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "&newfe_blkno",
            "new_dir",
            "&target_lookup_res"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_files_on_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2000-2021",
          "snippet": "int ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "old_dir",
            "old_dentry->d_name.name",
            "old_dentry->d_name.len",
            "&old_de_ino"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_link_max",
          "args": [
            "osb"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_link_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "546-551",
          "snippet": "static inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "old_inode",
            "&old_inode_bh",
            "1",
            "OI_LS_PARENT"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"no old_dir_bh!\\n\""
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_dir_bh"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_double_lock",
          "args": [
            "osb",
            "&old_dir_bh",
            "old_dir",
            "&new_dir_bh",
            "new_dir",
            "1"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1108-1195",
          "snippet": "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);",
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rename_not_permitted",
          "args": [
            "(unsigned long long)old_inode->i_ino",
            "(unsigned long long)new_dir->i_ino"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_if_ancestor",
          "args": [
            "osb",
            "new_dir->i_ino",
            "old_inode->i_ino"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_if_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1045-1102",
          "snippet": "static int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_LOOKUP_TIMES 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define MAX_LOOKUP_TIMES 32\n\nstatic int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rename_lock",
          "args": [
            "osb"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rename_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2597-2613",
          "snippet": "int ocfs2_rename_lock(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rename_lock(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "new_inode"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new_dir"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry",
            "old_dentry->d_name.len",
            "old_dentry->d_name.name",
            "new_dentry->d_name.len",
            "new_dentry->d_name.name"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);\n\nstatic int ocfs2_rename(struct inode *old_dir,\n\t\t\tstruct dentry *old_dentry,\n\t\t\tstruct inode *new_dir,\n\t\t\tstruct dentry *new_dentry)\n{\n\tint status = 0, rename_lock = 0, parents_locked = 0, target_exists = 0;\n\tint old_child_locked = 0, new_child_locked = 0, update_dot_dot = 0;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_dinode *newfe = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *newfe_bh = NULL;\n\tstruct buffer_head *old_inode_bh = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tu64 newfe_blkno, old_de_ino;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *new_dir_bh = NULL;\n\tu32 old_dir_nlink = old_dir->i_nlink;\n\tstruct ocfs2_dinode *old_di;\n\tstruct ocfs2_dir_lookup_result old_inode_dot_dot_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_lookup_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result old_entry_lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_insert = { NULL, };\n\tbool should_add_orphan = false;\n\n\t/* At some point it might be nice to break this function up a\n\t * bit. */\n\n\ttrace_ocfs2_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t   old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t   new_dentry->d_name.len, new_dentry->d_name.name);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\tosb = OCFS2_SB(old_dir->i_sb);\n\n\tif (new_inode) {\n\t\tif (!igrab(new_inode))\n\t\t\tBUG();\n\t}\n\n\t/* Assume a directory hierarchy thusly:\n\t * a/b/c\n\t * a/d\n\t * a,b,c, and d are all directories.\n\t *\n\t * from cwd of 'a' on both nodes:\n\t * node1: mv b/c d\n\t * node2: mv d   b/c\n\t *\n\t * And that's why, just like the VFS, we need a file system\n\t * rename lock. */\n\tif (old_dir != new_dir && S_ISDIR(old_inode->i_mode)) {\n\t\tstatus = ocfs2_rename_lock(osb);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\trename_lock = 1;\n\n\t\t/* here we cannot guarantee the inodes haven't just been\n\t\t * changed, so check if they are nested again */\n\t\tstatus = ocfs2_check_if_ancestor(osb, new_dir->i_ino,\n\t\t\t\told_inode->i_ino);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t} else if (status == 1) {\n\t\t\tstatus = -EPERM;\n\t\t\ttrace_ocfs2_rename_not_permitted(\n\t\t\t\t\t(unsigned long long)old_inode->i_ino,\n\t\t\t\t\t(unsigned long long)new_dir->i_ino);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* if old and new are the same, this'll just do one lock. */\n\tstatus = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t\t   &new_dir_bh, new_dir, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tparents_locked = 1;\n\n\t/* make sure both dirs have bhs\n\t * get an extra ref on old_dir_bh if old==new */\n\tif (!new_dir_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tnew_dir_bh = old_dir_bh;\n\t\t\tget_bh(new_dir_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"no old_dir_bh!\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/*\n\t * Aside from allowing a meta data update, the locking here\n\t * also ensures that the downconvert thread on other nodes\n\t * won't have to concurrently downconvert the inode and the\n\t * dentry locks.\n\t */\n\tstatus = ocfs2_inode_lock_nested(old_inode, &old_inode_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\told_child_locked = 1;\n\n\tstatus = ocfs2_remote_dentry_delete(old_dentry);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tu64 old_inode_parent;\n\n\t\tupdate_dot_dot = 1;\n\t\tstatus = ocfs2_find_files_on_disk(\"..\", 2, &old_inode_parent,\n\t\t\t\t\t\t  old_inode,\n\t\t\t\t\t\t  &old_inode_dot_dot_res);\n\t\tif (status) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (old_inode_parent != OCFS2_I(old_dir)->ip_blkno) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!new_inode && new_dir != old_dir &&\n\t\t    new_dir->i_nlink >= ocfs2_link_max(osb)) {\n\t\t\tstatus = -EMLINK;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de_ino);\n\tif (status) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tif (old_de_ino != OCFS2_I(old_inode)->ip_blkno) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/* check if the target already exists (in which case we need\n\t * to delete it */\n\tstatus = ocfs2_find_files_on_disk(new_dentry->d_name.name,\n\t\t\t\t\t  new_dentry->d_name.len,\n\t\t\t\t\t  &newfe_blkno, new_dir,\n\t\t\t\t\t  &target_lookup_res);\n\t/* The only error we allow here is -ENOENT because the new\n\t * file not existing is perfectly valid. */\n\tif ((status < 0) && (status != -ENOENT)) {\n\t\t/* If we cannot find the file specified we should just */\n\t\t/* return the error... */\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (status == 0)\n\t\ttarget_exists = 1;\n\n\tif (!target_exists && new_inode) {\n\t\t/*\n\t\t * Target was unlinked by another node while we were\n\t\t * waiting to get to ocfs2_rename(). There isn't\n\t\t * anything we can do here to help the situation, so\n\t\t * bubble up the appropriate error.\n\t\t */\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t/* In case we need to overwrite an existing file, we blow it\n\t * away first */\n\tif (target_exists) {\n\t\t/* VFS didn't think there existed an inode here, but\n\t\t * someone else in the cluster must have raced our\n\t\t * rename to create one. Today we error cleanly, in\n\t\t * the future we should consider calling iget to build\n\t\t * a new struct inode for this entry. */\n\t\tif (!new_inode) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_target_exists(new_dentry->d_name.len,\n\t\t\t\t\t\tnew_dentry->d_name.name);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (OCFS2_I(new_inode)->ip_blkno != newfe_blkno) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_disagree(\n\t\t\t     (unsigned long long)OCFS2_I(new_inode)->ip_blkno,\n\t\t\t     (unsigned long long)newfe_blkno,\n\t\t\t     OCFS2_I(new_inode)->ip_flags);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_inode_lock(new_inode, &newfe_bh, 1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tnew_child_locked = 1;\n\n\t\tstatus = ocfs2_remote_dentry_delete(new_dentry);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tnewfe = (struct ocfs2_dinode *) newfe_bh->b_data;\n\n\t\ttrace_ocfs2_rename_over_existing(\n\t\t     (unsigned long long)newfe_blkno, newfe_bh, newfe_bh ?\n\t\t     (unsigned long long)newfe_bh->b_blocknr : 0ULL);\n\n\t\tif (S_ISDIR(new_inode->i_mode) || (new_inode->i_nlink == 1)) {\n\t\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\tOCFS2_I(new_inode)->ip_blkno,\n\t\t\t\t\t\torphan_name, &orphan_insert,\n\t\t\t\t\t\tfalse);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tshould_add_orphan = true;\n\t\t}\n\t} else {\n\t\tBUG_ON(new_dentry->d_parent->d_inode != new_dir);\n\n\t\tstatus = ocfs2_check_dir_for_entry(new_dir,\n\t\t\t\t\t\t   new_dentry->d_name.name,\n\t\t\t\t\t\t   new_dentry->d_name.len);\n\t\tif (status)\n\t\t\tgoto bail;\n\n\t\tstatus = ocfs2_prepare_dir_for_insert(osb, new_dir, new_dir_bh,\n\t\t\t\t\t\t      new_dentry->d_name.name,\n\t\t\t\t\t\t      new_dentry->d_name.len,\n\t\t\t\t\t\t      &target_insert);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (target_exists) {\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\tif (new_inode->i_nlink != 2 ||\n\t\t\t    !ocfs2_empty_dir(new_inode)) {\n\t\t\t\tstatus = -ENOTEMPTY;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(new_inode),\n\t\t\t\t\t\t newfe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* change the dirent to point to the correct inode */\n\t\tstatus = ocfs2_update_entry(new_dir, handle, &target_lookup_res,\n\t\t\t\t\t    old_inode);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tnew_dir->i_version++;\n\n\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\tocfs2_set_links_count(newfe, 0);\n\t\telse\n\t\t\tocfs2_add_links_count(newfe, -1);\n\t\tocfs2_journal_dirty(handle, newfe_bh);\n\t\tif (should_add_orphan) {\n\t\t\tstatus = ocfs2_orphan_add(osb, handle, new_inode,\n\t\t\t\t\tnewfe_bh, orphan_name,\n\t\t\t\t\t&orphan_insert, orphan_dir, false);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if the name was not found in new_dir, add it now */\n\t\tstatus = ocfs2_add_entry(handle, new_dentry, old_inode,\n\t\t\t\t\t OCFS2_I(old_inode)->ip_blkno,\n\t\t\t\t\t new_dir_bh, &target_insert);\n\t}\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(old_inode),\n\t\t\t\t\t old_inode_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status >= 0) {\n\t\told_di = (struct ocfs2_dinode *) old_inode_bh->b_data;\n\n\t\told_di->i_ctime = cpu_to_le64(old_inode->i_ctime.tv_sec);\n\t\told_di->i_ctime_nsec = cpu_to_le32(old_inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(handle, old_inode_bh);\n\t} else\n\t\tmlog_errno(status);\n\n\t/*\n\t * Now that the name has been added to new_dir, remove the old name.\n\t *\n\t * We don't keep any directory entry context around until now\n\t * because the insert might have changed the type of directory\n\t * we're dealing with.\n\t */\n\tstatus = ocfs2_find_entry(old_dentry->d_name.name,\n\t\t\t\t  old_dentry->d_name.len, old_dir,\n\t\t\t\t  &old_entry_lookup);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = ocfs2_delete_entry(handle, old_dir, &old_entry_lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;\n\n\tif (update_dot_dot) {\n\t\tstatus = ocfs2_update_entry(old_inode, handle,\n\t\t\t\t\t    &old_inode_dot_dot_res, new_dir);\n\t\tdrop_nlink(old_dir);\n\t\tif (new_inode) {\n\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\tmark_inode_dirty(old_dir);\n\tocfs2_mark_inode_dirty(handle, old_dir, old_dir_bh);\n\tif (new_inode) {\n\t\tmark_inode_dirty(new_inode);\n\t\tocfs2_mark_inode_dirty(handle, new_inode, newfe_bh);\n\t}\n\n\tif (old_dir != new_dir) {\n\t\t/* Keep the same times on both directories.*/\n\t\tnew_dir->i_ctime = new_dir->i_mtime = old_dir->i_ctime;\n\n\t\t/*\n\t\t * This will also pick up the i_nlink change from the\n\t\t * block above.\n\t\t */\n\t\tocfs2_mark_inode_dirty(handle, new_dir, new_dir_bh);\n\t}\n\n\tif (old_dir_nlink != old_dir->i_nlink) {\n\t\tif (!old_dir_bh) {\n\t\t\tmlog(ML_ERROR, \"need to change nlink for old dir \"\n\t\t\t     \"%llu from %d to %d but bh is NULL!\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(old_dir)->ip_blkno,\n\t\t\t     (int)old_dir_nlink, old_dir->i_nlink);\n\t\t} else {\n\t\t\tstruct ocfs2_dinode *fe;\n\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t INODE_CACHE(old_dir),\n\t\t\t\t\t\t\t old_dir_bh,\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tfe = (struct ocfs2_dinode *) old_dir_bh->b_data;\n\t\t\tocfs2_set_links_count(fe, old_dir->i_nlink);\n\t\t\tocfs2_journal_dirty(handle, old_dir_bh);\n\t\t}\n\t}\n\tocfs2_dentry_move(old_dentry, new_dentry, old_dir, new_dir);\n\tstatus = 0;\nbail:\n\tif (rename_lock)\n\t\tocfs2_rename_unlock(osb);\n\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (parents_locked)\n\t\tocfs2_double_unlock(old_dir, new_dir);\n\n\tif (old_child_locked)\n\t\tocfs2_inode_unlock(old_inode, 1);\n\n\tif (new_child_locked)\n\t\tocfs2_inode_unlock(new_inode, 1);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif (new_inode)\n\t\tsync_mapping_buffers(old_inode->i_mapping);\n\n\tif (new_inode)\n\t\tiput(new_inode);\n\n\tocfs2_free_dir_lookup_result(&target_lookup_res);\n\tocfs2_free_dir_lookup_result(&old_entry_lookup);\n\tocfs2_free_dir_lookup_result(&old_inode_dot_dot_res);\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&target_insert);\n\n\tbrelse(newfe_bh);\n\tbrelse(old_inode_bh);\n\tbrelse(old_dir_bh);\n\tbrelse(new_dir_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_double_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1197-1203",
    "snippet": "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode2",
            "1"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}"
  },
  {
    "function_name": "ocfs2_double_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1108-1195",
    "snippet": "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);",
      "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_double_lock_end",
          "args": [
            "(unsigned long long)OCFS2_I(inode1)->ip_blkno",
            "(unsigned long long)OCFS2_I(inode2)->ip_blkno"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode2"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh2"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode2",
            "1"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "inode1",
            "bh1",
            "1",
            "rename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "inode2",
            "bh2",
            "1",
            "rename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_if_ancestor",
          "args": [
            "osb",
            "oi1->ip_blkno",
            "oi2->ip_blkno"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_if_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1045-1102",
          "snippet": "static int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_LOOKUP_TIMES 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define MAX_LOOKUP_TIMES 32\n\nstatic int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_double_lock",
          "args": [
            "(unsigned long long)oi1->ip_blkno",
            "(unsigned long long)oi2->ip_blkno"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_check_if_ancestor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "1045-1102",
    "snippet": "static int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_LOOKUP_TIMES 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\"",
            "(unsigned long long)src_inode_no",
            "(unsigned long long)dest_inode_no"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "child_inode"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "child_inode",
            "0"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "child_inode",
            "\"..\"",
            "2",
            "&parent_inode_no"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "child_inode",
            "NULL",
            "0"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "child_inode"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "child_inode"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "osb",
            "child_inode_no",
            "0",
            "0"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define MAX_LOOKUP_TIMES 32\n\nstatic int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog(ML_NOTICE, \"max lookup times reached, filesystem \"\n\t\t\t\t\t\"may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "876-1043",
    "snippet": "static int ocfs2_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tint child_locked = 0;\n\tbool is_unlinkable = false;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tu64 blkno;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *parent_node_bh = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\n\ttrace_ocfs2_unlink(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t   (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tdquot_initialize(dir);\n\n\tBUG_ON(dentry->d_parent->d_inode != dir);\n\n\tif (inode == osb->root_inode)\n\t\treturn -EPERM;\n\n\tstatus = ocfs2_inode_lock_nested(dir, &parent_node_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_files_on_disk(dentry->d_name.name,\n\t\t\t\t\t  dentry->d_name.len, &blkno, dir,\n\t\t\t\t\t  &lookup);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (OCFS2_I(inode)->ip_blkno != blkno) {\n\t\tstatus = -ENOENT;\n\n\t\ttrace_ocfs2_unlink_noent(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)blkno,\n\t\t\t\tOCFS2_I(inode)->ip_flags);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tchild_locked = 1;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink != 2 || !ocfs2_empty_dir(inode)) {\n\t\t\tstatus = -ENOTEMPTY;\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remote_dentry_delete(dentry);\n\tif (status < 0) {\n\t\t/* This remote delete should succeed under all normal\n\t\t * circumstances. */\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (ocfs2_inode_is_unlinkable(inode)) {\n\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\t  OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t\t  orphan_name, &orphan_insert,\n\t\t\t\t\t\t  false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tis_unlinkable = true;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_unlink_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/* delete the name from the parent dir */\n\tstatus = ocfs2_delete_entry(handle, dir, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(inode);\n\tdrop_nlink(inode);\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(dir);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_node_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinc_nlink(dir);\n\t\tgoto leave;\n\t}\n\n\tif (is_unlinkable) {\n\t\tstatus = ocfs2_orphan_add(osb, handle, inode, fe_bh,\n\t\t\t\torphan_name, &orphan_insert, orphan_dir, false);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nleave:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (child_locked)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(fe_bh);\n\tbrelse(parent_node_bh);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status && (status != -ENOTEMPTY) && (status != -ENOENT))\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "parent_node_bh"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir->i_mutex"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir",
            "1"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_add",
          "args": [
            "osb",
            "handle",
            "inode",
            "fe_bh",
            "orphan_name",
            "&orphan_insert",
            "orphan_dir",
            "false"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2190-2289",
          "snippet": "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * We're going to journal the change of i_flags and i_orphaned_slot.\n\t * It's safe anyway, though some callers may duplicate the journaling.\n\t * Journaling within the func just make the logic look more\n\t * straightforward.\n\t */\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* we're a cluster, and nlink can change on disk from\n\t * underneath us... */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan\n\t\t * slot.\n\t\t */\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t/* Record which orphan dir our inode now resides\n\t\t * in. delete_inode will use this to determine which orphan\n\t\t * dir to lock. */\n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "dir",
            "parent_node_bh"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "fe_bh"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "fe",
            "inode->i_nlink"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_entry",
          "args": [
            "handle",
            "dir",
            "&lookup"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1414-1427",
          "snippet": "int ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_unlink_credits(osb->sb)"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_credits",
          "args": [
            "osb->sb"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "464-468",
          "snippet": "static inline int ocfs2_unlink_credits(struct super_block *sb)\n{\n\t/* The quota update from ocfs2_link_credits is unused here... */\n\treturn 2 * OCFS2_INODE_UPDATE_CREDITS + 3 + ocfs2_link_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_unlink_credits(struct super_block *sb)\n{\n\t/* The quota update from ocfs2_link_credits is unused here... */\n\treturn 2 * OCFS2_INODE_UPDATE_CREDITS + 3 + ocfs2_link_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_orphan_dir",
          "args": [
            "osb",
            "&orphan_dir",
            "OCFS2_I(inode)->ip_blkno",
            "orphan_name",
            "&orphan_insert",
            "false"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2149-2188",
          "snippet": "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_unlinkable",
          "args": [
            "inode"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_unlinkable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "863-874",
          "snippet": "static inline int ocfs2_inode_is_unlinkable(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink == 2)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (inode->i_nlink == 1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_inode_is_unlinkable(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink == 2)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (inode->i_nlink == 1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remote_dentry_delete",
          "args": [
            "dentry"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remote_dentry_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "850-861",
          "snippet": "static int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_empty_dir",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2154-2185",
          "snippet": "int ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&fe_bh",
            "1"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_unlink_noent",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)blkno",
            "OCFS2_I(inode)->ip_flags"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_files_on_disk",
          "args": [
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&blkno",
            "dir",
            "&lookup"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_files_on_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2000-2021",
          "snippet": "int ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "dir",
            "&parent_node_bh",
            "1",
            "OI_LS_PARENT"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_parent->d_inode != dir"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_unlink",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tint child_locked = 0;\n\tbool is_unlinkable = false;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tu64 blkno;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *parent_node_bh = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\n\ttrace_ocfs2_unlink(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t   (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tdquot_initialize(dir);\n\n\tBUG_ON(dentry->d_parent->d_inode != dir);\n\n\tif (inode == osb->root_inode)\n\t\treturn -EPERM;\n\n\tstatus = ocfs2_inode_lock_nested(dir, &parent_node_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_files_on_disk(dentry->d_name.name,\n\t\t\t\t\t  dentry->d_name.len, &blkno, dir,\n\t\t\t\t\t  &lookup);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (OCFS2_I(inode)->ip_blkno != blkno) {\n\t\tstatus = -ENOENT;\n\n\t\ttrace_ocfs2_unlink_noent(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)blkno,\n\t\t\t\tOCFS2_I(inode)->ip_flags);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tchild_locked = 1;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink != 2 || !ocfs2_empty_dir(inode)) {\n\t\t\tstatus = -ENOTEMPTY;\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remote_dentry_delete(dentry);\n\tif (status < 0) {\n\t\t/* This remote delete should succeed under all normal\n\t\t * circumstances. */\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (ocfs2_inode_is_unlinkable(inode)) {\n\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\t  OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t\t  orphan_name, &orphan_insert,\n\t\t\t\t\t\t  false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tis_unlinkable = true;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_unlink_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/* delete the name from the parent dir */\n\tstatus = ocfs2_delete_entry(handle, dir, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(inode);\n\tdrop_nlink(inode);\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(dir);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_node_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinc_nlink(dir);\n\t\tgoto leave;\n\t}\n\n\tif (is_unlinkable) {\n\t\tstatus = ocfs2_orphan_add(osb, handle, inode, fe_bh,\n\t\t\t\torphan_name, &orphan_insert, orphan_dir, false);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nleave:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (child_locked)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(fe_bh);\n\tbrelse(parent_node_bh);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status && (status != -ENOTEMPTY) && (status != -ENOENT))\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_inode_is_unlinkable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "863-874",
    "snippet": "static inline int ocfs2_inode_is_unlinkable(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink == 2)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (inode->i_nlink == 1)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_inode_is_unlinkable(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink == 2)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (inode->i_nlink == 1)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_remote_dentry_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "850-861",
    "snippet": "static int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dentry_unlock",
          "args": [
            "dentry",
            "1"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2676-2684",
          "snippet": "void ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock",
          "args": [
            "dentry",
            "1"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "378-392",
          "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "687-844",
    "snippet": "static int ocfs2_link(struct dentry *old_dentry,\n\t\t      struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct inode *old_dir = old_dentry->d_parent->d_inode;\n\tint err;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tu64 old_de_ino;\n\n\ttrace_ocfs2_link((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t dentry->d_name.len, dentry->d_name.name);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\tdquot_initialize(dir);\n\n\terr = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t&parent_fe_bh, dir, 0);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\n\t/* make sure both dirs have bhs\n\t * get an extra ref on old_dir_bh if old==new */\n\tif (!parent_fe_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tparent_fe_bh = old_dir_bh;\n\t\t\tget_bh(parent_fe_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"%s: no old_dir_bh!\\n\", osb->uuid_str);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!dir->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\told_dentry->d_name.len, &old_de_ino);\n\tif (err) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check whether another node removed the source inode while we\n\t * were in the vfs.\n\t */\n\tif (old_de_ino != OCFS2_I(inode)->ip_blkno) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len);\n\tif (err)\n\t\tgoto out;\n\n\terr = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len, &lookup);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tif (ocfs2_read_links_count(fe) >= ocfs2_link_max(osb)) {\n\t\terr = -EMLINK;\n\t\tgoto out_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_link_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(err);\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\n\terr = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tinc_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\terr = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t      OCFS2_I(inode)->ip_blkno,\n\t\t\t      parent_fe_bh, &lookup);\n\tif (err) {\n\t\tocfs2_add_links_count(fe, -1);\n\t\tdrop_nlink(inode);\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\terr = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tocfs2_unblock_signals(&oldset);\nout_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_double_unlock(old_dir, dir);\n\n\tbrelse(fe_bh);\n\tbrelse(parent_fe_bh);\n\tbrelse(old_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (err)\n\t\tmlog_errno(err);\n\n\treturn err;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "old_dir_bh"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_double_unlock",
          "args": [
            "old_dir",
            "dir"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_double_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1197-1203",
          "snippet": "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_links_count",
          "args": [
            "fe",
            "-1"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "575-582",
          "snippet": "static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode",
            "OCFS2_I(inode)->ip_blkno",
            "parent_fe_bh",
            "&lookup"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
          "lines": "69-78",
          "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "fe_bh"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "fe",
            "inode->i_nlink"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_link_credits(osb->sb)"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_link_credits",
          "args": [
            "osb->sb"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_link_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "456-460",
          "snippet": "static inline int ocfs2_link_credits(struct super_block *sb)\n{\n\treturn 2*OCFS2_INODE_UPDATE_CREDITS + 4 +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_link_credits(struct super_block *sb)\n{\n\treturn 2*OCFS2_INODE_UPDATE_CREDITS + 4 +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_link_max",
          "args": [
            "osb"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_link_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "546-551",
          "snippet": "static inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "fe"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&fe_bh",
            "1"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "dir",
            "parent_fe_bh",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&lookup"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_for_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2046-2067",
          "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "old_dir",
            "old_dentry->d_name.name",
            "old_dentry->d_name.len",
            "&old_de_ino"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: no old_dir_bh!\\n\"",
            "osb->uuid_str"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "parent_fe_bh"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_double_lock",
          "args": [
            "osb",
            "&old_dir_bh",
            "old_dir",
            "&parent_fe_bh",
            "dir",
            "0"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "1108-1195",
          "snippet": "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);",
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\tstruct buffer_head **tmpbh;\n\tstruct inode *tmpinode;\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t/* we always want to lock the one with the lower lockid first.\n\t * and if they are nested, we lock ancestor first */\n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t/* switch id1 and id2 around */\n\t\t\ttmpbh = bh2;\n\t\t\tbh2 = bh1;\n\t\t\tbh1 = tmpbh;\n\n\t\t\ttmpinode = inode2;\n\t\t\tinode2 = inode1;\n\t\t\tinode1 = tmpinode;\n\t\t}\n\t\t/* lock id2 */\n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* lock id1 */\n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t/*\n\t\t * An error return must mean that no cluster locks\n\t\t * were held on function exit.\n\t\t */\n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)OCFS2_I(inode1)->ip_blkno,\n\t\t\t(unsigned long long)OCFS2_I(inode2)->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_link",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "old_dentry->d_name.len",
            "old_dentry->d_name.name",
            "dentry->d_name.len",
            "dentry->d_name.name"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_link(struct dentry *old_dentry,\n\t\t      struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct inode *old_dir = old_dentry->d_parent->d_inode;\n\tint err;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tu64 old_de_ino;\n\n\ttrace_ocfs2_link((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t dentry->d_name.len, dentry->d_name.name);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\tdquot_initialize(dir);\n\n\terr = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t&parent_fe_bh, dir, 0);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\n\t/* make sure both dirs have bhs\n\t * get an extra ref on old_dir_bh if old==new */\n\tif (!parent_fe_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tparent_fe_bh = old_dir_bh;\n\t\t\tget_bh(parent_fe_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"%s: no old_dir_bh!\\n\", osb->uuid_str);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!dir->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\told_dentry->d_name.len, &old_de_ino);\n\tif (err) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check whether another node removed the source inode while we\n\t * were in the vfs.\n\t */\n\tif (old_de_ino != OCFS2_I(inode)->ip_blkno) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len);\n\tif (err)\n\t\tgoto out;\n\n\terr = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len, &lookup);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tif (ocfs2_read_links_count(fe) >= ocfs2_link_max(osb)) {\n\t\terr = -EMLINK;\n\t\tgoto out_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_link_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(err);\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\n\terr = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tinc_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\terr = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t      OCFS2_I(inode)->ip_blkno,\n\t\t\t      parent_fe_bh, &lookup);\n\tif (err) {\n\t\tocfs2_add_links_count(fe, -1);\n\t\tdrop_nlink(inode);\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\terr = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tocfs2_unblock_signals(&oldset);\nout_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_double_unlock(old_dir, dir);\n\n\tbrelse(fe_bh);\n\tbrelse(parent_fe_bh);\n\tbrelse(old_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (err)\n\t\tmlog_errno(err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ocfs2_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "671-685",
    "snippet": "static int ocfs2_create(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint ret;\n\n\ttrace_ocfs2_create(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(dir, dentry, mode | S_IFREG, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFREG",
            "0"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "235-514",
          "snippet": "static int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_create",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "mode"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_create(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint ret;\n\n\ttrace_ocfs2_create(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(dir, dentry, mode | S_IFREG, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "656-669",
    "snippet": "static int ocfs2_mkdir(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode)\n{\n\tint ret;\n\n\ttrace_ocfs2_mkdir(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR",
            "0"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "235-514",
          "snippet": "static int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mkdir",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "OCFS2_I(dir)->ip_blkno",
            "mode"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mkdir(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode)\n{\n\tint ret;\n\n\ttrace_ocfs2_mkdir(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_mknod_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "628-654",
    "snippet": "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_mknod_locked",
          "args": [
            "dir",
            "inode",
            "dev",
            "new_fe_bh",
            "parent_fe_bh",
            "handle",
            "inode_ac",
            "fe_blkno",
            "suballoc_loc",
            "suballoc_bit"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_mknod_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "516-626",
          "snippet": "static int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_new_inode",
          "args": [
            "handle",
            "dir",
            "parent_fe_bh",
            "inode_ac",
            "&suballoc_loc",
            "&suballoc_bit",
            "&fe_blkno"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2198-2239",
          "snippet": "int ocfs2_claim_new_inode(handle_t *handle,\n\t\t\t  struct inode *dir,\n\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t  u64 *suballoc_loc,\n\t\t\t  u16 *suballoc_bit,\n\t\t\t  u64 *fe_blkno)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   1,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res.sr_bits != 1);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit = res.sr_bit_offset;\n\t*fe_blkno = res.sr_blkno;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_new_inode(handle_t *handle,\n\t\t\t  struct inode *dir,\n\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t  u64 *suballoc_loc,\n\t\t\t  u16 *suballoc_bit,\n\t\t\t  u64 *fe_blkno)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   1,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res.sr_bits != 1);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit = res.sr_bit_offset;\n\t*fe_blkno = res.sr_blkno;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}"
  },
  {
    "function_name": "__ocfs2_mknod_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "516-626",
    "snippet": "static int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*new_fe_bh"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_inode_locks",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1621-1663",
          "snippet": "int ocfs2_create_new_inode_locks(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\tBUG_ON(!ocfs2_inode_is_new(inode));\n\n\tmlog(0, \"Inode %llu\\n\", (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t/* NOTE: That we don't increment any of the holder counts, nor\n\t * do we add anything to a journal handle. Since this is\n\t * supposed to be a new inode which the cluster doesn't know\n\t * about yet, there is no need to.  As far as the LVB handling\n\t * is concerned, this is basically like acquiring an EX lock\n\t * on a resource which has an invalid one -- we'll set it\n\t * valid when we release the EX. */\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We don't want to use DLM_LKF_LOCAL on a meta data lock as they\n\t * don't use a generation in their lock names.\n\t */\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nint ocfs2_create_new_inode_locks(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\tBUG_ON(!ocfs2_inode_is_new(inode));\n\n\tmlog(0, \"Inode %llu\\n\", (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t/* NOTE: That we don't increment any of the holder counts, nor\n\t * do we add anything to a journal handle. Since this is\n\t * supposed to be a new inode which the cluster doesn't know\n\t * about yet, there is no need to.  As far as the LVB handling\n\t * is concerned, this is basically like acquiring an EX lock\n\t * on a resource which has an invalid one -- we'll set it\n\t * valid when we release the EX. */\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We don't want to use DLM_LKF_LOCAL on a meta data lock as they\n\t * don't use a generation in their lock names.\n\t */\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_ci_set_new",
          "args": [
            "osb",
            "INODE_CACHE(inode)"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ci_set_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "149-155",
          "snippet": "static inline void ocfs2_ci_set_new(struct ocfs2_super *osb,\n\t\t\t\t    struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_created_trans = osb->journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_ci_set_new(struct ocfs2_super *osb,\n\t\t\t\t    struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_created_trans = osb->journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_populate_inode",
          "args": [
            "inode",
            "fe",
            "1"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_populate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "265-403",
          "snippet": "void ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "*new_fe_bh"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_inode(osb->sb)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_inode",
          "args": [
            "osb->sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1497-1505",
          "snippet": "static inline int ocfs2_extent_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extent_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_max_inline_data_with_xattr(osb->sb, fe)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_max_inline_data_with_xattr",
          "args": [
            "osb->sb",
            "fe"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_inline_data_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1485-1495",
          "snippet": "static inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_INLINE_XATTR_FL\t(0x0004)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_INLINE_XATTR_FL\t(0x0004)\n\nstatic inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "feat | OCFS2_INLINE_DATA_FL"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "511-516",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->i_dyn_features"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CURRENT_TIME.tv_nsec"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "CURRENT_TIME.tv_sec"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_VALID_FL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fe->i_signature",
            "OCFS2_INODE_SIGNATURE"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "fe",
            "inode->i_nlink"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "huge_encode_dev(dev)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "dev"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode_ac->ac_alloc_slot"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "fe_blkno"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fe",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "*new_fe_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(inode)",
            "*new_fe_bh"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "fe_blkno"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_from_blkno",
          "args": [
            "osb->sb",
            "fe_blkno"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ino_from_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "705-709",
          "snippet": "static inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t*new_fe_bh = NULL;\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\tOCFS2_I(inode)->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(CURRENT_TIME.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(CURRENT_TIME.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t/*\n\t * If supported, directories start with inline data. If inline\n\t * isn't supported, but indexing is, we start them as indexed.\n\t */\n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "235-514",
    "snippet": "static int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_add_entry_failure",
          "args": [
            "osb",
            "dentry",
            "inode"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_add_entry_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "220-233",
          "snippet": "static void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "si.value"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "parent_fe_bh"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode",
            "OCFS2_I(inode)->ip_blkno",
            "parent_fe_bh",
            "&lookup"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
          "lines": "69-78",
          "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_set",
          "args": [
            "handle",
            "inode",
            "new_fe_bh",
            "&si",
            "meta_ac",
            "data_ac"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7299-7310",
          "snippet": "int ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_acl",
          "args": [
            "handle",
            "inode",
            "new_fe_bh",
            "ACL_TYPE_ACCESS",
            "acl",
            "meta_ac",
            "data_ac"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "224-283",
          "snippet": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "parent_fe_bh"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_links_count",
          "args": [
            "dirfe",
            "1"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "575-582",
          "snippet": "static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "parent_fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_new_dir",
          "args": [
            "osb",
            "handle",
            "dir",
            "inode",
            "new_fe_bh",
            "data_ac",
            "meta_ac"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_new_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2603-2623",
          "snippet": "int ocfs2_fill_new_dir(struct ocfs2_super *osb,\n\t\t       handle_t *handle,\n\t\t       struct inode *parent,\n\t\t       struct inode *inode,\n\t\t       struct buffer_head *fe_bh,\n\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t       struct ocfs2_alloc_context *meta_ac)\n\n{\n\tBUG_ON(!ocfs2_supports_inline_data(osb) && data_ac == NULL);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_fill_new_dir_id(osb, handle, parent, inode, fe_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn ocfs2_fill_new_dir_dx(osb, handle, parent, inode, fe_bh,\n\t\t\t\t\t     data_ac, meta_ac);\n\n\treturn ocfs2_fill_new_dir_el(osb, handle, parent, inode, fe_bh,\n\t\t\t\t     data_ac, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_fill_new_dir(struct ocfs2_super *osb,\n\t\t       handle_t *handle,\n\t\t       struct inode *parent,\n\t\t       struct inode *inode,\n\t\t       struct buffer_head *fe_bh,\n\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t       struct ocfs2_alloc_context *meta_ac)\n\n{\n\tBUG_ON(!ocfs2_supports_inline_data(osb) && data_ac == NULL);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_fill_new_dir_id(osb, handle, parent, inode, fe_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn ocfs2_fill_new_dir_dx(osb, handle, parent, inode, fe_bh,\n\t\t\t\t\t     data_ac, meta_ac);\n\n\treturn ocfs2_fill_new_dir_el(osb, handle, parent, inode, fe_bh,\n\t\t\t\t     data_ac, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod_locked",
          "args": [
            "osb",
            "dir",
            "inode",
            "dev",
            "&new_fe_bh",
            "parent_fe_bh",
            "handle",
            "inode_ac"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "628-654",
          "snippet": "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mknod_credits",
          "args": [
            "osb->sb",
            "S_ISDIR(mode)",
            "xattr_credits"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mknod_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "433-443",
          "snippet": "static inline int ocfs2_mknod_credits(struct super_block *sb, int is_dir,\n\t\t\t\t      int xattr_credits)\n{\n\tint dir_credits = OCFS2_DIR_LINK_ADDITIONAL_CREDITS;\n\n\tif (is_dir)\n\t\tdir_credits += ocfs2_add_dir_index_credits(sb);\n\n\treturn 4 + OCFS2_SUBALLOC_ALLOC + dir_credits + xattr_credits +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)",
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_mknod_credits(struct super_block *sb, int is_dir,\n\t\t\t\t      int xattr_credits)\n{\n\tint dir_credits = OCFS2_DIR_LINK_ADDITIONAL_CREDITS;\n\n\tif (is_dir)\n\t\tdir_credits += ocfs2_add_dir_index_credits(sb);\n\n\treturn 4 + OCFS2_SUBALLOC_ALLOC + dir_credits + xattr_credits +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&mode",
            "&default_acl",
            "&acl"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "want_clusters",
            "&data_ac"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "want_meta",
            "&meta_ac"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_indexed_dirs",
          "args": [
            "osb"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_indexed_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "532-537",
          "snippet": "static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "511-516",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_xattr_init",
          "args": [
            "dir",
            "parent_fe_bh",
            "mode",
            "&si",
            "&want_clusters",
            "&xattr_credits",
            "&want_meta"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_xattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "631-711",
          "snippet": "int ocfs2_calc_xattr_init(struct inode *dir,\n\t\t\t  struct buffer_head *dir_bh,\n\t\t\t  umode_t mode,\n\t\t\t  struct ocfs2_security_xattr_info *si,\n\t\t\t  int *want_clusters,\n\t\t\t  int *xattr_credits,\n\t\t\t  int *want_meta)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = 0, a_size = 0, acl_len = 0, new_clusters;\n\n\tif (si->enable)\n\t\ts_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t     si->value_len);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\tacl_len = ocfs2_xattr_get_nolock(dir, dir_bh,\n\t\t\t\t\tOCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT,\n\t\t\t\t\t\"\", NULL, 0);\n\t\tif (acl_len > 0) {\n\t\t\ta_size = ocfs2_xattr_entry_real_size(0, acl_len);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\ta_size <<= 1;\n\t\t} else if (acl_len != 0 && acl_len != -ENODATA) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(s_size + a_size))\n\t\treturn ret;\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * The max space of acl xattr taken inline is\n\t * 80(value) + 16(entry) * 2(if directory) = 192 bytes,\n\t * when blocksize = 512, may reserve one more cluser for\n\t * xattr bucket, otherwise reserve one metadata block\n\t * for them is ok.\n\t * If this is a new directory with inline data,\n\t * we choose to reserve the entire inline area for\n\t * directory contents and force an external xattr block.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    (S_ISDIR(mode) && ocfs2_supports_inline_data(osb)) ||\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\t*want_meta = *want_meta + 1;\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE &&\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_BLOCK(dir)) {\n\t\t*want_clusters += 1;\n\t\t*xattr_credits += ocfs2_blocks_per_xattr_bucket(dir->i_sb);\n\t}\n\n\t/*\n\t * reserve credits and clusters for xattrs which has large value\n\t * and have to be set outside\n\t */\n\tif (si->enable && si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tnew_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\tsi->value_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    acl_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* for directory, it has DEFAULT and ACCESS two types of acls */\n\t\tnew_clusters = (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\tocfs2_clusters_for_bytes(dir->i_sb, acl_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)",
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_calc_xattr_init(struct inode *dir,\n\t\t\t  struct buffer_head *dir_bh,\n\t\t\t  umode_t mode,\n\t\t\t  struct ocfs2_security_xattr_info *si,\n\t\t\t  int *want_clusters,\n\t\t\t  int *xattr_credits,\n\t\t\t  int *want_meta)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = 0, a_size = 0, acl_len = 0, new_clusters;\n\n\tif (si->enable)\n\t\ts_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t     si->value_len);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\tacl_len = ocfs2_xattr_get_nolock(dir, dir_bh,\n\t\t\t\t\tOCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT,\n\t\t\t\t\t\"\", NULL, 0);\n\t\tif (acl_len > 0) {\n\t\t\ta_size = ocfs2_xattr_entry_real_size(0, acl_len);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\ta_size <<= 1;\n\t\t} else if (acl_len != 0 && acl_len != -ENODATA) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(s_size + a_size))\n\t\treturn ret;\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * The max space of acl xattr taken inline is\n\t * 80(value) + 16(entry) * 2(if directory) = 192 bytes,\n\t * when blocksize = 512, may reserve one more cluser for\n\t * xattr bucket, otherwise reserve one metadata block\n\t * for them is ok.\n\t * If this is a new directory with inline data,\n\t * we choose to reserve the entire inline area for\n\t * directory contents and force an external xattr block.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    (S_ISDIR(mode) && ocfs2_supports_inline_data(osb)) ||\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\t*want_meta = *want_meta + 1;\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE &&\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_BLOCK(dir)) {\n\t\t*want_clusters += 1;\n\t\t*xattr_credits += ocfs2_blocks_per_xattr_bucket(dir->i_sb);\n\t}\n\n\t/*\n\t * reserve credits and clusters for xattrs which has large value\n\t * and have to be set outside\n\t */\n\tif (si->enable && si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tnew_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\tsi->value_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    acl_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* for directory, it has DEFAULT and ACCESS two types of acls */\n\t\tnew_clusters = (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\tocfs2_clusters_for_bytes(dir->i_sb, acl_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_get",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name",
            "&si"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7282-7297",
          "snippet": "int ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_init_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "200-218",
          "snippet": "static struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_inode",
          "args": [
            "osb",
            "&inode_ac"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1060-1150",
          "snippet": "int ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dir_for_insert",
          "args": [
            "osb",
            "dir",
            "parent_fe_bh",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&lookup"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4278-4353",
          "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_for_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2046-2067",
          "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "dirfe"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_link_max",
          "args": [
            "osb"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_link_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "546-551",
          "snippet": "static inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dir",
            "&parent_fe_bh",
            "1"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mknod",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long)dev",
            "mode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_mknod(struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tdquot_initialize(dir);\n\n\t/* get our super block */\n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* reserve an inode spot */\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get security xattr */\n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* calculate meta data/clusters for setting security and acl xattr */\n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Reserve a cluster if creating an extent based directory. */\n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t/* Dir indexing requires extra space as well */\n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* Starting to change things, restart is no longer possible. */\n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t/* do the real work now. */\n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tif (default_acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\tif (!status && acl) {\n\t\tstatus = ocfs2_set_acl(handle, inode, new_fe_bh,\n\t\t\t\t       ACL_TYPE_ACCESS, acl,\n\t\t\t\t       meta_ac, data_ac);\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/*\n\t * Do this before adding the entry to the directory. We add\n\t * also set d_op after success so that ->d_iput() will cleanup\n\t * the dentry lock even if ocfs2_add_entry() fails below.\n\t */\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nleave:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t/*\n\t * We should call iput after the i_mutex of the bitmap been\n\t * unlocked in ocfs2_free_alloc_context, or the\n\t * ocfs2_delete_inode will mutex_lock again.\n\t */\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_cleanup_add_entry_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "220-233",
    "snippet": "static void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dl"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dl->dl_count != 1"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&dl->dl_lockres"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "osb",
            "&dl->dl_lockres"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}"
  },
  {
    "function_name": "ocfs2_get_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "200-218",
    "snippet": "static struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"new_inode failed!\\n\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* populate as many fields early on as possible - many of\n\t * these are used by the support functions here and in\n\t * callers. */\n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "ocfs2_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
    "lines": "112-198",
    "snippet": "static struct dentry *ocfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint status;\n\tu64 blkno;\n\tstruct inode *inode = NULL;\n\tstruct dentry *ret;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_lookup(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, 0);\n\n\tif (dentry->d_name.len > OCFS2_MAX_FILENAME_LEN) {\n\t\tret = ERR_PTR(-ENAMETOOLONG);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock_nested(dir, NULL, 0, OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tret = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, dentry->d_name.name,\n\t\t\t\t\t    dentry->d_name.len, &blkno);\n\tif (status < 0)\n\t\tgoto bail_add;\n\n\tinode = ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tret = ERR_PTR(-EACCES);\n\t\tgoto bail_unlock;\n\t}\n\n\toi = OCFS2_I(inode);\n\t/* Clear any orphaned state... If we were able to look up the\n\t * inode from a directory, it certainly can't be orphaned. We\n\t * might have the bad state from a node which intended to\n\t * orphan this inode but crashed before it could commit the\n\t * unlink. */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags &= ~OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\nbail_add:\n\tret = d_splice_alias(inode, dentry);\n\n\tif (inode) {\n\t\t/*\n\t\t * If d_splice_alias() finds a DCACHE_DISCONNECTED\n\t\t * dentry, it will d_move() it on top of ourse. The\n\t\t * return value will indicate this however, so in\n\t\t * those cases, we switch them around for the locking\n\t\t * code.\n\t\t *\n\t\t * NOTE: This dentry already has ->d_op set from\n\t\t * ocfs2_get_parent() and ocfs2_get_dentry()\n\t\t */\n\t\tif (!IS_ERR_OR_NULL(ret))\n\t\t\tdentry = ret;\n\n\t\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tret = ERR_PTR(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t} else\n\t\tocfs2_dentry_attach_gen(dentry);\n\nbail_unlock:\n\t/* Don't drop the cluster lock until *after* the d_add --\n\t * unlink on another node will message us to remove that\n\t * dentry under this lock so otherwise we can race this with\n\t * the downconvert thread and have a stale dentry. */\n\tocfs2_inode_unlock(dir, 0);\n\nbail:\n\n\ttrace_ocfs2_lookup_ret(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_lookup_ret",
          "args": [
            "ret"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "0"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_gen",
          "args": [
            "dentry"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_gen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "42-48",
          "snippet": "void ocfs2_dentry_attach_gen(struct dentry *dentry)\n{\n\tunsigned long gen =\n\t\tOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\tBUG_ON(dentry->d_inode);\n\tdentry->d_fsdata = (void *)gen;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_attach_gen(struct dentry *dentry)\n{\n\tunsigned long gen =\n\t\tOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\tBUG_ON(dentry->d_inode);\n\tdentry->d_fsdata = (void *)gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "ret"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "blkno",
            "0",
            "0"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&blkno"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "dir",
            "NULL",
            "0",
            "OI_LS_PARENT"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_lookup",
          "args": [
            "dir",
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint status;\n\tu64 blkno;\n\tstruct inode *inode = NULL;\n\tstruct dentry *ret;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_lookup(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, 0);\n\n\tif (dentry->d_name.len > OCFS2_MAX_FILENAME_LEN) {\n\t\tret = ERR_PTR(-ENAMETOOLONG);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock_nested(dir, NULL, 0, OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tret = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, dentry->d_name.name,\n\t\t\t\t\t    dentry->d_name.len, &blkno);\n\tif (status < 0)\n\t\tgoto bail_add;\n\n\tinode = ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tret = ERR_PTR(-EACCES);\n\t\tgoto bail_unlock;\n\t}\n\n\toi = OCFS2_I(inode);\n\t/* Clear any orphaned state... If we were able to look up the\n\t * inode from a directory, it certainly can't be orphaned. We\n\t * might have the bad state from a node which intended to\n\t * orphan this inode but crashed before it could commit the\n\t * unlink. */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags &= ~OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\nbail_add:\n\tret = d_splice_alias(inode, dentry);\n\n\tif (inode) {\n\t\t/*\n\t\t * If d_splice_alias() finds a DCACHE_DISCONNECTED\n\t\t * dentry, it will d_move() it on top of ourse. The\n\t\t * return value will indicate this however, so in\n\t\t * those cases, we switch them around for the locking\n\t\t * code.\n\t\t *\n\t\t * NOTE: This dentry already has ->d_op set from\n\t\t * ocfs2_get_parent() and ocfs2_get_dentry()\n\t\t */\n\t\tif (!IS_ERR_OR_NULL(ret))\n\t\t\tdentry = ret;\n\n\t\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tret = ERR_PTR(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t} else\n\t\tocfs2_dentry_attach_gen(dentry);\n\nbail_unlock:\n\t/* Don't drop the cluster lock until *after* the d_add --\n\t * unlink on another node will message us to remove that\n\t * dentry under this lock so otherwise we can race this with\n\t * the downconvert thread and have a stale dentry. */\n\tocfs2_inode_unlock(dir, 0);\n\nbail:\n\n\ttrace_ocfs2_lookup_ret(ret);\n\n\treturn ret;\n}"
  }
]