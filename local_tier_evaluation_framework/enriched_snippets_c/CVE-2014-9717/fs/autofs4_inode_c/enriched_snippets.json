[
  {
    "function_name": "autofs4_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "346-370",
    "snippet": "struct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "autofs4_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "205-344",
    "snippet": "int autofs4_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode * root_inode;\n\tstruct dentry * root;\n\tstruct file * pipe;\n\tint pipefd;\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tint pgrp = 0;\n\tbool pgrp_set = false;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tDPRINTK(\"starting up, sbi = %p\",sbi);\n\n\ts->s_fs_info = sbi;\n\tsbi->magic = AUTOFS_SBI_MAGIC;\n\tsbi->pipefd = -1;\n\tsbi->pipe = NULL;\n\tsbi->catatonic = 1;\n\tsbi->exp_timeout = 0;\n\tsbi->oz_pgrp = NULL;\n\tsbi->sb = s;\n\tsbi->version = 0;\n\tsbi->sub_version = 0;\n\tset_autofs_type_indirect(&sbi->type);\n\tsbi->min_proto = 0;\n\tsbi->max_proto = 0;\n\tmutex_init(&sbi->wq_mutex);\n\tmutex_init(&sbi->pipe_mutex);\n\tspin_lock_init(&sbi->fs_lock);\n\tsbi->queues = NULL;\n\tspin_lock_init(&sbi->lookup_lock);\n\tINIT_LIST_HEAD(&sbi->active_list);\n\tINIT_LIST_HEAD(&sbi->expiring_list);\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = AUTOFS_SUPER_MAGIC;\n\ts->s_op = &autofs4_sops;\n\ts->s_d_op = &autofs4_dentry_operations;\n\ts->s_time_gran = 1;\n\n\t/*\n\t * Get the root inode and dentry, but defer checking for errors.\n\t */\n\tino = autofs4_new_ino(sbi);\n\tif (!ino) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\troot_inode = autofs4_get_inode(s, S_IFDIR | 0755);\n\troot = d_make_root(root_inode);\n\tif (!root)\n\t\tgoto fail_ino;\n\tpipe = NULL;\n\n\troot->d_fsdata = ino;\n\n\t/* Can this call block? */\n\tif (parse_options(data, &pipefd, &root_inode->i_uid, &root_inode->i_gid,\n\t\t\t  &pgrp, &pgrp_set, &sbi->type, &sbi->min_proto,\n\t\t\t  &sbi->max_proto)) {\n\t\tprintk(\"autofs: called with bogus options\\n\");\n\t\tgoto fail_dput;\n\t}\n\n\tif (pgrp_set) {\n\t\tsbi->oz_pgrp = find_get_pid(pgrp);\n\t\tif (!sbi->oz_pgrp) {\n\t\t\tpr_warn(\"autofs: could not find process group %d\\n\",\n\t\t\t\tpgrp);\n\t\t\tgoto fail_dput;\n\t\t}\n\t} else {\n\t\tsbi->oz_pgrp = get_task_pid(current, PIDTYPE_PGID);\n\t}\n\n\tif (autofs_type_trigger(sbi->type))\n\t\t__managed_dentry_set_managed(root);\n\n\troot_inode->i_fop = &autofs4_root_operations;\n\troot_inode->i_op = &autofs4_dir_inode_operations;\n\n\t/* Couldn't this be tested earlier? */\n\tif (sbi->max_proto < AUTOFS_MIN_PROTO_VERSION ||\n\t    sbi->min_proto > AUTOFS_MAX_PROTO_VERSION) {\n\t\tprintk(\"autofs: kernel does not match daemon version \"\n\t\t       \"daemon (%d, %d) kernel (%d, %d)\\n\",\n\t\t\tsbi->min_proto, sbi->max_proto,\n\t\t\tAUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);\n\t\tgoto fail_dput;\n\t}\n\n\t/* Establish highest kernel protocol version */\n\tif (sbi->max_proto > AUTOFS_MAX_PROTO_VERSION)\n\t\tsbi->version = AUTOFS_MAX_PROTO_VERSION;\n\telse\n\t\tsbi->version = sbi->max_proto;\n\tsbi->sub_version = AUTOFS_PROTO_SUBVERSION;\n\n\tDPRINTK(\"pipe fd = %d, pgrp = %u\", pipefd, pid_nr(sbi->oz_pgrp));\n\tpipe = fget(pipefd);\n\n\tif (!pipe) {\n\t\tprintk(\"autofs: could not open pipe file descriptor\\n\");\n\t\tgoto fail_dput;\n\t}\n\tret = autofs_prepare_pipe(pipe);\n\tif (ret < 0)\n\t\tgoto fail_fput;\n\tsbi->pipe = pipe;\n\tsbi->pipefd = pipefd;\n\tsbi->catatonic = 0;\n\n\t/*\n\t * Success! Install the root dentry now to indicate completion.\n\t */\n\ts->s_root = root;\n\treturn 0;\n\t\n\t/*\n\t * Failure ... clean up.\n\t */\nfail_fput:\n\tprintk(\"autofs: pipe file descriptor does not contain proper ops\\n\");\n\tfput(pipe);\n\t/* fall through */\nfail_dput:\n\tdput(root);\n\tgoto fail_free;\nfail_ino:\n\tkfree(ino);\nfail_free:\n\tput_pid(sbi->oz_pgrp);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations autofs4_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.show_options\t= autofs4_show_options,\n\t.evict_inode\t= autofs4_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ino"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "pipe"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"autofs: pipe file descriptor does not contain proper ops\\n\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_prepare_pipe",
          "args": [
            "pipe"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_prepare_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "214-223",
          "snippet": "static inline int autofs_prepare_pipe(struct file *pipe)\n{\n\tif (!pipe->f_op->write)\n\t\treturn -EINVAL;\n\tif (!S_ISFIFO(file_inode(pipe)->i_mode))\n\t\treturn -EINVAL;\n\t/* We want a packet pipe */\n\tpipe->f_flags |= O_DIRECT;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstatic inline int autofs_prepare_pipe(struct file *pipe)\n{\n\tif (!pipe->f_op->write)\n\t\treturn -EINVAL;\n\tif (!S_ISFIFO(file_inode(pipe)->i_mode))\n\t\treturn -EINVAL;\n\t/* We want a packet pipe */\n\tpipe->f_flags |= O_DIRECT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "pipefd"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"pipe fd = %d, pgrp = %u\"",
            "pipefd",
            "pid_nr(sbi->oz_pgrp)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_nr",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__managed_dentry_set_managed",
          "args": [
            "root"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__managed_dentry_set_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "184-187",
          "snippet": "static inline void __managed_dentry_set_managed(struct dentry *dentry)\n{\n\tdentry->d_flags |= (DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void __managed_dentry_set_managed(struct dentry *dentry)\n{\n\tdentry->d_flags |= (DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_pid",
          "args": [
            "current",
            "PIDTYPE_PGID"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"autofs: could not find process group %d\\n\"",
            "pgrp"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pid",
          "args": [
            "pgrp"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "&pipefd",
            "&root_inode->i_uid",
            "&root_inode->i_gid",
            "&pgrp",
            "&pgrp_set",
            "&sbi->type",
            "&sbi->min_proto",
            "&sbi->max_proto"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "129-203",
          "snippet": "static int parse_options(char *options, int *pipefd, kuid_t *uid, kgid_t *gid,\n\t\t\t int *pgrp, bool *pgrp_set, unsigned int *type,\n\t\t\t int *minproto, int *maxproto)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\t*uid = current_uid();\n\t*gid = current_gid();\n\n\t*minproto = AUTOFS_MIN_PROTO_VERSION;\n\t*maxproto = AUTOFS_MAX_PROTO_VERSION;\n\n\t*pipefd = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd:\n\t\t\tif (match_int(args, pipefd))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_pgrp:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*pgrp = option;\n\t\t\t*pgrp_set = true;\n\t\t\tbreak;\n\t\tcase Opt_minproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*minproto = option;\n\t\t\tbreak;\n\t\tcase Opt_maxproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*maxproto = option;\n\t\t\tbreak;\n\t\tcase Opt_indirect:\n\t\t\tset_autofs_type_indirect(type);\n\t\t\tbreak;\n\t\tcase Opt_direct:\n\t\t\tset_autofs_type_direct(type);\n\t\t\tbreak;\n\t\tcase Opt_offset:\n\t\t\tset_autofs_type_offset(type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn (*pipefd < 0);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_fd, \"fd=%u\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_pgrp, \"pgrp=%u\"},\n\t{Opt_minproto, \"minproto=%u\"},\n\t{Opt_maxproto, \"maxproto=%u\"},\n\t{Opt_indirect, \"indirect\"},\n\t{Opt_direct, \"direct\"},\n\t{Opt_offset, \"offset\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_fd, \"fd=%u\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_pgrp, \"pgrp=%u\"},\n\t{Opt_minproto, \"minproto=%u\"},\n\t{Opt_maxproto, \"maxproto=%u\"},\n\t{Opt_indirect, \"indirect\"},\n\t{Opt_direct, \"direct\"},\n\t{Opt_offset, \"offset\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, int *pipefd, kuid_t *uid, kgid_t *gid,\n\t\t\t int *pgrp, bool *pgrp_set, unsigned int *type,\n\t\t\t int *minproto, int *maxproto)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\t*uid = current_uid();\n\t*gid = current_gid();\n\n\t*minproto = AUTOFS_MIN_PROTO_VERSION;\n\t*maxproto = AUTOFS_MAX_PROTO_VERSION;\n\n\t*pipefd = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd:\n\t\t\tif (match_int(args, pipefd))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_pgrp:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*pgrp = option;\n\t\t\t*pgrp_set = true;\n\t\t\tbreak;\n\t\tcase Opt_minproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*minproto = option;\n\t\t\tbreak;\n\t\tcase Opt_maxproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*maxproto = option;\n\t\t\tbreak;\n\t\tcase Opt_indirect:\n\t\t\tset_autofs_type_indirect(type);\n\t\t\tbreak;\n\t\tcase Opt_direct:\n\t\t\tset_autofs_type_direct(type);\n\t\t\tbreak;\n\t\tcase Opt_offset:\n\t\t\tset_autofs_type_offset(type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn (*pipefd < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_inode",
          "args": [
            "s",
            "S_IFDIR | 0755"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "346-370",
          "snippet": "struct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_new_ino",
          "args": [
            "sbi"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_new_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "25-35",
          "snippet": "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->expiring_list"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->active_list"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->pipe_mutex"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_autofs_type_indirect",
          "args": [
            "&sbi->type"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"starting up, sbi = %p\"",
            "sbi"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const struct super_operations autofs4_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.show_options\t= autofs4_show_options,\n\t.evict_inode\t= autofs4_evict_inode,\n};\n\nint autofs4_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode * root_inode;\n\tstruct dentry * root;\n\tstruct file * pipe;\n\tint pipefd;\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tint pgrp = 0;\n\tbool pgrp_set = false;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tDPRINTK(\"starting up, sbi = %p\",sbi);\n\n\ts->s_fs_info = sbi;\n\tsbi->magic = AUTOFS_SBI_MAGIC;\n\tsbi->pipefd = -1;\n\tsbi->pipe = NULL;\n\tsbi->catatonic = 1;\n\tsbi->exp_timeout = 0;\n\tsbi->oz_pgrp = NULL;\n\tsbi->sb = s;\n\tsbi->version = 0;\n\tsbi->sub_version = 0;\n\tset_autofs_type_indirect(&sbi->type);\n\tsbi->min_proto = 0;\n\tsbi->max_proto = 0;\n\tmutex_init(&sbi->wq_mutex);\n\tmutex_init(&sbi->pipe_mutex);\n\tspin_lock_init(&sbi->fs_lock);\n\tsbi->queues = NULL;\n\tspin_lock_init(&sbi->lookup_lock);\n\tINIT_LIST_HEAD(&sbi->active_list);\n\tINIT_LIST_HEAD(&sbi->expiring_list);\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = AUTOFS_SUPER_MAGIC;\n\ts->s_op = &autofs4_sops;\n\ts->s_d_op = &autofs4_dentry_operations;\n\ts->s_time_gran = 1;\n\n\t/*\n\t * Get the root inode and dentry, but defer checking for errors.\n\t */\n\tino = autofs4_new_ino(sbi);\n\tif (!ino) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\troot_inode = autofs4_get_inode(s, S_IFDIR | 0755);\n\troot = d_make_root(root_inode);\n\tif (!root)\n\t\tgoto fail_ino;\n\tpipe = NULL;\n\n\troot->d_fsdata = ino;\n\n\t/* Can this call block? */\n\tif (parse_options(data, &pipefd, &root_inode->i_uid, &root_inode->i_gid,\n\t\t\t  &pgrp, &pgrp_set, &sbi->type, &sbi->min_proto,\n\t\t\t  &sbi->max_proto)) {\n\t\tprintk(\"autofs: called with bogus options\\n\");\n\t\tgoto fail_dput;\n\t}\n\n\tif (pgrp_set) {\n\t\tsbi->oz_pgrp = find_get_pid(pgrp);\n\t\tif (!sbi->oz_pgrp) {\n\t\t\tpr_warn(\"autofs: could not find process group %d\\n\",\n\t\t\t\tpgrp);\n\t\t\tgoto fail_dput;\n\t\t}\n\t} else {\n\t\tsbi->oz_pgrp = get_task_pid(current, PIDTYPE_PGID);\n\t}\n\n\tif (autofs_type_trigger(sbi->type))\n\t\t__managed_dentry_set_managed(root);\n\n\troot_inode->i_fop = &autofs4_root_operations;\n\troot_inode->i_op = &autofs4_dir_inode_operations;\n\n\t/* Couldn't this be tested earlier? */\n\tif (sbi->max_proto < AUTOFS_MIN_PROTO_VERSION ||\n\t    sbi->min_proto > AUTOFS_MAX_PROTO_VERSION) {\n\t\tprintk(\"autofs: kernel does not match daemon version \"\n\t\t       \"daemon (%d, %d) kernel (%d, %d)\\n\",\n\t\t\tsbi->min_proto, sbi->max_proto,\n\t\t\tAUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);\n\t\tgoto fail_dput;\n\t}\n\n\t/* Establish highest kernel protocol version */\n\tif (sbi->max_proto > AUTOFS_MAX_PROTO_VERSION)\n\t\tsbi->version = AUTOFS_MAX_PROTO_VERSION;\n\telse\n\t\tsbi->version = sbi->max_proto;\n\tsbi->sub_version = AUTOFS_PROTO_SUBVERSION;\n\n\tDPRINTK(\"pipe fd = %d, pgrp = %u\", pipefd, pid_nr(sbi->oz_pgrp));\n\tpipe = fget(pipefd);\n\n\tif (!pipe) {\n\t\tprintk(\"autofs: could not open pipe file descriptor\\n\");\n\t\tgoto fail_dput;\n\t}\n\tret = autofs_prepare_pipe(pipe);\n\tif (ret < 0)\n\t\tgoto fail_fput;\n\tsbi->pipe = pipe;\n\tsbi->pipefd = pipefd;\n\tsbi->catatonic = 0;\n\n\t/*\n\t * Success! Install the root dentry now to indicate completion.\n\t */\n\ts->s_root = root;\n\treturn 0;\n\t\n\t/*\n\t * Failure ... clean up.\n\t */\nfail_fput:\n\tprintk(\"autofs: pipe file descriptor does not contain proper ops\\n\");\n\tfput(pipe);\n\t/* fall through */\nfail_dput:\n\tdput(root);\n\tgoto fail_free;\nfail_ino:\n\tkfree(ino);\nfail_free:\n\tput_pid(sbi->oz_pgrp);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "129-203",
    "snippet": "static int parse_options(char *options, int *pipefd, kuid_t *uid, kgid_t *gid,\n\t\t\t int *pgrp, bool *pgrp_set, unsigned int *type,\n\t\t\t int *minproto, int *maxproto)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\t*uid = current_uid();\n\t*gid = current_gid();\n\n\t*minproto = AUTOFS_MIN_PROTO_VERSION;\n\t*maxproto = AUTOFS_MAX_PROTO_VERSION;\n\n\t*pipefd = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd:\n\t\t\tif (match_int(args, pipefd))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_pgrp:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*pgrp = option;\n\t\t\t*pgrp_set = true;\n\t\t\tbreak;\n\t\tcase Opt_minproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*minproto = option;\n\t\t\tbreak;\n\t\tcase Opt_maxproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*maxproto = option;\n\t\t\tbreak;\n\t\tcase Opt_indirect:\n\t\t\tset_autofs_type_indirect(type);\n\t\t\tbreak;\n\t\tcase Opt_direct:\n\t\t\tset_autofs_type_direct(type);\n\t\t\tbreak;\n\t\tcase Opt_offset:\n\t\t\tset_autofs_type_offset(type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn (*pipefd < 0);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_fd, \"fd=%u\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_pgrp, \"pgrp=%u\"},\n\t{Opt_minproto, \"minproto=%u\"},\n\t{Opt_maxproto, \"maxproto=%u\"},\n\t{Opt_indirect, \"indirect\"},\n\t{Opt_direct, \"direct\"},\n\t{Opt_offset, \"offset\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_autofs_type_offset",
          "args": [
            "type"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_autofs_type_direct",
          "args": [
            "type"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_autofs_type_indirect",
          "args": [
            "type"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "*gid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "*uid"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "pipefd"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_fd, \"fd=%u\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_pgrp, \"pgrp=%u\"},\n\t{Opt_minproto, \"minproto=%u\"},\n\t{Opt_maxproto, \"maxproto=%u\"},\n\t{Opt_indirect, \"indirect\"},\n\t{Opt_direct, \"direct\"},\n\t{Opt_offset, \"offset\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, int *pipefd, kuid_t *uid, kgid_t *gid,\n\t\t\t int *pgrp, bool *pgrp_set, unsigned int *type,\n\t\t\t int *minproto, int *maxproto)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\t*uid = current_uid();\n\t*gid = current_gid();\n\n\t*minproto = AUTOFS_MIN_PROTO_VERSION;\n\t*maxproto = AUTOFS_MAX_PROTO_VERSION;\n\n\t*pipefd = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd:\n\t\t\tif (match_int(args, pipefd))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase Opt_pgrp:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*pgrp = option;\n\t\t\t*pgrp_set = true;\n\t\t\tbreak;\n\t\tcase Opt_minproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*minproto = option;\n\t\t\tbreak;\n\t\tcase Opt_maxproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*maxproto = option;\n\t\t\tbreak;\n\t\tcase Opt_indirect:\n\t\t\tset_autofs_type_indirect(type);\n\t\t\tbreak;\n\t\tcase Opt_direct:\n\t\t\tset_autofs_type_direct(type);\n\t\t\tbreak;\n\t\tcase Opt_offset:\n\t\t\tset_autofs_type_offset(type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn (*pipefd < 0);\n}"
  },
  {
    "function_name": "autofs4_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "101-105",
    "snippet": "static void autofs4_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n\tkfree(inode->i_private);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inode->i_private"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void autofs4_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n\tkfree(inode->i_private);\n}"
  },
  {
    "function_name": "autofs4_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "71-99",
    "snippet": "static int autofs4_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct inode *root_inode = root->d_sb->s_root->d_inode;\n\n\tif (!sbi)\n\t\treturn 0;\n\n\tseq_printf(m, \",fd=%d\", sbi->pipefd);\n\tif (!uid_eq(root_inode->i_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\tfrom_kuid_munged(&init_user_ns, root_inode->i_uid));\n\tif (!gid_eq(root_inode->i_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\tfrom_kgid_munged(&init_user_ns, root_inode->i_gid));\n\tseq_printf(m, \",pgrp=%d\", pid_vnr(sbi->oz_pgrp));\n\tseq_printf(m, \",timeout=%lu\", sbi->exp_timeout/HZ);\n\tseq_printf(m, \",minproto=%d\", sbi->min_proto);\n\tseq_printf(m, \",maxproto=%d\", sbi->max_proto);\n\n\tif (autofs_type_offset(sbi->type))\n\t\tseq_printf(m, \",offset\");\n\telse if (autofs_type_direct(sbi->type))\n\t\tseq_printf(m, \",direct\");\n\telse\n\t\tseq_printf(m, \",indirect\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",indirect\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_type_direct",
          "args": [
            "sbi->type"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_offset",
          "args": [
            "sbi->type"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "root_inode->i_gid"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "root_inode->i_gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "root_inode->i_uid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "root_inode->i_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "root->d_sb"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int autofs4_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct inode *root_inode = root->d_sb->s_root->d_inode;\n\n\tif (!sbi)\n\t\treturn 0;\n\n\tseq_printf(m, \",fd=%d\", sbi->pipefd);\n\tif (!uid_eq(root_inode->i_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\tfrom_kuid_munged(&init_user_ns, root_inode->i_uid));\n\tif (!gid_eq(root_inode->i_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\tfrom_kgid_munged(&init_user_ns, root_inode->i_gid));\n\tseq_printf(m, \",pgrp=%d\", pid_vnr(sbi->oz_pgrp));\n\tseq_printf(m, \",timeout=%lu\", sbi->exp_timeout/HZ);\n\tseq_printf(m, \",minproto=%d\", sbi->min_proto);\n\tseq_printf(m, \",maxproto=%d\", sbi->max_proto);\n\n\tif (autofs_type_offset(sbi->type))\n\t\tseq_printf(m, \",offset\");\n\telse if (autofs_type_direct(sbi->type))\n\t\tseq_printf(m, \",direct\");\n\telse\n\t\tseq_printf(m, \",indirect\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "49-69",
    "snippet": "void autofs4_kill_sb(struct super_block *sb)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(sb);\n\n\t/*\n\t * In the event of a failure in get_sb_nodev the superblock\n\t * info is not present so nothing else has been setup, so\n\t * just call kill_anon_super when we are called from\n\t * deactivate_super.\n\t */\n\tif (sbi) {\n\t\t/* Free wait queues, close pipe */\n\t\tautofs4_catatonic_mode(sbi);\n\t\tput_pid(sbi->oz_pgrp);\n\t}\n\n\tDPRINTK(\"shutting down\");\n\tkill_litter_super(sb);\n\tif (sbi)\n\t\tkfree_rcu(sbi, rcu);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "sbi",
            "rcu"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"shutting down\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_catatonic_mode",
          "args": [
            "sbi"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_catatonic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "27-55",
          "snippet": "void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nvoid autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_kill_sb(struct super_block *sb)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(sb);\n\n\t/*\n\t * In the event of a failure in get_sb_nodev the superblock\n\t * info is not present so nothing else has been setup, so\n\t * just call kill_anon_super when we are called from\n\t * deactivate_super.\n\t */\n\tif (sbi) {\n\t\t/* Free wait queues, close pipe */\n\t\tautofs4_catatonic_mode(sbi);\n\t\tput_pid(sbi->oz_pgrp);\n\t}\n\n\tDPRINTK(\"shutting down\");\n\tkill_litter_super(sb);\n\tif (sbi)\n\t\tkfree_rcu(sbi, rcu);\n}"
  },
  {
    "function_name": "autofs4_free_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "44-47",
    "snippet": "void autofs4_free_ino(struct autofs_info *ino)\n{\n\tkfree(ino);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ino"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_free_ino(struct autofs_info *ino)\n{\n\tkfree(ino);\n}"
  },
  {
    "function_name": "autofs4_clean_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "37-42",
    "snippet": "void autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}"
  },
  {
    "function_name": "autofs4_new_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
    "lines": "25-35",
    "snippet": "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include \"autofs_i.h\"",
      "#include <linux/magic.h>",
      "#include <linux/bitops.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ino->expiring"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ino->active"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ino)",
            "GFP_KERNEL"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}"
  }
]