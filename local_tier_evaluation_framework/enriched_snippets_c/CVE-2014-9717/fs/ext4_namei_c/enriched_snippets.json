[
  {
    "function_name": "ext4_rename2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3510-3523",
    "snippet": "static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\n\treturn ext4_rename(old_dir, old_dentry, new_dir, new_dentry, flags);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry",
            "flags"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3510-3523",
          "snippet": "static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\n\treturn ext4_rename(old_dir, old_dentry, new_dir, new_dentry, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext4_cross_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_cross_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3387-3508",
          "snippet": "static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tu8 new_file_type;\n\tint retval;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Other than the special case of overwriting a directory, parents'\n\t * nlink only needs to be modified if this is a cross directory rename.\n\t */\n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\text4_mark_inode_dirty(handle, new.inode);\n\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tu8 new_file_type;\n\tint retval;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Other than the special case of overwriting a directory, parents'\n\t * nlink only needs to be modified if this is a cross directory rename.\n\t */\n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\text4_mark_inode_dirty(handle, new.inode);\n\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\n\treturn ext4_rename(old_dir, old_dentry, new_dir, new_dentry, flags);\n}"
  },
  {
    "function_name": "ext4_cross_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3387-3508",
    "snippet": "static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tu8 new_file_type;\n\tint retval;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Other than the special case of overwriting a directory, parents'\n\t * nlink only needs to be modified if this is a cross directory rename.\n\t */\n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\text4_mark_inode_dirty(handle, new.inode);\n\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new.bh"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dir_count",
          "args": [
            "handle",
            "&new"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dir_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3153-3162",
          "snippet": "static void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(handle, ent->dir);\n\t\telse\n\t\t\text4_inc_count(handle, ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\n\nstatic void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(handle, ent->dir);\n\t\telse\n\t\t\text4_inc_count(handle, ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rename_dir_finish",
          "args": [
            "handle",
            "&new",
            "old.dir->i_ino"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename_dir_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3045-3070",
          "snippet": "static int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "new.inode"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "new.inode"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_setent",
          "args": [
            "handle",
            "&old",
            "new.inode->i_ino",
            "new_file_type"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3072-3102",
          "snippet": "static int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_LINK_MAX",
          "args": [
            "new.dir"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_LINK_MAX",
          "args": [
            "old.dir"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rename_dir_prepare",
          "args": [
            "handle",
            "&new"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename_dir_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3030-3043",
          "snippet": "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new.inode->i_mode"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old.inode->i_mode"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 3440
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new.dir"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old.dir"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "old.dir",
            "EXT4_HT_DIR",
            "(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2)"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "old.dir->i_sb"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "new.de->inode"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new.bh"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new.bh"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "new.dir",
            "&new.dentry->d_name",
            "&new.de",
            "&new.inlined"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old.bh"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old.bh"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new.dir"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tu8 new_file_type;\n\tint retval;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Other than the special case of overwriting a directory, parents'\n\t * nlink only needs to be modified if this is a cross directory rename.\n\t */\n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\text4_mark_inode_dirty(handle, new.inode);\n\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3205-3385",
    "snippet": "static int ext4_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry,\n\t\t       unsigned int flags)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tint force_reread;\n\tint retval;\n\tstruct inode *whiteout = NULL;\n\tint credits;\n\tu8 old_file_type;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new.inode)\n\t\tdquot_initialize(new.inode);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de, NULL);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\tif (new.bh) {\n\t\tif (!new.inode) {\n\t\t\tbrelse(new.bh);\n\t\t\tnew.bh = NULL;\n\t\t}\n\t}\n\tif (new.inode && !test_opt(new.dir->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_alloc_da_blocks(old.inode);\n\n\tcredits = (2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (!(flags & RENAME_WHITEOUT)) {\n\t\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR, credits);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t} else {\n\t\twhiteout = ext4_whiteout_for_rename(&old, credits, &handle);\n\t\tif (IS_ERR(whiteout))\n\t\t\treturn PTR_ERR(whiteout);\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\tif (new.inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir(new.inode))\n\t\t\t\tgoto end_rename;\n\t\t} else {\n\t\t\tretval = -EMLINK;\n\t\t\tif (new.dir != old.dir && EXT4_DIR_LINK_MAX(new.dir))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\t/*\n\t * If we're renaming a file within an inline_data dir and adding or\n\t * setting the new dirent causes a conversion from inline_data to\n\t * extents/blockmap, we need to force the dirent delete code to\n\t * re-read the directory, or else we end up trying to delete a dirent\n\t * from what is now the extent tree root (or a block map).\n\t */\n\tforce_reread = (new.dir->i_ino == old.dir->i_ino &&\n\t\t\text4_test_inode_flag(new.dir, EXT4_INODE_INLINE_DATA));\n\n\told_file_type = old.de->file_type;\n\tif (whiteout) {\n\t\t/*\n\t\t * Do this before adding a new entry, so the old entry is sure\n\t\t * to be still pointing to the valid old entry.\n\t\t */\n\t\tretval = ext4_setent(handle, &old, whiteout->i_ino,\n\t\t\t\t     EXT4_FT_CHRDEV);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t\text4_mark_inode_dirty(handle, whiteout);\n\t}\n\tif (!new.bh) {\n\t\tretval = ext4_add_entry(handle, new.dentry, old.inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tretval = ext4_setent(handle, &new,\n\t\t\t\t     old.inode->i_ino, old_file_type);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (force_reread)\n\t\tforce_reread = !ext4_test_inode_flag(new.dir,\n\t\t\t\t\t\t     EXT4_INODE_INLINE_DATA);\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\n\tif (!whiteout) {\n\t\t/*\n\t\t * ok, that's it\n\t\t */\n\t\text4_rename_delete(handle, &old, force_reread);\n\t}\n\n\tif (new.inode) {\n\t\text4_dec_count(handle, new.inode);\n\t\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\t}\n\told.dir->i_ctime = old.dir->i_mtime = ext4_current_time(old.dir);\n\text4_update_dx_flag(old.dir);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\n\t\text4_dec_count(handle, old.dir);\n\t\tif (new.inode) {\n\t\t\t/* checked empty_dir above, can't have another parent,\n\t\t\t * ext4_dec_count() won't work for many-linked dirs */\n\t\t\tclear_nlink(new.inode);\n\t\t} else {\n\t\t\text4_inc_count(handle, new.dir);\n\t\t\text4_update_dx_flag(new.dir);\n\t\t\text4_mark_inode_dirty(handle, new.dir);\n\t\t}\n\t}\n\text4_mark_inode_dirty(handle, old.dir);\n\tif (new.inode) {\n\t\text4_mark_inode_dirty(handle, new.inode);\n\t\tif (!new.inode->i_nlink)\n\t\t\text4_orphan_add(handle, new.inode);\n\t}\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (whiteout) {\n\t\tif (retval)\n\t\t\tdrop_nlink(whiteout);\n\t\tunlock_new_inode(whiteout);\n\t\tiput(whiteout);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "whiteout"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "whiteout"
          ],
          "line": 3379
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "whiteout"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new.bh"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "new.inode"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "new.inode"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "new.dir"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inc_count",
          "args": [
            "handle",
            "new.dir"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inc_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2172-2183",
          "snippet": "static void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "new.inode"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_dec_count",
          "args": [
            "handle",
            "old.dir"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dec_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2189-2193",
          "snippet": "static void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rename_dir_finish",
          "args": [
            "handle",
            "&old",
            "new.dir->i_ino"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename_dir_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3045-3070",
          "snippet": "static int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "old.dir"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rename_delete",
          "args": [
            "handle",
            "&old",
            "force_reread"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3121-3151",
          "snippet": "static void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t/*\n\t * ent->de could have moved from under us during htree split, so make\n\t * sure that we are deleting the right entry.  We might also be pointing\n\t * to a stale entry in the unused part of ent->bh so just checking inum\n\t * and the name isn't enough.\n\t */\n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning(ent->dir->i_sb,\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\tent->dir->i_ino, ent->dir->i_nlink, retval);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t/*\n\t * ent->de could have moved from under us during htree split, so make\n\t * sure that we are deleting the right entry.  We might also be pointing\n\t * to a stale entry in the unused part of ent->bh so just checking inum\n\t * and the name isn't enough.\n\t */\n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning(ent->dir->i_sb,\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\tent->dir->i_ino, ent->dir->i_nlink, retval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "new.dir",
            "EXT4_INODE_INLINE_DATA"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_setent",
          "args": [
            "handle",
            "&new",
            "old.inode->i_ino",
            "old_file_type"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3072-3102",
          "snippet": "static int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_entry",
          "args": [
            "handle",
            "new.dentry",
            "old.inode"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1864-1938",
          "snippet": "static int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "new.dir",
            "EXT4_INODE_INLINE_DATA"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rename_dir_prepare",
          "args": [
            "handle",
            "&old"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rename_dir_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3030-3043",
          "snippet": "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_LINK_MAX",
          "args": [
            "new.dir"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "new.inode"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2459-2526",
          "snippet": "static int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old.inode->i_mode"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new.dir"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old.dir"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "whiteout"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "whiteout"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_whiteout_for_rename",
          "args": [
            "&old",
            "credits",
            "&handle"
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_whiteout_for_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3164-3195",
          "snippet": "static struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t/*\n\t * for inode block, sb block, group summaries,\n\t * and inode bitmap\n\t */\n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
            "const struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};\n\nstatic struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t/*\n\t * for inode block, sb block, group summaries,\n\t * and inode bitmap\n\t */\n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "old.dir",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "old.dir->i_sb"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_alloc_da_blocks",
          "args": [
            "old.inode"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_da_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2704-2743",
          "snippet": "int ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "new.dir->i_sb",
            "NO_AUTO_DA_ALLOC"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new.bh"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new.bh"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "new.dir",
            "&new.dentry->d_name",
            "&new.de",
            "&new.inlined"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "old.de->inode"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old.bh"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old.bh"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new.inode"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry,\n\t\t       unsigned int flags)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = old_dentry->d_inode,\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = new_dentry->d_inode,\n\t};\n\tint force_reread;\n\tint retval;\n\tstruct inode *whiteout = NULL;\n\tint credits;\n\tu8 old_file_type;\n\n\tdquot_initialize(old.dir);\n\tdquot_initialize(new.dir);\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new.inode)\n\t\tdquot_initialize(new.inode);\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de, NULL);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\tif (new.bh) {\n\t\tif (!new.inode) {\n\t\t\tbrelse(new.bh);\n\t\t\tnew.bh = NULL;\n\t\t}\n\t}\n\tif (new.inode && !test_opt(new.dir->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_alloc_da_blocks(old.inode);\n\n\tcredits = (2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (!(flags & RENAME_WHITEOUT)) {\n\t\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR, credits);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t} else {\n\t\twhiteout = ext4_whiteout_for_rename(&old, credits, &handle);\n\t\tif (IS_ERR(whiteout))\n\t\t\treturn PTR_ERR(whiteout);\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\tif (new.inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir(new.inode))\n\t\t\t\tgoto end_rename;\n\t\t} else {\n\t\t\tretval = -EMLINK;\n\t\t\tif (new.dir != old.dir && EXT4_DIR_LINK_MAX(new.dir))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\t/*\n\t * If we're renaming a file within an inline_data dir and adding or\n\t * setting the new dirent causes a conversion from inline_data to\n\t * extents/blockmap, we need to force the dirent delete code to\n\t * re-read the directory, or else we end up trying to delete a dirent\n\t * from what is now the extent tree root (or a block map).\n\t */\n\tforce_reread = (new.dir->i_ino == old.dir->i_ino &&\n\t\t\text4_test_inode_flag(new.dir, EXT4_INODE_INLINE_DATA));\n\n\told_file_type = old.de->file_type;\n\tif (whiteout) {\n\t\t/*\n\t\t * Do this before adding a new entry, so the old entry is sure\n\t\t * to be still pointing to the valid old entry.\n\t\t */\n\t\tretval = ext4_setent(handle, &old, whiteout->i_ino,\n\t\t\t\t     EXT4_FT_CHRDEV);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t\text4_mark_inode_dirty(handle, whiteout);\n\t}\n\tif (!new.bh) {\n\t\tretval = ext4_add_entry(handle, new.dentry, old.inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tretval = ext4_setent(handle, &new,\n\t\t\t\t     old.inode->i_ino, old_file_type);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (force_reread)\n\t\tforce_reread = !ext4_test_inode_flag(new.dir,\n\t\t\t\t\t\t     EXT4_INODE_INLINE_DATA);\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = ext4_current_time(old.inode);\n\text4_mark_inode_dirty(handle, old.inode);\n\n\tif (!whiteout) {\n\t\t/*\n\t\t * ok, that's it\n\t\t */\n\t\text4_rename_delete(handle, &old, force_reread);\n\t}\n\n\tif (new.inode) {\n\t\text4_dec_count(handle, new.inode);\n\t\tnew.inode->i_ctime = ext4_current_time(new.inode);\n\t}\n\told.dir->i_ctime = old.dir->i_mtime = ext4_current_time(old.dir);\n\text4_update_dx_flag(old.dir);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\n\t\text4_dec_count(handle, old.dir);\n\t\tif (new.inode) {\n\t\t\t/* checked empty_dir above, can't have another parent,\n\t\t\t * ext4_dec_count() won't work for many-linked dirs */\n\t\t\tclear_nlink(new.inode);\n\t\t} else {\n\t\t\text4_inc_count(handle, new.dir);\n\t\t\text4_update_dx_flag(new.dir);\n\t\t\text4_mark_inode_dirty(handle, new.dir);\n\t\t}\n\t}\n\text4_mark_inode_dirty(handle, old.dir);\n\tif (new.inode) {\n\t\text4_mark_inode_dirty(handle, new.inode);\n\t\tif (!new.inode->i_nlink)\n\t\t\text4_orphan_add(handle, new.inode);\n\t}\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (whiteout) {\n\t\tif (retval)\n\t\t\tdrop_nlink(whiteout);\n\t\tunlock_new_inode(whiteout);\n\t\tiput(whiteout);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_whiteout_for_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3164-3195",
    "snippet": "static struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t/*\n\t * for inode block, sb block, group summaries,\n\t * and inode bitmap\n\t */\n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
      "const struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "wh",
            "wh->i_mode",
            "WHITEOUT_DEV"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "ent->dir->i_sb",
            "&retries"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wh"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wh"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "ent->dir",
            "S_IFCHR | WHITEOUT_MODE",
            "&ent->dentry->d_name",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_TRANS_BLOCKS",
          "args": [
            "ent->dir->i_sb"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};\n\nstatic struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t/*\n\t * for inode block, sb block, group summaries,\n\t * and inode bitmap\n\t */\n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}"
  },
  {
    "function_name": "ext4_update_dir_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3153-3162",
    "snippet": "static void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(handle, ent->dir);\n\t\telse\n\t\t\text4_inc_count(handle, ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "ent->dir"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inc_count",
          "args": [
            "handle",
            "ent->dir"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inc_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2172-2183",
          "snippet": "static void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_dec_count",
          "args": [
            "handle",
            "ent->dir"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dec_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2189-2193",
          "snippet": "static void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\n\nstatic void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(handle, ent->dir);\n\t\telse\n\t\t\text4_inc_count(handle, ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}"
  },
  {
    "function_name": "ext4_rename_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3121-3151",
    "snippet": "static void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t/*\n\t * ent->de could have moved from under us during htree split, so make\n\t * sure that we are deleting the right entry.  We might also be pointing\n\t * to a stale entry in the unused part of ent->bh so just checking inum\n\t * and the name isn't enough.\n\t */\n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning(ent->dir->i_sb,\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\tent->dir->i_ino, ent->dir->i_nlink, retval);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "ent->dir->i_sb",
            "\"Deleting old file (%lu), %d, error=%d\"",
            "ent->dir->i_ino",
            "ent->dir->i_nlink",
            "retval"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_delete_entry",
          "args": [
            "handle",
            "ent->dir",
            "&ent->dentry->d_name"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "3104-3119",
          "snippet": "static int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_delete_entry",
          "args": [
            "handle",
            "ent->dir",
            "ent->de",
            "ent->bh"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2127-2166",
          "snippet": "static int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ent->de->name",
            "ent->dentry->d_name.name",
            "ent->de->name_len"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ent->de->inode"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t/*\n\t * ent->de could have moved from under us during htree split, so make\n\t * sure that we are deleting the right entry.  We might also be pointing\n\t * to a stale entry in the unused part of ent->bh so just checking inum\n\t * and the name isn't enough.\n\t */\n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning(ent->dir->i_sb,\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\tent->dir->i_ino, ent->dir->i_nlink, retval);\n\t}\n}"
  },
  {
    "function_name": "ext4_find_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3104-3119",
    "snippet": "static int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_delete_entry",
          "args": [
            "handle",
            "dir",
            "de",
            "bh"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2127-2166",
          "snippet": "static int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "dir",
            "d_name",
            "&de",
            "NULL"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_setent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3072-3102",
    "snippet": "static int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ent->bh"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "ent->dir->i_sb",
            "retval"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "ent->dir",
            "ent->bh"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "ent->bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "ent->dir"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "ent->dir"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "ent->dir->i_sb",
            "EXT4_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ino"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "ent->bh"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "ent->bh",
            "\"get write access\""
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(ent->dir->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tent->de->file_type = file_type;\n\tent->dir->i_version++;\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\text4_current_time(ent->dir);\n\text4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t       ent->dir, ent->bh);\n\t\tif (unlikely(retval)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_rename_dir_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3045-3070",
    "snippet": "static int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "ent->dir->i_sb",
            "retval"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "ent->inode"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "ent->inode",
            "ent->dir_bh"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dx_node",
          "args": [
            "handle",
            "ent->inode",
            "ent->dir_bh"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dx_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "485-491",
          "snippet": "static inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "ent->inode"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "ent->dir_bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir_ino"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirent_node(handle,\n\t\t\t\t\t\t\t       ent->inode,\n\t\t\t\t\t\t\t       ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_rename_dir_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "3030-3043",
    "snippet": "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "ent->dir_bh"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "ent->dir_bh",
            "\"get_write_access\""
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ent->parent_de->inode"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_first_dir_block",
          "args": [
            "handle",
            "ent->inode",
            "&retval",
            "&ent->parent_de",
            "&ent->dir_inlined"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_first_dir_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2988-3010",
          "snippet": "static struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = ext4_next_entry(\n\t\t\t\t\t(struct ext4_dir_entry_2 *)bh->b_data,\n\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = ext4_next_entry(\n\t\t\t\t\t(struct ext4_dir_entry_2 *)bh->b_data,\n\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EIO;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}"
  },
  {
    "function_name": "ext4_get_first_dir_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2988-3010",
    "snippet": "static struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = ext4_next_entry(\n\t\t\t\t\t(struct ext4_dir_entry_2 *)bh->b_data,\n\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_first_inline_block",
          "args": [
            "inode",
            "parent_de",
            "retval"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_first_inline_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1554-1567",
          "snippet": "struct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval)\n{\n\tstruct ext4_iloc iloc;\n\n\t*retval = ext4_get_inode_loc(inode, &iloc);\n\tif (*retval)\n\t\treturn NULL;\n\n\t*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\n\treturn iloc.bh;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstruct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval)\n{\n\tstruct ext4_iloc iloc;\n\n\t*retval = ext4_get_inode_loc(inode, &iloc);\n\tif (*retval)\n\t\treturn NULL;\n\n\t*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\n\treturn iloc.bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "(struct ext4_dir_entry_2 *)bh->b_data",
            "inode->i_sb->s_blocksize"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "inode",
            "0",
            "EITHER"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = ext4_next_entry(\n\t\t\t\t\t(struct ext4_dir_entry_2 *)bh->b_data,\n\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}"
  },
  {
    "function_name": "ext4_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2937-2980",
    "snippet": "static int ext4_link(struct dentry *old_dentry,\n\t\t     struct inode *dir, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err, retries = 0;\n\n\tif (inode->i_nlink >= EXT4_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t(EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t EXT4_INDEX_EXTRA_TRANS_BLOCKS) + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tinode->i_ctime = ext4_current_time(inode);\n\text4_inc_count(handle, inode);\n\tihold(inode);\n\n\terr = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\t/* this can happen only for tmpfile being\n\t\t * linked the first time\n\t\t */\n\t\tif (inode->i_nlink == 1)\n\t\t\text4_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1864-1938",
          "snippet": "static int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inc_count",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inc_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2172-2183",
          "snippet": "static void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dir",
            "EXT4_HT_DIR",
            "(EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t EXT4_INDEX_EXTRA_TRANS_BLOCKS) + 1"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_link(struct dentry *old_dentry,\n\t\t     struct inode *dir, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err, retries = 0;\n\n\tif (inode->i_nlink >= EXT4_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t(EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t EXT4_INDEX_EXTRA_TRANS_BLOCKS) + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tinode->i_ctime = ext4_current_time(inode);\n\text4_inc_count(handle, inode);\n\tihold(inode);\n\n\terr = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\t/* this can happen only for tmpfile being\n\t\t * linked the first time\n\t\t */\n\t\tif (inode->i_nlink == 1)\n\t\t\text4_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2832-2935",
    "snippet": "static int ext4_symlink(struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint l, err, retries = 0;\n\tint credits;\n\n\tl = strlen(symname)+1;\n\tif (l > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tdquot_initialize(dir);\n\n\tif (l > EXT4_N_BLOCKS * 4) {\n\t\t/*\n\t\t * For non-fast symlinks, we just allocate inode and put it on\n\t\t * orphan list in the first transaction => we need bitmap,\n\t\t * group descriptor, sb, inode block, quota blocks, and\n\t\t * possibly selinux xattr blocks.\n\t\t */\n\t\tcredits = 4 + EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_XATTR_TRANS_BLOCKS;\n\t} else {\n\t\t/*\n\t\t * Fast symlink. We have to add entry to directory\n\t\t * (EXT4_DATA_TRANS_BLOCKS + EXT4_INDEX_EXTRA_TRANS_BLOCKS),\n\t\t * allocate new inode (bitmap, group descriptor, inode block,\n\t\t * quota blocks, sb is already counted in previous macros).\n\t\t */\n\t\tcredits = EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3;\n\t}\nretry:\n\tinode = ext4_new_inode_start_handle(dir, S_IFLNK|S_IRWXUGO,\n\t\t\t\t\t    &dentry->d_name, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tif (l > EXT4_N_BLOCKS * 4) {\n\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\text4_set_aops(inode);\n\t\t/*\n\t\t * We cannot call page_symlink() with transaction started\n\t\t * because it calls into ext4_write_begin() which can wait\n\t\t * for transaction commit if we are running out of space\n\t\t * and thus we deadlock. So we have to stop transaction now\n\t\t * and restart it when symlink contents is written.\n\t\t * \n\t\t * To keep fs consistent in case of crash, we have to put inode\n\t\t * to orphan list in the mean time.\n\t\t */\n\t\tdrop_nlink(inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\terr = __page_symlink(inode, symname, l, 1);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\t/*\n\t\t * Now inode is being linked into dir (EXT4_DATA_TRANS_BLOCKS\n\t\t * + EXT4_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified\n\t\t */\n\t\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\tEXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT4_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\terr = ext4_orphan_del(handle, inode);\n\t\tif (err) {\n\t\t\text4_journal_stop(handle);\n\t\t\tclear_nlink(inode);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t} else {\n\t\t/* clear the extent format for fast symlink */\n\t\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\tmemcpy((char *)&EXT4_I(inode)->i_data, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_add_nondir(handle, dentry, inode);\n\tif (!err && IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_drop_inode:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2196-2210",
          "snippet": "static int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)&EXT4_I(inode)->i_data",
            "symname",
            "l"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dir",
            "EXT4_HT_DIR",
            "EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT4_INDEX_EXTRA_TRANS_BLOCKS + 1"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_symlink",
          "args": [
            "inode",
            "symname",
            "l",
            "1"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "__page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4497-4529",
          "snippet": "int __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_aops",
          "args": [
            "inode"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3187-3206",
          "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "dir",
            "S_IFLNK|S_IRWXUGO",
            "&dentry->d_name",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_symlink(struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint l, err, retries = 0;\n\tint credits;\n\n\tl = strlen(symname)+1;\n\tif (l > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tdquot_initialize(dir);\n\n\tif (l > EXT4_N_BLOCKS * 4) {\n\t\t/*\n\t\t * For non-fast symlinks, we just allocate inode and put it on\n\t\t * orphan list in the first transaction => we need bitmap,\n\t\t * group descriptor, sb, inode block, quota blocks, and\n\t\t * possibly selinux xattr blocks.\n\t\t */\n\t\tcredits = 4 + EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_XATTR_TRANS_BLOCKS;\n\t} else {\n\t\t/*\n\t\t * Fast symlink. We have to add entry to directory\n\t\t * (EXT4_DATA_TRANS_BLOCKS + EXT4_INDEX_EXTRA_TRANS_BLOCKS),\n\t\t * allocate new inode (bitmap, group descriptor, inode block,\n\t\t * quota blocks, sb is already counted in previous macros).\n\t\t */\n\t\tcredits = EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3;\n\t}\nretry:\n\tinode = ext4_new_inode_start_handle(dir, S_IFLNK|S_IRWXUGO,\n\t\t\t\t\t    &dentry->d_name, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tif (l > EXT4_N_BLOCKS * 4) {\n\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\text4_set_aops(inode);\n\t\t/*\n\t\t * We cannot call page_symlink() with transaction started\n\t\t * because it calls into ext4_write_begin() which can wait\n\t\t * for transaction commit if we are running out of space\n\t\t * and thus we deadlock. So we have to stop transaction now\n\t\t * and restart it when symlink contents is written.\n\t\t * \n\t\t * To keep fs consistent in case of crash, we have to put inode\n\t\t * to orphan list in the mean time.\n\t\t */\n\t\tdrop_nlink(inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\terr = __page_symlink(inode, symname, l, 1);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\t/*\n\t\t * Now inode is being linked into dir (EXT4_DATA_TRANS_BLOCKS\n\t\t * + EXT4_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified\n\t\t */\n\t\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\tEXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT4_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\terr = ext4_orphan_del(handle, inode);\n\t\tif (err) {\n\t\t\text4_journal_stop(handle);\n\t\t\tclear_nlink(inode);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t} else {\n\t\t/* clear the extent format for fast symlink */\n\t\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\tmemcpy((char *)&EXT4_I(inode)->i_data, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_add_nondir(handle, dentry, inode);\n\tif (!err && IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_drop_inode:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2768-2830",
    "snippet": "static int ext4_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\ttrace_ext4_unlink_enter(dir, dentry);\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_unlink;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_unlink;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tif (!inode->i_nlink) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"Deleting nonexistent file (%lu), %d\",\n\t\t\t     inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\text4_mark_inode_dirty(handle, dir);\n\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text4_orphan_add(handle, inode);\n\tinode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nend_unlink:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\ttrace_ext4_unlink_exit(dentry, retval);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_unlink_exit",
          "args": [
            "dentry",
            "retval"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_delete_entry",
          "args": [
            "handle",
            "dir",
            "de",
            "bh"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2127-2166",
          "snippet": "static int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"Deleting nonexistent file (%lu), %d\"",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dir",
            "EXT4_HT_DIR",
            "EXT4_DATA_TRANS_BLOCKS(dir->i_sb)"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de",
            "NULL"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_unlink_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\ttrace_ext4_unlink_enter(dir, dentry);\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_unlink;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_unlink;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tif (!inode->i_nlink) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"Deleting nonexistent file (%lu), %d\",\n\t\t\t     inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\text4_mark_inode_dirty(handle, dir);\n\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text4_orphan_add(handle, inode);\n\tinode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nend_unlink:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\ttrace_ext4_unlink_exit(dentry, retval);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2700-2766",
    "snippet": "static int ext4_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\t/* Initialize quotas before so that eventual writes go in\n\t * separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir(inode))\n\t\tgoto end_rmdir;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rmdir;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (!EXT4_DIR_LINK_EMPTY(inode))\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"empty directory has too many links (%d)\",\n\t\t\t     inode->i_nlink);\n\tinode->i_version++;\n\tclear_nlink(inode);\n\t/* There's no need to set i_disksize: the fact that i_nlink is\n\t * zero will ensure that the right thing happens during any\n\t * recovery. */\n\tinode->i_size = 0;\n\text4_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_dec_count(handle, dir);\n\text4_update_dx_flag(dir);\n\text4_mark_inode_dirty(handle, dir);\n\nend_rmdir:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_dec_count",
          "args": [
            "handle",
            "dir"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dec_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2189-2193",
          "snippet": "static void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"empty directory has too many links (%d)\"",
            "inode->i_nlink"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_LINK_EMPTY",
          "args": [
            "inode"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_delete_entry",
          "args": [
            "handle",
            "dir",
            "de",
            "bh"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2127-2166",
          "snippet": "static int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dir",
            "EXT4_HT_DIR",
            "EXT4_DATA_TRANS_BLOCKS(dir->i_sb)"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "inode"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2459-2526",
          "snippet": "static int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de",
            "NULL"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\t/* Initialize quotas before so that eventual writes go in\n\t * separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir(inode))\n\t\tgoto end_rmdir;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rmdir;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (!EXT4_DIR_LINK_EMPTY(inode))\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"empty directory has too many links (%d)\",\n\t\t\t     inode->i_nlink);\n\tinode->i_version++;\n\tclear_nlink(inode);\n\t/* There's no need to set i_disksize: the fact that i_nlink is\n\t * zero will ensure that the right thing happens during any\n\t * recovery. */\n\tinode->i_size = 0;\n\text4_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_dec_count(handle, dir);\n\text4_update_dx_flag(dir);\n\text4_mark_inode_dirty(handle, dir);\n\nend_rmdir:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_orphan_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2621-2698",
    "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "i_prev"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "i_prev",
            "&iloc2"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"orphan inode %lu will point to %u\\n\"",
            "i_prev->i_ino",
            "ino_next"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "prev",
            "structext4_inode_info",
            "i_orphan"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "inode->i_sb"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ino_next"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"superblock will point to %u\\n\"",
            "ino_next"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"remove inode %lu from orphan list\\n\"",
            "inode->i_ino"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
  },
  {
    "function_name": "ext4_orphan_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2540-2615",
    "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"orphan inode %lu will point to %d\\n\"",
            "inode->i_ino",
            "NEXT_ORPHAN(inode)"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"superblock will point to %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&EXT4_I(inode)->i_orphan"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&EXT4_I(inode)->i_orphan",
            "&sbi->s_orphan"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_last_orphan"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&EXT4_I(inode)->i_orphan"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2459-2526",
    "snippet": "static int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "sb->s_blocksize"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "sb->s_blocksize"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "inode",
            "NULL",
            "de",
            "bh",
            "bh->b_data",
            "bh->b_size",
            "offset"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "inode",
            "lblock",
            "EITHER"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"bad directory (dir #%lu) - no `.' or `..'\"",
            "inode->i_ino"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"..\"",
            "de1->name"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "inode",
            "0",
            "EITHER"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"invalid size\""
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty_inline_dir",
          "args": [
            "inode",
            "&has_inline_data"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "empty_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1740-1799",
          "snippet": "int empty_inline_dir(struct inode *dir, int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tint ret = 1;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(dir, \"error %d getting inode %lu block\",\n\t\t\t\t err, dir->i_ino);\n\t\treturn 1;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tif (!le32_to_cpu(de->inode)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"bad inline directory (dir #%lu) - no `..'\",\n\t\t\t     dir->i_ino);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\toffset = EXT4_INLINE_DOTDOT_SIZE;\n\twhile (offset < dir->i_size) {\n\t\tde = ext4_get_inline_entry(dir, &iloc, offset,\n\t\t\t\t\t   &inline_pos, &inline_size);\n\t\tif (ext4_check_dir_entry(dir, NULL, de,\n\t\t\t\t\t iloc.bh, inline_pos,\n\t\t\t\t\t inline_size, offset)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\\n\",\n\t\t\t\t     dir->i_ino, le32_to_cpu(de->inode),\n\t\t\t\t     le16_to_cpu(de->rec_len), de->name_len,\n\t\t\t\t     inline_size);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t}\n\nout:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nint empty_inline_dir(struct inode *dir, int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tint ret = 1;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(dir, \"error %d getting inode %lu block\",\n\t\t\t\t err, dir->i_ino);\n\t\treturn 1;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tif (!le32_to_cpu(de->inode)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"bad inline directory (dir #%lu) - no `..'\",\n\t\t\t     dir->i_ino);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\toffset = EXT4_INLINE_DOTDOT_SIZE;\n\twhile (offset < dir->i_size) {\n\t\tde = ext4_get_inline_entry(dir, &iloc, offset,\n\t\t\t\t\t   &inline_pos, &inline_size);\n\t\tif (ext4_check_dir_entry(dir, NULL, de,\n\t\t\t\t\t iloc.bh, inline_pos,\n\t\t\t\t\t inline_size, offset)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\\n\",\n\t\t\t\t     dir->i_ino, le32_to_cpu(de->inode),\n\t\t\t\t     le16_to_cpu(de->rec_len), de->name_len,\n\t\t\t\t     inline_size);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t}\n\nout:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\n\t\terr = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn 1;\n\t}\n\tbh = ext4_read_dirblock(inode, 0, EITHER);\n\tif (IS_ERR(bh))\n\t\treturn 1;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif ((void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn 1;\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2400-2454",
    "snippet": "static int ext4_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tif (EXT4_DIR_LINK_MAX(dir))\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, S_IFDIR | mode,\n\t\t\t\t\t    &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext4_dir_inode_operations;\n\tinode->i_fop = &ext4_dir_operations;\n\terr = ext4_init_new_dir(handle, dir, inode);\n\tif (err)\n\t\tgoto out_clear_inode;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext4_add_entry(handle, dentry, inode);\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\tunlock_new_inode(inode);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tiput(inode);\n\t\tgoto out_stop;\n\t}\n\text4_inc_count(handle, dir);\n\text4_update_dx_flag(dir);\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
      "const struct inode_operations ext4_dir_inode_operations = {\n\t.create\t\t= ext4_create,\n\t.lookup\t\t= ext4_lookup,\n\t.link\t\t= ext4_link,\n\t.unlink\t\t= ext4_unlink,\n\t.symlink\t= ext4_symlink,\n\t.mkdir\t\t= ext4_mkdir,\n\t.rmdir\t\t= ext4_rmdir,\n\t.mknod\t\t= ext4_mknod,\n\t.tmpfile\t= ext4_tmpfile,\n\t.rename2\t= ext4_rename2,\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n\t.fiemap         = ext4_fiemap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inc_count",
          "args": [
            "handle",
            "dir"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inc_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2172-2183",
          "snippet": "static void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1864-1938",
          "snippet": "static int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_new_dir",
          "args": [
            "handle",
            "dir",
            "inode"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_new_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2356-2398",
          "snippet": "static int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "dir",
            "S_IFDIR | mode",
            "&dentry->d_name",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_LINK_MAX",
          "args": [
            "dir"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext4_dir_inode_operations = {\n\t.create\t\t= ext4_create,\n\t.lookup\t\t= ext4_lookup,\n\t.link\t\t= ext4_link,\n\t.unlink\t\t= ext4_unlink,\n\t.symlink\t= ext4_symlink,\n\t.mkdir\t\t= ext4_mkdir,\n\t.rmdir\t\t= ext4_rmdir,\n\t.mknod\t\t= ext4_mknod,\n\t.tmpfile\t= ext4_tmpfile,\n\t.rename2\t= ext4_rename2,\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n\t.fiemap         = ext4_fiemap,\n};\n\nstatic int ext4_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tif (EXT4_DIR_LINK_MAX(dir))\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, S_IFDIR | mode,\n\t\t\t\t\t    &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext4_dir_inode_operations;\n\tinode->i_fop = &ext4_dir_operations;\n\terr = ext4_init_new_dir(handle, dir, inode);\n\tif (err)\n\t\tgoto out_clear_inode;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext4_add_entry(handle, dentry, inode);\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\tunlock_new_inode(inode);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tiput(inode);\n\t\tgoto out_stop;\n\t}\n\text4_inc_count(handle, dir);\n\text4_update_dx_flag(dir);\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_init_new_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2356-2398",
    "snippet": "static int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir_block"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "dir_block"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "inode",
            "dir_block"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dir_block",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_dirent_tail",
          "args": [
            "t",
            "blocksize"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "276-283",
          "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "dir_block->b_data",
            "blocksize"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_dot_dotdot",
          "args": [
            "inode",
            "de",
            "blocksize",
            "csum_size",
            "dir->i_ino",
            "0"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_dot_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2328-2354",
          "snippet": "struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir_block"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir_block"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_append",
          "args": [
            "handle",
            "inode",
            "&block"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "51-78",
          "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_try_create_inline_dir",
          "args": [
            "handle",
            "dir",
            "inode"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_try_create_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1574-1605",
          "snippet": "int ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * For inline dir, we only save the inode information for the \"..\"\n\t * and create a fake dentry to cover the left space.\n\t */\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * For inline dir, we only save the inode information for the \"..\"\n\t * and create a fake dentry to cover the left space.\n\t */\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "dir->i_sb"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_init_dot_dotdot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2328-2354",
    "snippet": "struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "blocksize"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_de_type",
          "args": [
            "inode->i_sb",
            "de",
            "S_IFDIR"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2695-2700",
          "snippet": "static inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12",
            "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define S_SHIFT 12\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\"..\""
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "EXT4_DIR_REC_LEN(de->name_len)",
            "blocksize"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "parent_ino"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\".\""
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}"
  },
  {
    "function_name": "ext4_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2287-2326",
    "snippet": "static int ext4_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode,\n\t\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR,\n\t\t\tEXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT4_XATTR_TRANS_BLOCKS);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\td_tmpfile(dentry, inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_unlock_inode:\n\text4_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_aops",
          "args": [
            "inode"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3187-3206",
          "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "dir",
            "mode",
            "NULL",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT4_XATTR_TRANS_BLOCKS"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode,\n\t\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR,\n\t\t\tEXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT4_XATTR_TRANS_BLOCKS);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\td_tmpfile(dentry, inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_unlock_inode:\n\text4_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2254-2285",
    "snippet": "static int ext4_mknod(struct inode *dir, struct dentry *dentry,\n\t\t      umode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t\tif (!err && IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
      "const struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2196-2210",
          "snippet": "static int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "dir",
            "mode",
            "&dentry->d_name",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext4_listxattr,\n\t.removexattr\t= generic_removexattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};\n\nstatic int ext4_mknod(struct inode *dir, struct dentry *dentry,\n\t\t      umode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t\tif (!err && IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2220-2252",
    "snippet": "static int ext4_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t\tif (!err && IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2196-2210",
          "snippet": "static int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_aops",
          "args": [
            "inode"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3187-3206",
          "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_new_inode_start_handle",
          "args": [
            "dir",
            "mode",
            "&dentry->d_name",
            "0",
            "NULL",
            "EXT4_HT_DIR",
            "credits"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\tdquot_initialize(dir);\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t\tif (!err && IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2196-2210",
    "snippet": "static int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1864-1938",
          "snippet": "static int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_dec_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2189-2193",
    "snippet": "static void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dec_count(handle_t *handle, struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}"
  },
  {
    "function_name": "ext4_inc_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2172-2183",
    "snippet": "static void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_SET_RO_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_RO_COMPAT_DIR_NLINK"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "inode"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_inc_count(handle_t *handle, struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) && inode->i_nlink > 1) {\n\t\t/* limit is 16-bit i_links_count */\n\t\tif (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {\n\t\t\tset_nlink(inode, 1);\n\t\t\tEXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t\t      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ext4_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2127-2166",
    "snippet": "static int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "dir",
            "bh"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_generic_delete_entry",
          "args": [
            "handle",
            "dir",
            "de_del",
            "bh",
            "bh->b_data",
            "dir->i_sb->s_blocksize",
            "csum_size"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_generic_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2088-2125",
          "snippet": "int ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "dir->i_sb"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_delete_inline_entry",
          "args": [
            "handle",
            "dir",
            "de_del",
            "bh",
            "&has_inline_data"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_delete_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1655-1709",
          "snippet": "int ext4_delete_inline_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\n\t\tEXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t\tinline_size = EXT4_MIN_INLINE_DATA_SIZE -\n\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t} else {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\t\tinline_size = ext4_get_inline_size(dir) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del, bh,\n\t\t\t\t\tinline_start, inline_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\text4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\nout:\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_delete_inline_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\n\t\tEXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t\tinline_size = EXT4_MIN_INLINE_DATA_SIZE -\n\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t} else {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\t\tinline_size = ext4_get_inline_size(dir) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del, bh,\n\t\t\t\t\tinline_start, inline_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\text4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\nout:\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del,\n\t\t\t\t\tbh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_generic_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "2088-2125",
    "snippet": "int ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "blocksize"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "blocksize"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "ext4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize)",
            "blocksize"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "bh->b_data",
            "bh->b_size",
            "i"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "ext4_dx_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1943-2082",
    "snippet": "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head *bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text4_warning(sb, \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block(frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext4_handle_dirty_dx_node(handle, dir, frames[0].bh);\n\t\tif (err) {\n\t\t\text4_std_error(inode->i_sb, err);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err);\ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_release(struct dx_frame *frames);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "783-791",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release(struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_release(struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1675-1726",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "de"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "de"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_split",
          "args": [
            "handle",
            "dir",
            "&bh",
            "frame",
            "&hinfo"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "do_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1503-1608",
          "snippet": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dx_node",
          "args": [
            "handle",
            "dir",
            "frames[0].bh"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dx_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "485-491",
          "snippet": "static inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "entries + 0",
            "newblock"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "513-516",
          "snippet": "static inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "1"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "538-541",
          "snippet": "static inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_limit",
          "args": [
            "entries2",
            "dx_node_limit(dir)"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "543-546",
          "snippet": "static inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_node_limit",
          "args": [
            "dir"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "dx_node_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "558-565",
          "snippet": "static inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) entries2",
            "(char *) entries",
            "icount * sizeof(struct dx_entry)"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\")"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\""
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries)"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_index",
          "args": [
            "\"node\"",
            "((struct dx_node *) bh2->b_data)->entries"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "571-580",
          "snippet": "static void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index(\"node\", frames[1].entries)"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_insert_block",
          "args": [
            "frames + 0",
            "hash2",
            "newblock"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "dx_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1089-1101",
          "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "frame->bh",
            "bh2"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_boot_loader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "96-197",
          "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) entries2",
            "(char *) (entries + icount1)",
            "icount2 * sizeof(struct dx_entry)"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "frames[0].bh"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Split index %i/%i\\n\"",
            "icount1",
            "icount2"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + icount1"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "518-521",
          "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "sb->s_blocksize",
            "sb->s_blocksize"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&node2->fake",
            "0",
            "sizeof(struct fake_dirent)"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh2"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh2"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_append",
          "args": [
            "handle",
            "dir",
            "&newblock"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "51-78",
          "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Directory index full!\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "frames->entries"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "533-536",
          "snippet": "static inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "frames->entries"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries))"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "dx_get_block(frame->at)",
            "DIRENT"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "frame"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frame"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "&dentry->d_name",
            "dir",
            "&hinfo",
            "frames"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "663-781",
          "snippet": "static struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head *bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text4_warning(sb, \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block(frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext4_handle_dirty_dx_node(handle, dir, frames[0].bh);\n\t\tif (err) {\n\t\t\text4_std_error(inode->i_sb, err);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err);\ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1864-1938",
    "snippet": "static int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NEWENTRY"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1675-1726",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_dirent_tail",
          "args": [
            "t",
            "blocksize"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "276-283",
          "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "bh->b_data",
            "blocksize"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "blocksize - csum_size",
            "blocksize"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_append",
          "args": [
            "handle",
            "dir",
            "&block"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "51-78",
          "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_indexed_dir",
          "args": [
            "handle",
            "dentry",
            "inode",
            "bh"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "make_indexed_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1732-1852",
          "snippet": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint\t\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),\n\t\t\t\t\t   blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\tretval = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\n\tde = do_split(handle,dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\tdx_release(frames);\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\treturn retval;\nout_frames:\n\t/*\n\t * Even if the block split failed, we have to properly write\n\t * out all the changes we did so far. Otherwise we can end up\n\t * with corrupted filesystem.\n\t */\n\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint\t\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),\n\t\t\t\t\t   blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\tretval = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\n\tde = do_split(handle,dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\tdx_release(frames);\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\treturn retval;\nout_frames:\n\t/*\n\t * Even if the block split failed, we have to properly write\n\t * out all the changes we did so far. Otherwise we can end up\n\t * with corrupted filesystem.\n\t */\n\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "block",
            "DIRENT"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "dir",
            "EXT4_INODE_INDEX"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dx_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1943-2082",
          "snippet": "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head *bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text4_warning(sb, \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block(frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext4_handle_dirty_dx_node(handle, dir, frames[0].bh);\n\t\tif (err) {\n\t\t\text4_std_error(inode->i_sb, err);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err);\ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head *bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text4_warning(sb, \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block(frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext4_handle_dirty_dx_node(handle, dir, frames[0].bh);\n\t\tif (err) {\n\t\t\text4_std_error(inode->i_sb, err);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err);\ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "dir"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_try_add_inline_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_try_add_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1248-1308",
          "snippet": "int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tint ret, inline_size;\n\tvoid *inline_start;\n\tstruct ext4_iloc iloc;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\tret = ext4_get_inode_loc(dir, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir))\n\t\tgoto out;\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\t EXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\n\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\tinline_start, inline_size);\n\tif (ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* check whether it can be inserted to inline xattr space. */\n\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\tif (!inline_size) {\n\t\t/* Try to use the xattr space.*/\n\t\tret = ext4_update_inline_dir(handle, dir, &iloc);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_size) {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\n\t\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\t\tinline_start, inline_size);\n\n\t\tif (ret != -ENOSPC)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * The inline space is filled up, so create a new block for it.\n\t * As the extent tree will be created, we have to save the inline\n\t * dir first.\n\t */\n\tret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\n\nout:\n\text4_mark_inode_dirty(handle, dir);\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tint ret, inline_size;\n\tvoid *inline_start;\n\tstruct ext4_iloc iloc;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\tret = ext4_get_inode_loc(dir, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir))\n\t\tgoto out;\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\t EXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\n\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\tinline_start, inline_size);\n\tif (ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* check whether it can be inserted to inline xattr space. */\n\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\tif (!inline_size) {\n\t\t/* Try to use the xattr space.*/\n\t\tret = ext4_update_inline_dir(handle, dir, &iloc);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_size) {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\n\t\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\t\tinline_start, inline_size);\n\n\t\tif (ret != -ENOSPC)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * The inline space is filled up, so create a new block for it.\n\t * As the extent tree will be created, we have to save the inline\n\t * dir first.\n\t */\n\tret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\n\nout:\n\text4_mark_inode_dirty(handle, dir);\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tstruct super_block *sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, dentry, inode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\text4_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC) {\n\t\t\tbrelse(bh);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}"
  },
  {
    "function_name": "make_indexed_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1732-1852",
    "snippet": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint\t\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),\n\t\t\t\t\t   blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\tretval = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\n\tde = do_split(handle,dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\tdx_release(frames);\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\treturn retval;\nout_frames:\n\t/*\n\t * Even if the block split failed, we have to properly write\n\t * out all the changes we did so far. Otherwise we can end up\n\t * with corrupted filesystem.\n\t */\n\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_release(struct dx_frame *frames);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "783-791",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release(struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_release(struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1675-1726",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "de"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "de"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_split",
          "args": [
            "handle",
            "dir",
            "&bh",
            "frame",
            "&hinfo"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "do_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1503-1608",
          "snippet": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "dir",
            "bh"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dx_node",
          "args": [
            "handle",
            "dir",
            "frame->bh"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dx_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "485-491",
          "snippet": "static inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "frames",
            "0",
            "sizeof(frames)"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "name",
            "namelen",
            "&hinfo"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_limit",
          "args": [
            "entries",
            "dx_root_limit(dir, sizeof(root->info))"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "543-546",
          "snippet": "static inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_root_limit",
          "args": [
            "dir",
            "sizeof(root->info)"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "dx_root_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "548-556",
          "snippet": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_root_limit(struct inode *dir, unsigned infosize);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_root_limit(struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "1"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "538-541",
          "snippet": "static inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "entries",
            "1"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "513-516",
          "snippet": "static inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->info",
            "0",
            "sizeof(root->info)"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "blocksize - EXT4_DIR_REC_LEN(2)",
            "blocksize"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_dirent_tail",
          "args": [
            "t",
            "blocksize"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "276-283",
          "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "data1",
            "blocksize"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "blocksize"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data1",
            "de",
            "len"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "dir",
            "EXT4_INODE_INDEX"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh2"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh2"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_append",
          "args": [
            "handle",
            "dir",
            "&block"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "51-78",
          "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"invalid rec_len for '..'\""
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "fde->rec_len",
            "blocksize"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "retval"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino)"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Creating index: inode %lu\\n\"",
            "dir->i_ino"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint\t\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),\n\t\t\t\t\t   blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\tretval = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\n\tde = do_split(handle,dir, &bh, frame, &hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\tdx_release(frames);\n\n\tretval = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbrelse(bh);\n\treturn retval;\nout_frames:\n\t/*\n\t * Even if the block split failed, we have to properly write\n\t * out all the changes we did so far. Otherwise we can end up\n\t * with corrupted filesystem.\n\t */\n\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\treturn retval;\n}"
  },
  {
    "function_name": "add_dirent_to_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1675-1726",
    "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "dir",
            "bh"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "dir"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_insert_dentry",
          "args": [
            "inode",
            "de",
            "blocksize",
            "name",
            "namelen"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_insert_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1644-1666",
          "snippet": "void ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_dest_de",
          "args": [
            "dir",
            "inode",
            "bh",
            "bh->b_data",
            "blocksize - csum_size",
            "name",
            "namelen",
            "&de"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_dest_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1610-1642",
          "snippet": "int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode,\n\t\t\t\t\tbh, bh->b_data, blocksize - csum_size,\n\t\t\t\t\tname, namelen, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, name, namelen);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_insert_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1644-1666",
    "snippet": "void ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "name",
            "namelen"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_de_type",
          "args": [
            "inode->i_sb",
            "de",
            "inode->i_mode"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2695-2700",
          "snippet": "static inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12",
            "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define S_SHIFT 12\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "nlen",
            "buf_size"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "buf_size"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}"
  },
  {
    "function_name": "ext4_find_dest_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1610-1642",
    "snippet": "int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "buf_size"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1109-1117",
          "snippet": "static inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "buf",
            "buf_size",
            "offset"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1503-1608",
    "snippet": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index(\"frame\", frame->entries)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_index",
          "args": [
            "\"frame\"",
            "frame->entries"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "571-580",
          "snippet": "static void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dx_node",
          "args": [
            "handle",
            "dir",
            "frame->bh"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dx_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "485-491",
          "snippet": "static inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "dir",
            "bh2"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_insert_block",
          "args": [
            "frame",
            "hash2 + continued",
            "newblock"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "dx_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1089-1101",
          "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "*bh",
            "bh2"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_boot_loader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "96-197",
          "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1)"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_leaf",
          "args": [
            "hinfo",
            "(struct ext4_dir_entry_2 *) data2",
            "blocksize",
            "1"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "589-617",
          "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_dirent_tail",
          "args": [
            "t",
            "blocksize"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "276-283",
          "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "data1",
            "blocksize"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "data2",
            "blocksize"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2",
            "blocksize"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_pack_dirents",
          "args": [
            "data1",
            "blocksize"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "dx_pack_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1477-1496",
          "snippet": "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_move_dirents",
          "args": [
            "data1",
            "data2",
            "map + split",
            "count - split",
            "blocksize"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "dx_move_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1453-1471",
          "snippet": "static struct ext4_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split)"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Split block %lu at %x, %i/%i\\n\"",
            "(unsigned long)dx_get_block(frame->at)",
            "hash2",
            "split",
            "count-split"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_sort_map",
          "args": [
            "map",
            "count"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "dx_sort_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1063-1087",
          "snippet": "static void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t/* Combsort until bubble sort doesn't suck */\n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2) /* 9, 10 -> 11 */\n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t/* Garden variety bubble sort */\n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t/* Combsort until bubble sort doesn't suck */\n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2) /* 9, 10 -> 11 */\n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t/* Garden variety bubble sort */\n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_make_map",
          "args": [
            "(struct ext4_dir_entry_2 *) data1",
            "blocksize",
            "hinfo",
            "map"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "dx_make_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1038-1060",
          "snippet": "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize) {\n\t\tif (de->name_len && de->inode) {\n\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize) {\n\t\tif (de->name_len && de->inode) {\n\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "*bh"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "*bh",
            "\"get_write_access\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh2"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_append",
          "args": [
            "handle",
            "dir",
            "&newblock"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "51-78",
          "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "dir->i_sb"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tstruct ext4_dir_entry_tail *t;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map((struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split, blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(data2, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\n\t\tt = EXT4_DIRENT_TAIL(data1, blocksize);\n\t\tinitialize_dirent_tail(t, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext4_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirent_node(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "dx_pack_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1477-1496",
    "snippet": "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "rec_len",
            "blocksize"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "de",
            "rec_len"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "blocksize"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}"
  },
  {
    "function_name": "dx_move_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1453-1471",
    "snippet": "static struct ext4_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "rec_len",
            "blocksize"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "de",
            "rec_len"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}"
  },
  {
    "function_name": "ext4_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1425-1447",
    "snippet": "struct dentry *ext4_get_parent(struct dentry *child)\n{\n\t__u32 ino;\n\tstatic const struct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct ext4_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext4_find_entry(child->d_inode, &dotdot, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn (struct dentry *) bh;\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext4_valid_inum(child->d_inode->i_sb, ino)) {\n\t\tEXT4_ERROR_INODE(child->d_inode,\n\t\t\t\t \"bad parent inode number: %u\", ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_obtain_alias(ext4_iget_normal(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ext4_iget_normal(child->d_inode->i_sb, ino)"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_iget_normal",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "child->d_inode",
            "\"bad parent inode number: %u\"",
            "ino"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_valid_inum",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1371-1381",
          "snippet": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */",
            "#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */",
            "#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */",
            "#define EXT4_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "child->d_inode",
            "&dotdot",
            "&de",
            "NULL"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct dentry *ext4_get_parent(struct dentry *child)\n{\n\t__u32 ino;\n\tstatic const struct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct ext4_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext4_find_entry(child->d_inode, &dotdot, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn (struct dentry *) bh;\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext4_valid_inum(child->d_inode->i_sb, ino)) {\n\t\tEXT4_ERROR_INODE(child->d_inode,\n\t\t\t\t \"bad parent inode number: %u\", ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_obtain_alias(ext4_iget_normal(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "ext4_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1388-1422",
    "snippet": "static struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct buffer_head *bh;\n\n\tif (dentry->d_name.len > EXT4_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn (struct dentry *) bh;\n\tinode = NULL;\n\tif (bh) {\n\t\t__u32 ino = le32_to_cpu(de->inode);\n\t\tbrelse(bh);\n\t\tif (!ext4_valid_inum(dir->i_sb, ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"bad inode number: %u\", ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tif (unlikely(ino == dir->i_ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"'%pd' linked to parent dir\",\n\t\t\t\t\t dentry);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tinode = ext4_iget_normal(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\t \"deleted inode referenced: %u\",\n\t\t\t\t\t ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"deleted inode referenced: %u\"",
            "ino"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget_normal",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"'%pd' linked to parent dir\"",
            "dentry"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ino == dir->i_ino"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"bad inode number: %u\"",
            "ino"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_valid_inum",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1371-1381",
          "snippet": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */",
            "#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */",
            "#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */",
            "#define EXT4_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de",
            "NULL"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1189-1336",
          "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct buffer_head *bh;\n\n\tif (dentry->d_name.len > EXT4_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn (struct dentry *) bh;\n\tinode = NULL;\n\tif (bh) {\n\t\t__u32 ino = le32_to_cpu(de->inode);\n\t\tbrelse(bh);\n\t\tif (!ext4_valid_inum(dir->i_sb, ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"bad inode number: %u\", ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tif (unlikely(ino == dir->i_ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"'%pd' linked to parent dir\",\n\t\t\t\t\t dentry);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tinode = ext4_iget_normal(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\t \"deleted inode referenced: %u\",\n\t\t\t\t\t ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "ext4_dx_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1338-1386",
    "snippet": "static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct qstr *d_name,\n\t\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n\tframe = dx_probe(d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, d_name,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext4_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning(sb,\n\t\t\t     \"error %d reading index page in directory #%lu\",\n\t\t\t     retval, dir->i_ino);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", d_name->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_release(struct dx_frame *frames);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "783-791",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release(struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_release(struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"%s not found\\n\", d_name->name)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s not found\\n\"",
            "d_name->name"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"error %d reading index page in directory #%lu\"",
            "retval",
            "dir->i_ino"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_htree_next_block",
          "args": [
            "dir",
            "hinfo.hash",
            "frame",
            "frames",
            "NULL"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_next_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "810-865",
          "snippet": "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ERR_BAD_DX_DIR"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_dirblock",
          "args": [
            "bh",
            "dir",
            "d_name",
            "block << EXT4_BLOCK_SIZE_BITS(sb)",
            "res_dir"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1020-1028",
          "snippet": "static inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "block",
            "DIRENT"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frame"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "d_name",
            "dir",
            "&hinfo",
            "frames"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "663-781",
          "snippet": "static struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct qstr *d_name,\n\t\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n\tframe = dx_probe(d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, d_name,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext4_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning(sb,\n\t\t\t     \"error %d reading index page in directory #%lu\",\n\t\t\t     retval, dir->i_ino);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", d_name->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}"
  },
  {
    "function_name": "ext4_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1189-1336",
    "snippet": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
    ],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_use[ra_ptr]"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_dirblock",
          "args": [
            "bh",
            "dir",
            "d_name",
            "block << EXT4_BLOCK_SIZE_BITS(sb)",
            "res_dir"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1020-1028",
          "snippet": "static inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"checksumming directory \"\n\t\t\t\t\t \"block %lu\"",
            "(unsigned long)block"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dirent_csum_verify",
          "args": [
            "dir",
            "(struct ext4_dir_entry *)bh->b_data"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "336-354",
          "snippet": "int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx_internal_node",
          "args": [
            "dir",
            "block",
            "(struct ext4_dir_entry *)bh->b_data"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_internal_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1162-1176",
          "snippet": "static int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"reading directory lblock %lu\"",
            "(unsigned long) block"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "1",
            "&bh"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(bh)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_getblk",
          "args": [
            "NULL",
            "dir",
            "b++",
            "0"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "734-789",
          "snippet": "struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\")"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\""
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dx_find_entry",
          "args": [
            "dir",
            "d_name",
            "res_dir"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1338-1386",
          "snippet": "static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct qstr *d_name,\n\t\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n\tframe = dx_probe(d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, d_name,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext4_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning(sb,\n\t\t\t     \"error %d reading index page in directory #%lu\",\n\t\t\t     retval, dir->i_ino);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", d_name->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct qstr *d_name,\n\t\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n\tframe = dx_probe(d_name, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, d_name,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext4_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning(sb,\n\t\t\t     \"error %d reading index page in directory #%lu\",\n\t\t\t     retval, dir->i_ino);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", d_name->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "dir"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_inline_entry",
          "args": [
            "dir",
            "d_name",
            "res_dir",
            "&has_inline_data"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1607-1653",
          "snippet": "struct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data)\n{\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\tint inline_size;\n\n\tif (ext4_get_inode_loc(dir, &iloc))\n\t\treturn NULL;\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\n\t\tgoto out;\n\n\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\tinline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\n\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\nout:\n\tbrelse(iloc.bh);\n\tiloc.bh = NULL;\nout_find:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\treturn iloc.bh;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstruct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data)\n{\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\tint inline_size;\n\n\tif (ext4_get_inode_loc(dir, &iloc))\n\t\treturn NULL;\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\n\t\tgoto out;\n\n\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\tinline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\n\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\nout:\n\tbrelse(iloc.bh);\n\tiloc.bh = NULL;\nout_find:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\treturn iloc.bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0);\n\t\t\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\t\t\tif (ra_max == 0)\n\t\t\t\t\t\treturn bh;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_dx_internal_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1162-1176",
    "snippet": "static int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "sb->s_blocksize"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "dir"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "search_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1122-1160",
    "snippet": "int search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "dir->i_sb->s_blocksize"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "bh->b_data",
            "bh->b_size",
            "offset"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1109-1117",
          "snippet": "static inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1109-1117",
    "snippet": "static inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->name",
            "len"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_match (int len, const char * const name,\n\t\t\t      struct ext4_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
  },
  {
    "function_name": "dx_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1089-1101",
    "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "count + 1"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "538-541",
          "snippet": "static inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "new",
            "block"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "513-516",
          "snippet": "static inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_hash",
          "args": [
            "new",
            "hash"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "523-526",
          "snippet": "static inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "new + 1",
            "new",
            "(char *)(entries + count) - (char *)(new)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "old < entries + count"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "entries"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "533-536",
          "snippet": "static inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
  },
  {
    "function_name": "dx_sort_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1063-1087",
    "snippet": "static void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t/* Combsort until bubble sort doesn't suck */\n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2) /* 9, 10 -> 11 */\n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t/* Garden variety bubble sort */\n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "*(q+1)",
            "*q"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_boot_loader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "96-197",
          "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t/* Combsort until bubble sort doesn't suck */\n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2) /* 9, 10 -> 11 */\n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t/* Garden variety bubble sort */\n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}"
  },
  {
    "function_name": "dx_make_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1038-1060",
    "snippet": "static int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize) {\n\t\tif (de->name_len && de->inode) {\n\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "blocksize"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "&h"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int dx_make_map(struct ext4_dir_entry_2 *de, unsigned blocksize,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize) {\n\t\tif (de->name_len && de->inode) {\n\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "search_dirblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "1020-1028",
    "snippet": "static inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_dir",
          "args": [
            "bh",
            "bh->b_data",
            "dir->i_sb->s_blocksize",
            "dir",
            "d_name",
            "offset",
            "res_dir"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "search_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1122-1160",
          "snippet": "int search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}"
  },
  {
    "function_name": "ext4_htree_fill_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "927-1018",
    "snippet": "int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = htree_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t\t&hinfo, start_hash,\n\t\t\t\t\t\t\tstart_minor_hash,\n\t\t\t\t\t\t\t&has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_release(struct dx_frame *frames);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "783-791",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release(struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_release(struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\"",
            "count",
            "*next_hash"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_htree_next_block",
          "args": [
            "dir",
            "HASH_NB_ALWAYS",
            "frame",
            "frames",
            "&hashval"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_next_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "810-865",
          "snippet": "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htree_dirblock_to_tree",
          "args": [
            "dir_file",
            "dir",
            "block",
            "&hinfo",
            "start_hash",
            "start_minor_hash"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "htree_dirblock_to_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "873-916",
          "snippet": "static int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_htree_store_dirent",
          "args": [
            "dir_file",
            "2",
            "0",
            "de"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_store_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "388-441",
          "snippet": "int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "dir->i_sb->s_blocksize"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "frame"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frame"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "NULL",
            "dir",
            "&hinfo",
            "frames"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "663-781",
          "snippet": "static struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htree_inlinedir_to_tree",
          "args": [
            "dir_file",
            "dir",
            "0",
            "&hinfo",
            "start_hash",
            "start_minor_hash",
            "&has_inline_data"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "htree_inlinedir_to_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1315-1414",
          "snippet": "int htree_inlinedir_to_tree(struct file *dir_file,\n\t\t\t    struct inode *dir, ext4_lblk_t block,\n\t\t\t    struct dx_hash_info *hinfo,\n\t\t\t    __u32 start_hash, __u32 start_minor_hash,\n\t\t\t    int *has_inline_data)\n{\n\tint err = 0, count = 0;\n\tunsigned int parent_ino;\n\tint pos;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct inode *inode = file_inode(dir_file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tstruct ext4_dir_entry_2 fake;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = 0;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\twhile (pos < inline_size) {\n\t\t/*\n\t\t * As inlined dir doesn't store any information about '.' and\n\t\t * only the inode number of '..' is stored, we have to handle\n\t\t * them differently.\n\t\t */\n\t\tif (pos == 0) {\n\t\t\tfake.inode = cpu_to_le32(inode->i_ino);\n\t\t\tfake.name_len = 1;\n\t\t\tstrcpy(fake.name, \".\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_OFFSET;\n\t\t} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\n\t\t\tfake.inode = cpu_to_le32(parent_ino);\n\t\t\tfake.name_len = 2;\n\t\t\tstrcpy(fake.name, \"..\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_SIZE;\n\t\t} else {\n\t\t\tde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\n\t\t\tpos += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\t\tif (ext4_check_dir_entry(inode, dir_file, de,\n\t\t\t\t\t iloc.bh, dir_buf,\n\t\t\t\t\t inline_size, pos)) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de);\n\t\tif (err) {\n\t\t\tcount = err;\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t}\n\tret = count;\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
            "#define EXT4_INLINE_DOTDOT_OFFSET\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_INLINE_DOTDOT_OFFSET\t2\n\nint htree_inlinedir_to_tree(struct file *dir_file,\n\t\t\t    struct inode *dir, ext4_lblk_t block,\n\t\t\t    struct dx_hash_info *hinfo,\n\t\t\t    __u32 start_hash, __u32 start_minor_hash,\n\t\t\t    int *has_inline_data)\n{\n\tint err = 0, count = 0;\n\tunsigned int parent_ino;\n\tint pos;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct inode *inode = file_inode(dir_file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tstruct ext4_dir_entry_2 fake;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = 0;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\twhile (pos < inline_size) {\n\t\t/*\n\t\t * As inlined dir doesn't store any information about '.' and\n\t\t * only the inode number of '..' is stored, we have to handle\n\t\t * them differently.\n\t\t */\n\t\tif (pos == 0) {\n\t\t\tfake.inode = cpu_to_le32(inode->i_ino);\n\t\t\tfake.name_len = 1;\n\t\t\tstrcpy(fake.name, \".\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_OFFSET;\n\t\t} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\n\t\t\tfake.inode = cpu_to_le32(parent_ino);\n\t\t\tfake.name_len = 2;\n\t\t\tstrcpy(fake.name, \"..\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_SIZE;\n\t\t} else {\n\t\t\tde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\n\t\t\tpos += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\t\tif (ext4_check_dir_entry(inode, dir_file, de,\n\t\t\t\t\t iloc.bh, dir_buf,\n\t\t\t\t\t inline_size, pos)) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de);\n\t\tif (err) {\n\t\t\tcount = err;\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t}\n\tret = count;\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "dir",
            "EXT4_INODE_INDEX"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dir_file"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = htree_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t\t&hinfo, start_hash,\n\t\t\t\t\t\t\tstart_minor_hash,\n\t\t\t\t\t\t\t&has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}"
  },
  {
    "function_name": "htree_dirblock_to_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "873-916",
    "snippet": "static int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_htree_store_dirent",
          "args": [
            "dir_file",
            "hinfo->hash",
            "hinfo->minor_hash",
            "de"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_store_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "388-441",
          "snippet": "int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "hinfo"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "bh->b_data",
            "bh->b_size",
            "(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "dir->i_sb"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "dir->i_sb->s_blocksize"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "0"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "block",
            "DIRENT"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\"",
            "(unsigned long)block"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
  },
  {
    "function_name": "ext4_htree_next_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "810-865",
    "snippet": "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_release(struct dx_frame *frames);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "p->bh"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "dx_get_block(p->at)",
            "INDEX"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "p->at"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "p->at"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "518-521",
          "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "p->entries"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "dx_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "783-791",
    "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_release(struct dx_frame *frames);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "frames[0].bh"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_release(struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
  },
  {
    "function_name": "dx_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "663-781",
    "snippet": "static struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\"",
            "dir->i_ino"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ERR_BAD_DX_DIR"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "frame->bh"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"dx entry: limit != node limit\""
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_node_limit",
          "args": [
            "dir"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "dx_node_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "558-565",
          "snippet": "static inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "entries"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "533-536",
          "snippet": "static inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frame->bh"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "dx_get_block(at)",
            "INDEX"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "at"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at))"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" %x->%u\\n\"",
            "at == entries? 0: dx_get_hash(at)",
            "dx_get_block(at)"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "at"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "518-521",
          "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "at == p - 1"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\",\")"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\",\""
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\".\")"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"dx entry: no count or count > limit\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Look up %x\", hash)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Look up %x\"",
            "hash"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"dx entry: limit != root limit\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_root_limit",
          "args": [
            "dir",
            "root->info.info_length"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "dx_root_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "548-556",
          "snippet": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_root_limit(struct inode *dir, unsigned infosize);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_root_limit(struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"Unimplemented inode hash depth: %#06x\"",
            "root->info.indirect_levels"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"Unimplemented inode hash flags: %#06x\"",
            "root->info.unused_flags"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "d_name->name",
            "d_name->len",
            "hinfo"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"Unrecognised inode hash code %d\"",
            "root->info.hash_version"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frame->bh"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_dirblock",
          "args": [
            "dir",
            "0",
            "INDEX"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ERR_BAD_DX_DIR"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn ret_err;\n}"
  },
  {
    "function_name": "dx_show_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "619-651",
    "snippet": "struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tbh = ext4_bread(NULL,dir, block, 0);\n\t\tif (!bh || IS_ERR(bh))\n\t\t\tcontinue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext4_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\"",
            "levels ? \"\" : \"   \"",
            "names",
            "space/bcount",
            "(space/bcount)*100/blocksize"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_show_leaf",
          "args": [
            "hinfo",
            "(struct ext4_dir_entry_2 *) bh->b_data",
            "blocksize",
            "0"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "589-617",
          "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_show_entries",
          "args": [
            "hinfo",
            "dir",
            "((struct dx_node *) bh->b_data)->entries",
            "levels - 1"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "619-651",
          "snippet": "struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tbh = ext4_bread(NULL,dir, block, 0);\n\t\tif (!bh || IS_ERR(bh))\n\t\t\tcontinue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext4_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "NULL",
            "dir",
            "block",
            "0"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + 1"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "518-521",
          "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "entries"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%i indexed blocks...\\n\"",
            "count"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tbh = ext4_bread(NULL,dir, block, 0);\n\t\tif (!bh || IS_ERR(bh))\n\t\t\tcontinue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext4_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}"
  },
  {
    "function_name": "dx_show_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "589-617",
    "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"(%i)\\n\"",
            "names"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_next_entry",
          "args": [
            "de",
            "size"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "496-501",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\":%x.%u \"",
            "h.hash",
            "(unsigned) ((char *) de - base)"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "&h"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"names: \""
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text4fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
  },
  {
    "function_name": "dx_show_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "571-580",
    "snippet": "static void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%x->%lu \"",
            "i ? dx_get_hash(entries + i) :\n\t\t\t\t0",
            "(unsigned long)dx_get_block(entries + i)"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "entries + i"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "508-511",
          "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + i"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "518-521",
          "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s index \"",
            "label"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "528-531",
          "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index \", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(\"%x->%lu \", i ? dx_get_hash(entries + i) :\n\t\t\t\t0, (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(\"\\n\");\n}"
  },
  {
    "function_name": "dx_node_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "558-565",
    "snippet": "static inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "dir->i_sb"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "0"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
  },
  {
    "function_name": "dx_root_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "548-556",
    "snippet": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_root_limit(struct inode *dir, unsigned infosize);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "dir->i_sb"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_root_limit(struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
  },
  {
    "function_name": "dx_set_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "543-546",
    "snippet": "static inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "value"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
  },
  {
    "function_name": "dx_set_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "538-541",
    "snippet": "static inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "value"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
  },
  {
    "function_name": "dx_get_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "533-536",
    "snippet": "static inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct dx_countlimit *) entries)->limit"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
  },
  {
    "function_name": "dx_get_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "528-531",
    "snippet": "static inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count(struct dx_entry *entries);",
      "static unsigned dx_get_limit(struct dx_entry *entries);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct dx_countlimit *) entries)->count"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
  },
  {
    "function_name": "dx_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "523-526",
    "snippet": "static inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}"
  },
  {
    "function_name": "dx_get_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "518-521",
    "snippet": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->hash"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
  },
  {
    "function_name": "dx_set_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "513-516",
    "snippet": "static inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
      "static void dx_set_count(struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
  },
  {
    "function_name": "dx_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "508-511",
    "snippet": "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
      "static inline unsigned dx_get_hash(struct dx_entry *entry);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->block"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
  },
  {
    "function_name": "ext4_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "496-501",
    "snippet": "static inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "p->rec_len",
            "blocksize"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}"
  },
  {
    "function_name": "ext4_handle_dirty_dx_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "485-491",
    "snippet": "static inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dx_csum_set",
          "args": [
            "inode",
            "(struct ext4_dir_entry *)bh->b_data"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "459-483",
          "snippet": "static void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
  },
  {
    "function_name": "ext4_dx_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "459-483",
    "snippet": "static void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_dx_csum",
          "args": [
            "inode",
            "dirent",
            "count_offset",
            "count",
            "t"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "410-427",
          "snippet": "static __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_no_space_for_csum",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_space_for_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "330-334",
          "snippet": "static void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "c->count"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"dir seems corrupt?  Run e2fsck -D.\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dx_countlimit",
          "args": [
            "inode",
            "dirent",
            "&count_offset"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "get_dx_countlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "382-408",
          "snippet": "static struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}"
  },
  {
    "function_name": "ext4_dx_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "429-457",
    "snippet": "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 1;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 1;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static unsigned dx_node_limit(struct inode *dir);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_dx_csum",
          "args": [
            "inode",
            "dirent",
            "count_offset",
            "count",
            "t"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "410-427",
          "snippet": "static __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_no_space_for_csum",
          "args": [
            "inode"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_space_for_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "330-334",
          "snippet": "static void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "c->count"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"dir seems corrupt?  Run e2fsck -D.\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dx_countlimit",
          "args": [
            "inode",
            "dirent",
            "&count_offset"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "get_dx_countlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "382-408",
          "snippet": "static struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 1;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 1;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_dx_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "410-427",
    "snippet": "static __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "csum"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "csum",
            "(__u8 *)t",
            "sizeof(struct dx_tail)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\t__le32 save_csum;\n\tint size;\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tsave_csum = t->dt_checksum;\n\tt->dt_checksum = 0;\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, sizeof(struct dx_tail));\n\tt->dt_checksum = save_csum;\n\n\treturn cpu_to_le32(csum);\n}"
  },
  {
    "function_name": "get_dx_countlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "382-408",
    "snippet": "static struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dp->rec_len"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}"
  },
  {
    "function_name": "ext4_handle_dirty_dirent_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "374-380",
    "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dirent_csum_set",
          "args": [
            "inode",
            "(struct ext4_dir_entry *)bh->b_data"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "356-372",
          "snippet": "static void ext4_dirent_csum_set(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t   (void *)t - (void *)dirent);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dirent_csum_set(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t   (void *)t - (void *)dirent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
  },
  {
    "function_name": "ext4_dirent_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "356-372",
    "snippet": "static void ext4_dirent_csum_set(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t   (void *)t - (void *)dirent);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_dirent_csum",
          "args": [
            "inode",
            "dirent",
            "(void *)t - (void *)dirent"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "319-328",
          "snippet": "static __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_no_space_for_csum",
          "args": [
            "inode"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_space_for_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "330-334",
          "snippet": "static void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dirent_tail",
          "args": [
            "inode",
            "dirent"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "286-317",
          "snippet": "static struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext4_dirent_csum_set(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t   (void *)t - (void *)dirent);\n}"
  },
  {
    "function_name": "ext4_dirent_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "336-354",
    "snippet": "int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_dirent_csum",
          "args": [
            "inode",
            "dirent",
            "(void *)t - (void *)dirent"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "319-328",
          "snippet": "static __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_no_space_for_csum",
          "args": [
            "inode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_space_for_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "330-334",
          "snippet": "static void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dirent_tail",
          "args": [
            "inode",
            "dirent"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "286-317",
          "snippet": "static struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "warn_no_space_for_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "330-334",
    "snippet": "static void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\"",
            "inode->i_ino"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void warn_no_space_for_csum(struct inode *inode)\n{\n\text4_warning(inode->i_sb, \"no space in directory inode %lu leaf for \"\n\t\t     \"checksum.  Please run e2fsck -D.\", inode->i_ino);\n}"
  },
  {
    "function_name": "ext4_dirent_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "319-328",
    "snippet": "static __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "csum"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "ei->i_csum_seed",
            "(__u8 *)dirent",
            "size"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic __le32 ext4_dirent_csum(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}"
  },
  {
    "function_name": "get_dirent_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "286-317",
    "snippet": "static struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "t->det_rec_len"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "de",
            "EXT4_BLOCK_SIZE(inode->i_sb)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct ext4_dir_entry *de)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = de;\n\ttop = (struct ext4_dir_entry *)(((void *)de) +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\tsizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}"
  },
  {
    "function_name": "initialize_dirent_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "276-283",
    "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
      "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "sizeof(struct ext4_dir_entry_tail)",
            "blocksize"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "t",
            "0",
            "sizeof(struct ext4_dir_entry_tail)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
  },
  {
    "function_name": "__ext4_read_dirblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "90-157",
    "snippet": "static struct buffer_head *__ext4_read_dirblock(struct inode *inode,\n\t\t\t\t\t      ext4_lblk_t block,\n\t\t\t\t\t      dirblock_type_t type,\n\t\t\t\t\t      unsigned int line)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry *dirent;\n\tint is_dx_block = 0;\n\n\tbh = ext4_bread(NULL, inode, block, 0);\n\tif (IS_ERR(bh)) {\n\t\t__ext4_warning(inode->i_sb, __func__, line,\n\t\t\t       \"error %ld reading directory block \"\n\t\t\t       \"(ino %lu, block %lu)\", PTR_ERR(bh), inode->i_ino,\n\t\t\t       (unsigned long) block);\n\n\t\treturn bh;\n\t}\n\tif (!bh) {\n\t\text4_error_inode(inode, __func__, line, block, \"Directory hole found\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tdirent = (struct ext4_dir_entry *) bh->b_data;\n\t/* Determine whether or not we have an index block */\n\tif (is_dx(inode)) {\n\t\tif (block == 0)\n\t\t\tis_dx_block = 1;\n\t\telse if (ext4_rec_len_from_disk(dirent->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize) ==\n\t\t\t inode->i_sb->s_blocksize)\n\t\t\tis_dx_block = 1;\n\t}\n\tif (!is_dx_block && type == INDEX) {\n\t\text4_error_inode(inode, __func__, line, block,\n\t\t       \"directory leaf block found instead of index block\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (!ext4_has_metadata_csum(inode->i_sb) ||\n\t    buffer_verified(bh))\n\t\treturn bh;\n\n\t/*\n\t * An empty leaf block can get mistaken for a index block; for\n\t * this reason, we can only check the index checksum when the\n\t * caller is sure it should be an index block.\n\t */\n\tif (is_dx_block && type == INDEX) {\n\t\tif (ext4_dx_csum_verify(inode, dirent))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode(inode, __func__, line, block,\n\t\t\t\t\"Directory index failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\tif (!is_dx_block) {\n\t\tif (ext4_dirent_csum_verify(inode, dirent))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode(inode, __func__, line, block,\n\t\t\t\t\"Directory block failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "inode",
            "__func__",
            "line",
            "block",
            "\"Directory block failed checksum\""
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dirent_csum_verify",
          "args": [
            "inode",
            "dirent"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "336-354",
          "snippet": "int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dx_csum_verify",
          "args": [
            "inode",
            "dirent"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "429-457",
          "snippet": "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 1;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 1;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 1;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 1;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "dirent->rec_len",
            "inode->i_sb->s_blocksize"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "inode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_warning",
          "args": [
            "inode->i_sb",
            "__func__",
            "line",
            "\"error %ld reading directory block \"\n\t\t\t       \"(ino %lu, block %lu)\"",
            "PTR_ERR(bh)",
            "inode->i_ino",
            "(unsigned long) block"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "NULL",
            "inode",
            "block",
            "0"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *__ext4_read_dirblock(struct inode *inode,\n\t\t\t\t\t      ext4_lblk_t block,\n\t\t\t\t\t      dirblock_type_t type,\n\t\t\t\t\t      unsigned int line)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry *dirent;\n\tint is_dx_block = 0;\n\n\tbh = ext4_bread(NULL, inode, block, 0);\n\tif (IS_ERR(bh)) {\n\t\t__ext4_warning(inode->i_sb, __func__, line,\n\t\t\t       \"error %ld reading directory block \"\n\t\t\t       \"(ino %lu, block %lu)\", PTR_ERR(bh), inode->i_ino,\n\t\t\t       (unsigned long) block);\n\n\t\treturn bh;\n\t}\n\tif (!bh) {\n\t\text4_error_inode(inode, __func__, line, block, \"Directory hole found\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tdirent = (struct ext4_dir_entry *) bh->b_data;\n\t/* Determine whether or not we have an index block */\n\tif (is_dx(inode)) {\n\t\tif (block == 0)\n\t\t\tis_dx_block = 1;\n\t\telse if (ext4_rec_len_from_disk(dirent->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize) ==\n\t\t\t inode->i_sb->s_blocksize)\n\t\t\tis_dx_block = 1;\n\t}\n\tif (!is_dx_block && type == INDEX) {\n\t\text4_error_inode(inode, __func__, line, block,\n\t\t       \"directory leaf block found instead of index block\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (!ext4_has_metadata_csum(inode->i_sb) ||\n\t    buffer_verified(bh))\n\t\treturn bh;\n\n\t/*\n\t * An empty leaf block can get mistaken for a index block; for\n\t * this reason, we can only check the index checksum when the\n\t * caller is sure it should be an index block.\n\t */\n\tif (is_dx_block && type == INDEX) {\n\t\tif (ext4_dx_csum_verify(inode, dirent))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode(inode, __func__, line, block,\n\t\t\t\t\"Directory index failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\tif (!is_dx_block) {\n\t\tif (ext4_dirent_csum_verify(inode, dirent))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode(inode, __func__, line, block,\n\t\t\t\t\"Directory block failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn bh;\n}"
  },
  {
    "function_name": "ext4_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
    "lines": "51-78",
    "snippet": "static struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/time.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
      "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "handle",
            "inode",
            "*block",
            "1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, 1);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}"
  }
]