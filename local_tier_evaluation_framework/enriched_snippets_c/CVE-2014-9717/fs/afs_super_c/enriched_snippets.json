[
  {
    "function_name": "afs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "529-557",
    "snippet": "static int afs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct afs_volume_status vs;\n\tstruct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);\n\tstruct key *key;\n\tint ret;\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tret = afs_vnode_get_volume_status(vnode, key, &vs);\n\tkey_put(key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf->f_type\t= dentry->d_sb->s_magic;\n\tbuf->f_bsize\t= AFS_BLOCK_SIZE;\n\tbuf->f_namelen\t= AFSNAMEMAX - 1;\n\n\tif (vs.max_quota == 0)\n\t\tbuf->f_blocks = vs.part_max_blocks;\n\telse\n\t\tbuf->f_blocks = vs.max_quota;\n\tbuf->f_bavail = buf->f_bfree = buf->f_blocks - vs.blocks_in_use;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_get_volume_status",
          "args": [
            "vnode",
            "key",
            "&vs"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_get_volume_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "876-910",
          "snippet": "int afs_vnode_get_volume_status(struct afs_vnode *vnode, struct key *key,\n\t\t\t\tstruct afs_volume_status *vs)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_get_volume_status(server, key, vnode, vs, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_get_volume_status(struct afs_vnode *vnode, struct key *key,\n\t\t\t\tstruct afs_volume_status *vs)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_get_volume_status(server, key, vnode, vs, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "vnode->volume->cell"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int afs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct afs_volume_status vs;\n\tstruct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);\n\tstruct key *key;\n\tint ret;\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tret = afs_vnode_get_volume_status(vnode, key, &vs);\n\tkey_put(key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf->f_type\t= dentry->d_sb->s_magic;\n\tbuf->f_bsize\t= AFS_BLOCK_SIZE;\n\tbuf->f_namelen\t= AFSNAMEMAX - 1;\n\n\tif (vs.max_quota == 0)\n\t\tbuf->f_blocks = vs.part_max_blocks;\n\telse\n\t\tbuf->f_blocks = vs.max_quota;\n\tbuf->f_bavail = buf->f_bfree = buf->f_blocks - vs.blocks_in_use;\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "512-524",
    "snippet": "static void afs_destroy_inode(struct inode *inode)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"%p{%x:%u}\", inode, vnode->fid.vid, vnode->fid.vnode);\n\n\t_debug(\"DESTROY INODE %p\", inode);\n\n\tASSERTCMP(vnode->server, ==, NULL);\n\n\tcall_rcu(&inode->i_rcu, afs_i_callback);\n\tatomic_dec(&afs_count_active_inodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_destroy_inode(struct inode *inode);",
      "static atomic_t afs_count_active_inodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&afs_count_active_inodes"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "afs_i_callback"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->server",
            "==,NULL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"DESTROY INODE %p\"",
            "inode"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p{%x:%u}\"",
            "inode",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstatic atomic_t afs_count_active_inodes;\n\nstatic void afs_destroy_inode(struct inode *inode)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"%p{%x:%u}\", inode, vnode->fid.vid, vnode->fid.vnode);\n\n\t_debug(\"DESTROY INODE %p\", inode);\n\n\tASSERTCMP(vnode->server, ==, NULL);\n\n\tcall_rcu(&inode->i_rcu, afs_i_callback);\n\tatomic_dec(&afs_count_active_inodes);\n}"
  },
  {
    "function_name": "afs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "502-507",
    "snippet": "static void afs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tkmem_cache_free(afs_inode_cachep, vnode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *afs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "afs_inode_cachep",
            "vnode"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *afs_inode_cachep;\n\nstatic void afs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tkmem_cache_free(afs_inode_cachep, vnode);\n}"
  },
  {
    "function_name": "afs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "480-500",
    "snippet": "static struct inode *afs_alloc_inode(struct super_block *sb)\n{\n\tstruct afs_vnode *vnode;\n\n\tvnode = kmem_cache_alloc(afs_inode_cachep, GFP_KERNEL);\n\tif (!vnode)\n\t\treturn NULL;\n\n\tatomic_inc(&afs_count_active_inodes);\n\n\tmemset(&vnode->fid, 0, sizeof(vnode->fid));\n\tmemset(&vnode->status, 0, sizeof(vnode->status));\n\n\tvnode->volume\t\t= NULL;\n\tvnode->update_cnt\t= 0;\n\tvnode->flags\t\t= 1 << AFS_VNODE_UNSET;\n\tvnode->cb_promised\t= false;\n\n\t_leave(\" = %p\", &vnode->vfs_inode);\n\treturn &vnode->vfs_inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);",
      "static void afs_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *afs_inode_cachep;",
      "static atomic_t afs_count_active_inodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p\"",
            "&vnode->vfs_inode"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vnode->status",
            "0",
            "sizeof(vnode->status)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vnode->fid",
            "0",
            "sizeof(vnode->fid)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&afs_count_active_inodes"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "afs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\nstatic void afs_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nstatic struct inode *afs_alloc_inode(struct super_block *sb)\n{\n\tstruct afs_vnode *vnode;\n\n\tvnode = kmem_cache_alloc(afs_inode_cachep, GFP_KERNEL);\n\tif (!vnode)\n\t\treturn NULL;\n\n\tatomic_inc(&afs_count_active_inodes);\n\n\tmemset(&vnode->fid, 0, sizeof(vnode->fid));\n\tmemset(&vnode->status, 0, sizeof(vnode->status));\n\n\tvnode->volume\t\t= NULL;\n\tvnode->update_cnt\t= 0;\n\tvnode->flags\t\t= 1 << AFS_VNODE_UNSET;\n\tvnode->cb_promised\t= false;\n\n\t_leave(\" = %p\", &vnode->vfs_inode);\n\treturn &vnode->vfs_inode;\n}"
  },
  {
    "function_name": "afs_i_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "459-475",
    "snippet": "static void afs_i_init_once(void *_vnode)\n{\n\tstruct afs_vnode *vnode = _vnode;\n\n\tmemset(vnode, 0, sizeof(*vnode));\n\tinode_init_once(&vnode->vfs_inode);\n\tinit_waitqueue_head(&vnode->update_waitq);\n\tmutex_init(&vnode->permits_lock);\n\tmutex_init(&vnode->validate_lock);\n\tspin_lock_init(&vnode->writeback_lock);\n\tspin_lock_init(&vnode->lock);\n\tINIT_LIST_HEAD(&vnode->writebacks);\n\tINIT_LIST_HEAD(&vnode->pending_locks);\n\tINIT_LIST_HEAD(&vnode->granted_locks);\n\tINIT_DELAYED_WORK(&vnode->lock_work, afs_lock_work);\n\tINIT_WORK(&vnode->cb_broken_work, afs_broken_callback_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&vnode->cb_broken_work",
            "afs_broken_callback_work"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&vnode->lock_work",
            "afs_lock_work"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vnode->granted_locks"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vnode->pending_locks"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vnode->writebacks"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vnode->lock"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&vnode->validate_lock"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&vnode->permits_lock"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&vnode->update_waitq"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vnode",
            "0",
            "sizeof(*vnode)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_i_init_once(void *_vnode)\n{\n\tstruct afs_vnode *vnode = _vnode;\n\n\tmemset(vnode, 0, sizeof(*vnode));\n\tinode_init_once(&vnode->vfs_inode);\n\tinit_waitqueue_head(&vnode->update_waitq);\n\tmutex_init(&vnode->permits_lock);\n\tmutex_init(&vnode->validate_lock);\n\tspin_lock_init(&vnode->writeback_lock);\n\tspin_lock_init(&vnode->lock);\n\tINIT_LIST_HEAD(&vnode->writebacks);\n\tINIT_LIST_HEAD(&vnode->pending_locks);\n\tINIT_LIST_HEAD(&vnode->granted_locks);\n\tINIT_DELAYED_WORK(&vnode->lock_work, afs_lock_work);\n\tINIT_WORK(&vnode->cb_broken_work, afs_broken_callback_work);\n}"
  },
  {
    "function_name": "afs_kill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "448-454",
    "snippet": "static void afs_kill_super(struct super_block *sb)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tkill_anon_super(sb);\n\tafs_put_volume(as->volume);\n\tkfree(as);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "as"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_volume",
          "args": [
            "as->volume"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "172-213",
          "snippet": "void afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\n\nstatic void afs_kill_super(struct super_block *sb)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tkill_anon_super(sb);\n\tafs_put_volume(as->volume);\n\tkfree(as);\n}"
  },
  {
    "function_name": "afs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "354-446",
    "snippet": "static struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *options)\n{\n\tstruct afs_mount_params params;\n\tstruct super_block *sb;\n\tstruct afs_volume *vol;\n\tstruct key *key;\n\tchar *new_opts = kstrdup(options, GFP_KERNEL);\n\tstruct afs_super_info *as;\n\tint ret;\n\n\t_enter(\",,%s,%p\", dev_name, options);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tret = -EINVAL;\n\tif (current->nsproxy->net_ns != &init_net)\n\t\tgoto error;\n\n\t/* parse the options and device name */\n\tif (options) {\n\t\tret = afs_parse_options(&params, options, &dev_name);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = afs_parse_device_name(&params, dev_name);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* try and do the mount securely */\n\tkey = afs_request_key(params.cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\tparams.key = key;\n\n\t/* parse the device name */\n\tvol = afs_volume_lookup(&params);\n\tif (IS_ERR(vol)) {\n\t\tret = PTR_ERR(vol);\n\t\tgoto error;\n\t}\n\n\t/* allocate a superblock info record */\n\tas = kzalloc(sizeof(struct afs_super_info), GFP_KERNEL);\n\tif (!as) {\n\t\tret = -ENOMEM;\n\t\tafs_put_volume(vol);\n\t\tgoto error;\n\t}\n\tas->volume = vol;\n\n\t/* allocate a deviceless superblock */\n\tsb = sget(fs_type, afs_test_super, afs_set_super, flags, as);\n\tif (IS_ERR(sb)) {\n\t\tret = PTR_ERR(sb);\n\t\tafs_put_volume(vol);\n\t\tkfree(as);\n\t\tgoto error;\n\t}\n\n\tif (!sb->s_root) {\n\t\t/* initial superblock/root creation */\n\t\t_debug(\"create\");\n\t\tret = afs_fill_super(sb, &params);\n\t\tif (ret < 0) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tgoto error;\n\t\t}\n\t\tsave_mount_options(sb, new_opts);\n\t\tsb->s_flags |= MS_ACTIVE;\n\t} else {\n\t\t_debug(\"reuse\");\n\t\tASSERTCMP(sb->s_flags, &, MS_ACTIVE);\n\t\tafs_put_volume(vol);\n\t\tkfree(as);\n\t}\n\n\tafs_put_cell(params.cell);\n\tkfree(new_opts);\n\t_leave(\" = 0 [%p]\", sb);\n\treturn dget(sb->s_root);\n\nerror:\n\tafs_put_cell(params.cell);\n\tkey_put(params.key);\n\tkfree(new_opts);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_opts"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "params.key"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_cell",
          "args": [
            "params.cell"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_cell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "343-370",
          "snippet": "void afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);\n\nvoid afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_opts"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "as"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_volume",
          "args": [
            "vol"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "172-213",
          "snippet": "void afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "sb->s_flags",
            "&, MS_ACTIVE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"reuse\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "new_opts"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_fill_super",
          "args": [
            "sb",
            "&params"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
          "lines": "307-349",
          "snippet": "static int afs_fill_super(struct super_block *sb,\n\t\t\t  struct afs_mount_params *params)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tstruct afs_fid fid;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* fill in the superblock */\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tsb->s_bdi\t\t= &as->volume->bdi;\n\tstrlcpy(sb->s_id, as->volume->vlocation->vldb.name, sizeof(sb->s_id));\n\n\t/* allocate the root inode and dentry */\n\tfid.vid\t\t= as->volume->vid;\n\tfid.vnode\t= 1;\n\tfid.unique\t= 1;\n\tinode = afs_iget(sb, params->key, &fid, NULL, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (params->autocell)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto error;\n\n\tsb->s_d_op = &afs_fs_dentry_operations;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sched.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AFS_FS_MAGIC 0x6B414653 /* 'kAFS' */"
          ],
          "globals_used": [
            "static void afs_kill_super(struct super_block *sb);",
            "static struct inode *afs_alloc_inode(struct super_block *sb);",
            "static void afs_destroy_inode(struct inode *inode);",
            "static const struct super_operations afs_super_ops = {\n\t.statfs\t\t= afs_statfs,\n\t.alloc_inode\t= afs_alloc_inode,\n\t.drop_inode\t= afs_drop_inode,\n\t.destroy_inode\t= afs_destroy_inode,\n\t.evict_inode\t= afs_evict_inode,\n\t.show_options\t= generic_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_FS_MAGIC 0x6B414653 /* 'kAFS' */\n\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\nstatic void afs_destroy_inode(struct inode *inode);\nstatic const struct super_operations afs_super_ops = {\n\t.statfs\t\t= afs_statfs,\n\t.alloc_inode\t= afs_alloc_inode,\n\t.drop_inode\t= afs_drop_inode,\n\t.destroy_inode\t= afs_destroy_inode,\n\t.evict_inode\t= afs_evict_inode,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int afs_fill_super(struct super_block *sb,\n\t\t\t  struct afs_mount_params *params)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tstruct afs_fid fid;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* fill in the superblock */\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tsb->s_bdi\t\t= &as->volume->bdi;\n\tstrlcpy(sb->s_id, as->volume->vlocation->vldb.name, sizeof(sb->s_id));\n\n\t/* allocate the root inode and dentry */\n\tfid.vid\t\t= as->volume->vid;\n\tfid.vnode\t= 1;\n\tfid.unique\t= 1;\n\tinode = afs_iget(sb, params->key, &fid, NULL, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (params->autocell)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto error;\n\n\tsb->s_d_op = &afs_fs_dentry_operations;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "as"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sb"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "afs_test_super",
            "afs_set_super",
            "flags",
            "as"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct afs_super_info)",
            "GFP_KERNEL"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_lookup",
          "args": [
            "&params"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "45-167",
          "snippet": "struct afs_volume *afs_volume_lookup(struct afs_mount_params *params)\n{\n\tstruct afs_vlocation *vlocation = NULL;\n\tstruct afs_volume *volume = NULL;\n\tstruct afs_server *server = NULL;\n\tchar srvtmask;\n\tint ret, loop;\n\n\t_enter(\"{%*.*s,%d}\",\n\t       params->volnamesz, params->volnamesz, params->volname, params->rwpath);\n\n\t/* lookup the volume location record */\n\tvlocation = afs_vlocation_lookup(params->cell, params->key,\n\t\t\t\t\t params->volname, params->volnamesz);\n\tif (IS_ERR(vlocation)) {\n\t\tret = PTR_ERR(vlocation);\n\t\tvlocation = NULL;\n\t\tgoto error;\n\t}\n\n\t/* make the final decision on the type we want */\n\tret = -ENOMEDIUM;\n\tif (params->force && !(vlocation->vldb.vidmask & (1 << params->type)))\n\t\tgoto error;\n\n\tsrvtmask = 0;\n\tfor (loop = 0; loop < vlocation->vldb.nservers; loop++)\n\t\tsrvtmask |= vlocation->vldb.srvtmask[loop];\n\n\tif (params->force) {\n\t\tif (!(srvtmask & (1 << params->type)))\n\t\t\tgoto error;\n\t} else if (srvtmask & AFS_VOL_VTM_RO) {\n\t\tparams->type = AFSVL_ROVOL;\n\t} else if (srvtmask & AFS_VOL_VTM_RW) {\n\t\tparams->type = AFSVL_RWVOL;\n\t} else {\n\t\tgoto error;\n\t}\n\n\tdown_write(&params->cell->vl_sem);\n\n\t/* is the volume already active? */\n\tif (vlocation->vols[params->type]) {\n\t\t/* yes - re-use it */\n\t\tvolume = vlocation->vols[params->type];\n\t\tafs_get_volume(volume);\n\t\tgoto success;\n\t}\n\n\t/* create a new volume record */\n\t_debug(\"creating new volume record\");\n\n\tret = -ENOMEM;\n\tvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\n\tif (!volume)\n\t\tgoto error_up;\n\n\tatomic_set(&volume->usage, 1);\n\tvolume->type\t\t= params->type;\n\tvolume->type_force\t= params->force;\n\tvolume->cell\t\t= params->cell;\n\tvolume->vid\t\t= vlocation->vldb.vid[params->type];\n\n\tret = bdi_setup_and_register(&volume->bdi, \"afs\");\n\tif (ret)\n\t\tgoto error_bdi;\n\n\tinit_rwsem(&volume->server_sem);\n\n\t/* look up all the applicable server records */\n\tfor (loop = 0; loop < 8; loop++) {\n\t\tif (vlocation->vldb.srvtmask[loop] & (1 << volume->type)) {\n\t\t\tserver = afs_lookup_server(\n\t\t\t       volume->cell, &vlocation->vldb.servers[loop]);\n\t\t\tif (IS_ERR(server)) {\n\t\t\t\tret = PTR_ERR(server);\n\t\t\t\tgoto error_discard;\n\t\t\t}\n\n\t\t\tvolume->servers[volume->nservers] = server;\n\t\t\tvolume->nservers++;\n\t\t}\n\t}\n\n\t/* attach the cache and volume location */\n#ifdef CONFIG_AFS_FSCACHE\n\tvolume->cache = fscache_acquire_cookie(vlocation->cache,\n\t\t\t\t\t       &afs_volume_cache_index_def,\n\t\t\t\t\t       volume, true);\n#endif\n\tafs_get_vlocation(vlocation);\n\tvolume->vlocation = vlocation;\n\n\tvlocation->vols[volume->type] = volume;\n\nsuccess:\n\t_debug(\"kAFS selected %s volume %08x\",\n\t       afs_voltypes[volume->type], volume->vid);\n\tup_write(&params->cell->vl_sem);\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %p\", volume);\n\treturn volume;\n\n\t/* clean up */\nerror_up:\n\tup_write(&params->cell->vl_sem);\nerror:\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nerror_discard:\n\tbdi_destroy(&volume->bdi);\nerror_bdi:\n\tup_write(&params->cell->vl_sem);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tkfree(volume);\n\tgoto error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *afs_voltypes[] = { \"R/W\", \"R/O\", \"BAK\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const char *afs_voltypes[] = { \"R/W\", \"R/O\", \"BAK\" };\n\nstruct afs_volume *afs_volume_lookup(struct afs_mount_params *params)\n{\n\tstruct afs_vlocation *vlocation = NULL;\n\tstruct afs_volume *volume = NULL;\n\tstruct afs_server *server = NULL;\n\tchar srvtmask;\n\tint ret, loop;\n\n\t_enter(\"{%*.*s,%d}\",\n\t       params->volnamesz, params->volnamesz, params->volname, params->rwpath);\n\n\t/* lookup the volume location record */\n\tvlocation = afs_vlocation_lookup(params->cell, params->key,\n\t\t\t\t\t params->volname, params->volnamesz);\n\tif (IS_ERR(vlocation)) {\n\t\tret = PTR_ERR(vlocation);\n\t\tvlocation = NULL;\n\t\tgoto error;\n\t}\n\n\t/* make the final decision on the type we want */\n\tret = -ENOMEDIUM;\n\tif (params->force && !(vlocation->vldb.vidmask & (1 << params->type)))\n\t\tgoto error;\n\n\tsrvtmask = 0;\n\tfor (loop = 0; loop < vlocation->vldb.nservers; loop++)\n\t\tsrvtmask |= vlocation->vldb.srvtmask[loop];\n\n\tif (params->force) {\n\t\tif (!(srvtmask & (1 << params->type)))\n\t\t\tgoto error;\n\t} else if (srvtmask & AFS_VOL_VTM_RO) {\n\t\tparams->type = AFSVL_ROVOL;\n\t} else if (srvtmask & AFS_VOL_VTM_RW) {\n\t\tparams->type = AFSVL_RWVOL;\n\t} else {\n\t\tgoto error;\n\t}\n\n\tdown_write(&params->cell->vl_sem);\n\n\t/* is the volume already active? */\n\tif (vlocation->vols[params->type]) {\n\t\t/* yes - re-use it */\n\t\tvolume = vlocation->vols[params->type];\n\t\tafs_get_volume(volume);\n\t\tgoto success;\n\t}\n\n\t/* create a new volume record */\n\t_debug(\"creating new volume record\");\n\n\tret = -ENOMEM;\n\tvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\n\tif (!volume)\n\t\tgoto error_up;\n\n\tatomic_set(&volume->usage, 1);\n\tvolume->type\t\t= params->type;\n\tvolume->type_force\t= params->force;\n\tvolume->cell\t\t= params->cell;\n\tvolume->vid\t\t= vlocation->vldb.vid[params->type];\n\n\tret = bdi_setup_and_register(&volume->bdi, \"afs\");\n\tif (ret)\n\t\tgoto error_bdi;\n\n\tinit_rwsem(&volume->server_sem);\n\n\t/* look up all the applicable server records */\n\tfor (loop = 0; loop < 8; loop++) {\n\t\tif (vlocation->vldb.srvtmask[loop] & (1 << volume->type)) {\n\t\t\tserver = afs_lookup_server(\n\t\t\t       volume->cell, &vlocation->vldb.servers[loop]);\n\t\t\tif (IS_ERR(server)) {\n\t\t\t\tret = PTR_ERR(server);\n\t\t\t\tgoto error_discard;\n\t\t\t}\n\n\t\t\tvolume->servers[volume->nservers] = server;\n\t\t\tvolume->nservers++;\n\t\t}\n\t}\n\n\t/* attach the cache and volume location */\n#ifdef CONFIG_AFS_FSCACHE\n\tvolume->cache = fscache_acquire_cookie(vlocation->cache,\n\t\t\t\t\t       &afs_volume_cache_index_def,\n\t\t\t\t\t       volume, true);\n#endif\n\tafs_get_vlocation(vlocation);\n\tvolume->vlocation = vlocation;\n\n\tvlocation->vols[volume->type] = volume;\n\nsuccess:\n\t_debug(\"kAFS selected %s volume %08x\",\n\t       afs_voltypes[volume->type], volume->vid);\n\tup_write(&params->cell->vl_sem);\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %p\", volume);\n\treturn volume;\n\n\t/* clean up */\nerror_up:\n\tup_write(&params->cell->vl_sem);\nerror:\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nerror_discard:\n\tbdi_destroy(&volume->bdi);\nerror_bdi:\n\tup_write(&params->cell->vl_sem);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tkfree(volume);\n\tgoto error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "params.cell"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_parse_device_name",
          "args": [
            "&params",
            "dev_name"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "afs_parse_device_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
          "lines": "206-285",
          "snippet": "static int afs_parse_device_name(struct afs_mount_params *params,\n\t\t\t\t const char *name)\n{\n\tstruct afs_cell *cell;\n\tconst char *cellname, *suffix;\n\tint cellnamesz;\n\n\t_enter(\",%s\", name);\n\n\tif (!name) {\n\t\tprintk(KERN_ERR \"kAFS: no volume name specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((name[0] != '%' && name[0] != '#') || !name[1]) {\n\t\tprintk(KERN_ERR \"kAFS: unparsable volume name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine the type of volume we're looking for */\n\tparams->type = AFSVL_ROVOL;\n\tparams->force = false;\n\tif (params->rwpath || name[0] == '%') {\n\t\tparams->type = AFSVL_RWVOL;\n\t\tparams->force = true;\n\t}\n\tname++;\n\n\t/* split the cell name out if there is one */\n\tparams->volname = strchr(name, ':');\n\tif (params->volname) {\n\t\tcellname = name;\n\t\tcellnamesz = params->volname - name;\n\t\tparams->volname++;\n\t} else {\n\t\tparams->volname = name;\n\t\tcellname = NULL;\n\t\tcellnamesz = 0;\n\t}\n\n\t/* the volume type is further affected by a possible suffix */\n\tsuffix = strrchr(params->volname, '.');\n\tif (suffix) {\n\t\tif (strcmp(suffix, \".readonly\") == 0) {\n\t\t\tparams->type = AFSVL_ROVOL;\n\t\t\tparams->force = true;\n\t\t} else if (strcmp(suffix, \".backup\") == 0) {\n\t\t\tparams->type = AFSVL_BACKVOL;\n\t\t\tparams->force = true;\n\t\t} else if (suffix[1] == 0) {\n\t\t} else {\n\t\t\tsuffix = NULL;\n\t\t}\n\t}\n\n\tparams->volnamesz = suffix ?\n\t\tsuffix - params->volname : strlen(params->volname);\n\n\t_debug(\"cell %*.*s [%p]\",\n\t       cellnamesz, cellnamesz, cellname ?: \"\", params->cell);\n\n\t/* lookup the cell record */\n\tif (cellname || !params->cell) {\n\t\tcell = afs_cell_lookup(cellname, cellnamesz, true);\n\t\tif (IS_ERR(cell)) {\n\t\t\tprintk(KERN_ERR \"kAFS: unable to lookup cell '%*.*s'\\n\",\n\t\t\t       cellnamesz, cellnamesz, cellname ?: \"\");\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tafs_put_cell(params->cell);\n\t\tparams->cell = cell;\n\t}\n\n\t_debug(\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\",\n\t       params->cell->name, params->cell,\n\t       params->volnamesz, params->volnamesz, params->volname,\n\t       suffix ?: \"-\", params->type, params->force ? \" FORCE\" : \"\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sched.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_parse_device_name(struct afs_mount_params *params,\n\t\t\t\t const char *name)\n{\n\tstruct afs_cell *cell;\n\tconst char *cellname, *suffix;\n\tint cellnamesz;\n\n\t_enter(\",%s\", name);\n\n\tif (!name) {\n\t\tprintk(KERN_ERR \"kAFS: no volume name specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((name[0] != '%' && name[0] != '#') || !name[1]) {\n\t\tprintk(KERN_ERR \"kAFS: unparsable volume name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine the type of volume we're looking for */\n\tparams->type = AFSVL_ROVOL;\n\tparams->force = false;\n\tif (params->rwpath || name[0] == '%') {\n\t\tparams->type = AFSVL_RWVOL;\n\t\tparams->force = true;\n\t}\n\tname++;\n\n\t/* split the cell name out if there is one */\n\tparams->volname = strchr(name, ':');\n\tif (params->volname) {\n\t\tcellname = name;\n\t\tcellnamesz = params->volname - name;\n\t\tparams->volname++;\n\t} else {\n\t\tparams->volname = name;\n\t\tcellname = NULL;\n\t\tcellnamesz = 0;\n\t}\n\n\t/* the volume type is further affected by a possible suffix */\n\tsuffix = strrchr(params->volname, '.');\n\tif (suffix) {\n\t\tif (strcmp(suffix, \".readonly\") == 0) {\n\t\t\tparams->type = AFSVL_ROVOL;\n\t\t\tparams->force = true;\n\t\t} else if (strcmp(suffix, \".backup\") == 0) {\n\t\t\tparams->type = AFSVL_BACKVOL;\n\t\t\tparams->force = true;\n\t\t} else if (suffix[1] == 0) {\n\t\t} else {\n\t\t\tsuffix = NULL;\n\t\t}\n\t}\n\n\tparams->volnamesz = suffix ?\n\t\tsuffix - params->volname : strlen(params->volname);\n\n\t_debug(\"cell %*.*s [%p]\",\n\t       cellnamesz, cellnamesz, cellname ?: \"\", params->cell);\n\n\t/* lookup the cell record */\n\tif (cellname || !params->cell) {\n\t\tcell = afs_cell_lookup(cellname, cellnamesz, true);\n\t\tif (IS_ERR(cell)) {\n\t\t\tprintk(KERN_ERR \"kAFS: unable to lookup cell '%*.*s'\\n\",\n\t\t\t       cellnamesz, cellnamesz, cellname ?: \"\");\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tafs_put_cell(params->cell);\n\t\tparams->cell = cell;\n\t}\n\n\t_debug(\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\",\n\t       params->cell->name, params->cell,\n\t       params->volnamesz, params->volnamesz, params->volname,\n\t       suffix ?: \"-\", params->type, params->force ? \" FORCE\" : \"\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_parse_options",
          "args": [
            "&params",
            "options",
            "&dev_name"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "afs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
          "lines": "143-192",
          "snippet": "static int afs_parse_options(struct afs_mount_params *params,\n\t\t\t     char *options, const char **devname)\n{\n\tstruct afs_cell *cell;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint token;\n\n\t_enter(\"%s\", options);\n\n\toptions[PAGE_SIZE - 1] = 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, afs_options_list, args);\n\t\tswitch (token) {\n\t\tcase afs_opt_cell:\n\t\t\tcell = afs_cell_lookup(args[0].from,\n\t\t\t\t\t       args[0].to - args[0].from,\n\t\t\t\t\t       false);\n\t\t\tif (IS_ERR(cell))\n\t\t\t\treturn PTR_ERR(cell);\n\t\t\tafs_put_cell(params->cell);\n\t\t\tparams->cell = cell;\n\t\t\tbreak;\n\n\t\tcase afs_opt_rwpath:\n\t\t\tparams->rwpath = 1;\n\t\t\tbreak;\n\n\t\tcase afs_opt_vol:\n\t\t\t*devname = args[0].from;\n\t\t\tbreak;\n\n\t\tcase afs_opt_autocell:\n\t\t\tparams->autocell = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t\t       \" Unknown or invalid mount option: '%s'\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sched.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t afs_options_list = {\n\t{ afs_opt_cell,\t\t\"cell=%s\"\t},\n\t{ afs_opt_rwpath,\t\"rwpath\"\t},\n\t{ afs_opt_vol,\t\t\"vol=%s\"\t},\n\t{ afs_opt_autocell,\t\"autocell\"\t},\n\t{ afs_no_opt,\t\tNULL\t\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const match_table_t afs_options_list = {\n\t{ afs_opt_cell,\t\t\"cell=%s\"\t},\n\t{ afs_opt_rwpath,\t\"rwpath\"\t},\n\t{ afs_opt_vol,\t\t\"vol=%s\"\t},\n\t{ afs_opt_autocell,\t\"autocell\"\t},\n\t{ afs_no_opt,\t\tNULL\t\t},\n};\n\nstatic int afs_parse_options(struct afs_mount_params *params,\n\t\t\t     char *options, const char **devname)\n{\n\tstruct afs_cell *cell;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint token;\n\n\t_enter(\"%s\", options);\n\n\toptions[PAGE_SIZE - 1] = 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, afs_options_list, args);\n\t\tswitch (token) {\n\t\tcase afs_opt_cell:\n\t\t\tcell = afs_cell_lookup(args[0].from,\n\t\t\t\t\t       args[0].to - args[0].from,\n\t\t\t\t\t       false);\n\t\t\tif (IS_ERR(cell))\n\t\t\t\treturn PTR_ERR(cell);\n\t\t\tafs_put_cell(params->cell);\n\t\t\tparams->cell = cell;\n\t\t\tbreak;\n\n\t\tcase afs_opt_rwpath:\n\t\t\tparams->rwpath = 1;\n\t\t\tbreak;\n\n\t\tcase afs_opt_vol:\n\t\t\t*devname = args[0].from;\n\t\t\tbreak;\n\n\t\tcase afs_opt_autocell:\n\t\t\tparams->autocell = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t\t       \" Unknown or invalid mount option: '%s'\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&params",
            "0",
            "sizeof(params)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%s,%p\"",
            "dev_name",
            "options"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "options",
            "GFP_KERNEL"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\n\nstatic struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *options)\n{\n\tstruct afs_mount_params params;\n\tstruct super_block *sb;\n\tstruct afs_volume *vol;\n\tstruct key *key;\n\tchar *new_opts = kstrdup(options, GFP_KERNEL);\n\tstruct afs_super_info *as;\n\tint ret;\n\n\t_enter(\",,%s,%p\", dev_name, options);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tret = -EINVAL;\n\tif (current->nsproxy->net_ns != &init_net)\n\t\tgoto error;\n\n\t/* parse the options and device name */\n\tif (options) {\n\t\tret = afs_parse_options(&params, options, &dev_name);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = afs_parse_device_name(&params, dev_name);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* try and do the mount securely */\n\tkey = afs_request_key(params.cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\tparams.key = key;\n\n\t/* parse the device name */\n\tvol = afs_volume_lookup(&params);\n\tif (IS_ERR(vol)) {\n\t\tret = PTR_ERR(vol);\n\t\tgoto error;\n\t}\n\n\t/* allocate a superblock info record */\n\tas = kzalloc(sizeof(struct afs_super_info), GFP_KERNEL);\n\tif (!as) {\n\t\tret = -ENOMEM;\n\t\tafs_put_volume(vol);\n\t\tgoto error;\n\t}\n\tas->volume = vol;\n\n\t/* allocate a deviceless superblock */\n\tsb = sget(fs_type, afs_test_super, afs_set_super, flags, as);\n\tif (IS_ERR(sb)) {\n\t\tret = PTR_ERR(sb);\n\t\tafs_put_volume(vol);\n\t\tkfree(as);\n\t\tgoto error;\n\t}\n\n\tif (!sb->s_root) {\n\t\t/* initial superblock/root creation */\n\t\t_debug(\"create\");\n\t\tret = afs_fill_super(sb, &params);\n\t\tif (ret < 0) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tgoto error;\n\t\t}\n\t\tsave_mount_options(sb, new_opts);\n\t\tsb->s_flags |= MS_ACTIVE;\n\t} else {\n\t\t_debug(\"reuse\");\n\t\tASSERTCMP(sb->s_flags, &, MS_ACTIVE);\n\t\tafs_put_volume(vol);\n\t\tkfree(as);\n\t}\n\n\tafs_put_cell(params.cell);\n\tkfree(new_opts);\n\t_leave(\" = 0 [%p]\", sb);\n\treturn dget(sb->s_root);\n\nerror:\n\tafs_put_cell(params.cell);\n\tkey_put(params.key);\n\tkfree(new_opts);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "afs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "307-349",
    "snippet": "static int afs_fill_super(struct super_block *sb,\n\t\t\t  struct afs_mount_params *params)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tstruct afs_fid fid;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* fill in the superblock */\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tsb->s_bdi\t\t= &as->volume->bdi;\n\tstrlcpy(sb->s_id, as->volume->vlocation->vldb.name, sizeof(sb->s_id));\n\n\t/* allocate the root inode and dentry */\n\tfid.vid\t\t= as->volume->vid;\n\tfid.vnode\t= 1;\n\tfid.unique\t= 1;\n\tinode = afs_iget(sb, params->key, &fid, NULL, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (params->autocell)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto error;\n\n\tsb->s_d_op = &afs_fs_dentry_operations;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AFS_FS_MAGIC 0x6B414653 /* 'kAFS' */"
    ],
    "globals_used": [
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);",
      "static void afs_destroy_inode(struct inode *inode);",
      "static const struct super_operations afs_super_ops = {\n\t.statfs\t\t= afs_statfs,\n\t.alloc_inode\t= afs_alloc_inode,\n\t.drop_inode\t= afs_drop_inode,\n\t.destroy_inode\t= afs_destroy_inode,\n\t.evict_inode\t= afs_evict_inode,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_AUTOCELL",
            "&AFS_FS_I(inode)->flags"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "sb",
            "params->key",
            "&fid",
            "NULL",
            "NULL"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sb->s_id",
            "as->volume->vlocation->vldb.name",
            "sizeof(sb->s_id)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_FS_MAGIC 0x6B414653 /* 'kAFS' */\n\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\nstatic void afs_destroy_inode(struct inode *inode);\nstatic const struct super_operations afs_super_ops = {\n\t.statfs\t\t= afs_statfs,\n\t.alloc_inode\t= afs_alloc_inode,\n\t.drop_inode\t= afs_drop_inode,\n\t.destroy_inode\t= afs_destroy_inode,\n\t.evict_inode\t= afs_evict_inode,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int afs_fill_super(struct super_block *sb,\n\t\t\t  struct afs_mount_params *params)\n{\n\tstruct afs_super_info *as = sb->s_fs_info;\n\tstruct afs_fid fid;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* fill in the superblock */\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tsb->s_bdi\t\t= &as->volume->bdi;\n\tstrlcpy(sb->s_id, as->volume->vlocation->vldb.name, sizeof(sb->s_id));\n\n\t/* allocate the root inode and dentry */\n\tfid.vid\t\t= as->volume->vid;\n\tfid.vnode\t= 1;\n\tfid.unique\t= 1;\n\tinode = afs_iget(sb, params->key, &fid, NULL, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (params->autocell)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto error;\n\n\tsb->s_d_op = &afs_fs_dentry_operations;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "298-302",
    "snippet": "static int afs_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data);",
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "sb",
            "NULL"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data);\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\n\nstatic int afs_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}"
  },
  {
    "function_name": "afs_test_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "290-296",
    "snippet": "static int afs_test_super(struct super_block *sb, void *data)\n{\n\tstruct afs_super_info *as1 = data;\n\tstruct afs_super_info *as = sb->s_fs_info;\n\n\treturn as->volume == as1->volume;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data);",
      "static void afs_kill_super(struct super_block *sb);",
      "static struct inode *afs_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data);\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\n\nstatic int afs_test_super(struct super_block *sb, void *data)\n{\n\tstruct afs_super_info *as1 = data;\n\tstruct afs_super_info *as = sb->s_fs_info;\n\n\treturn as->volume == as1->volume;\n}"
  },
  {
    "function_name": "afs_parse_device_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "206-285",
    "snippet": "static int afs_parse_device_name(struct afs_mount_params *params,\n\t\t\t\t const char *name)\n{\n\tstruct afs_cell *cell;\n\tconst char *cellname, *suffix;\n\tint cellnamesz;\n\n\t_enter(\",%s\", name);\n\n\tif (!name) {\n\t\tprintk(KERN_ERR \"kAFS: no volume name specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((name[0] != '%' && name[0] != '#') || !name[1]) {\n\t\tprintk(KERN_ERR \"kAFS: unparsable volume name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine the type of volume we're looking for */\n\tparams->type = AFSVL_ROVOL;\n\tparams->force = false;\n\tif (params->rwpath || name[0] == '%') {\n\t\tparams->type = AFSVL_RWVOL;\n\t\tparams->force = true;\n\t}\n\tname++;\n\n\t/* split the cell name out if there is one */\n\tparams->volname = strchr(name, ':');\n\tif (params->volname) {\n\t\tcellname = name;\n\t\tcellnamesz = params->volname - name;\n\t\tparams->volname++;\n\t} else {\n\t\tparams->volname = name;\n\t\tcellname = NULL;\n\t\tcellnamesz = 0;\n\t}\n\n\t/* the volume type is further affected by a possible suffix */\n\tsuffix = strrchr(params->volname, '.');\n\tif (suffix) {\n\t\tif (strcmp(suffix, \".readonly\") == 0) {\n\t\t\tparams->type = AFSVL_ROVOL;\n\t\t\tparams->force = true;\n\t\t} else if (strcmp(suffix, \".backup\") == 0) {\n\t\t\tparams->type = AFSVL_BACKVOL;\n\t\t\tparams->force = true;\n\t\t} else if (suffix[1] == 0) {\n\t\t} else {\n\t\t\tsuffix = NULL;\n\t\t}\n\t}\n\n\tparams->volnamesz = suffix ?\n\t\tsuffix - params->volname : strlen(params->volname);\n\n\t_debug(\"cell %*.*s [%p]\",\n\t       cellnamesz, cellnamesz, cellname ?: \"\", params->cell);\n\n\t/* lookup the cell record */\n\tif (cellname || !params->cell) {\n\t\tcell = afs_cell_lookup(cellname, cellnamesz, true);\n\t\tif (IS_ERR(cell)) {\n\t\t\tprintk(KERN_ERR \"kAFS: unable to lookup cell '%*.*s'\\n\",\n\t\t\t       cellnamesz, cellnamesz, cellname ?: \"\");\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tafs_put_cell(params->cell);\n\t\tparams->cell = cell;\n\t}\n\n\t_debug(\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\",\n\t       params->cell->name, params->cell,\n\t       params->volnamesz, params->volnamesz, params->volname,\n\t       suffix ?: \"-\", params->type, params->force ? \" FORCE\" : \"\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\"",
            "params->cell->name",
            "params->cell",
            "params->volnamesz",
            "params->volnamesz",
            "params->volname",
            "suffix ?: \"-\"",
            "params->type",
            "params->force ? \" FORCE\" : \"\""
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_cell",
          "args": [
            "params->cell"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_cell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "343-370",
          "snippet": "void afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);\n\nvoid afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cell"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kAFS: unable to lookup cell '%*.*s'\\n\"",
            "cellnamesz",
            "cellnamesz",
            "cellname ?: \"\""
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cell"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_cell_lookup",
          "args": [
            "cellname",
            "cellnamesz",
            "true"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "268-320",
          "snippet": "struct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,\n\t\t\t\t bool dns_cell)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\\\"%*.*s\\\",\", namesz, namesz, name ?: \"\");\n\n\tdown_read(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\n\tif (name) {\n\t\t/* if the cell was named, look for it in the cell record list */\n\t\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\t\tif (strncmp(cell->name, name, namesz) == 0) {\n\t\t\t\tafs_get_cell(cell);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tcell = ERR_PTR(-ENOENT);\n\t\tif (dns_cell)\n\t\t\tgoto create_cell;\n\tfound:\n\t\t;\n\t} else {\n\t\tcell = afs_cell_root;\n\t\tif (!cell) {\n\t\t\t/* this should not happen unless user tries to mount\n\t\t\t * when root cell is not set. Return an impossibly\n\t\t\t * bizarre errno to alert the user. Things like\n\t\t\t * ENOENT might be \"more appropriate\" but they happen\n\t\t\t * for other reasons.\n\t\t\t */\n\t\t\tcell = ERR_PTR(-EDESTADDRREQ);\n\t\t} else {\n\t\t\tafs_get_cell(cell);\n\t\t}\n\n\t}\n\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\ncreate_cell:\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\n\tcell = afs_cell_create(name, namesz, NULL, true);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_cells);",
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_RWSEM(afs_cells_sem);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(afs_cells);\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_RWSEM(afs_cells_sem);\nstatic struct afs_cell *afs_cell_root;\n\nstruct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,\n\t\t\t\t bool dns_cell)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\\\"%*.*s\\\",\", namesz, namesz, name ?: \"\");\n\n\tdown_read(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\n\tif (name) {\n\t\t/* if the cell was named, look for it in the cell record list */\n\t\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\t\tif (strncmp(cell->name, name, namesz) == 0) {\n\t\t\t\tafs_get_cell(cell);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tcell = ERR_PTR(-ENOENT);\n\t\tif (dns_cell)\n\t\t\tgoto create_cell;\n\tfound:\n\t\t;\n\t} else {\n\t\tcell = afs_cell_root;\n\t\tif (!cell) {\n\t\t\t/* this should not happen unless user tries to mount\n\t\t\t * when root cell is not set. Return an impossibly\n\t\t\t * bizarre errno to alert the user. Things like\n\t\t\t * ENOENT might be \"more appropriate\" but they happen\n\t\t\t * for other reasons.\n\t\t\t */\n\t\t\tcell = ERR_PTR(-EDESTADDRREQ);\n\t\t} else {\n\t\t\tafs_get_cell(cell);\n\t\t}\n\n\t}\n\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\ncreate_cell:\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\n\tcell = afs_cell_create(name, namesz, NULL, true);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "params->volname"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "suffix",
            "\".backup\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "params->volname",
            "'.'"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "':'"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kAFS: unparsable volume name\\n\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "name"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_parse_device_name(struct afs_mount_params *params,\n\t\t\t\t const char *name)\n{\n\tstruct afs_cell *cell;\n\tconst char *cellname, *suffix;\n\tint cellnamesz;\n\n\t_enter(\",%s\", name);\n\n\tif (!name) {\n\t\tprintk(KERN_ERR \"kAFS: no volume name specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((name[0] != '%' && name[0] != '#') || !name[1]) {\n\t\tprintk(KERN_ERR \"kAFS: unparsable volume name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine the type of volume we're looking for */\n\tparams->type = AFSVL_ROVOL;\n\tparams->force = false;\n\tif (params->rwpath || name[0] == '%') {\n\t\tparams->type = AFSVL_RWVOL;\n\t\tparams->force = true;\n\t}\n\tname++;\n\n\t/* split the cell name out if there is one */\n\tparams->volname = strchr(name, ':');\n\tif (params->volname) {\n\t\tcellname = name;\n\t\tcellnamesz = params->volname - name;\n\t\tparams->volname++;\n\t} else {\n\t\tparams->volname = name;\n\t\tcellname = NULL;\n\t\tcellnamesz = 0;\n\t}\n\n\t/* the volume type is further affected by a possible suffix */\n\tsuffix = strrchr(params->volname, '.');\n\tif (suffix) {\n\t\tif (strcmp(suffix, \".readonly\") == 0) {\n\t\t\tparams->type = AFSVL_ROVOL;\n\t\t\tparams->force = true;\n\t\t} else if (strcmp(suffix, \".backup\") == 0) {\n\t\t\tparams->type = AFSVL_BACKVOL;\n\t\t\tparams->force = true;\n\t\t} else if (suffix[1] == 0) {\n\t\t} else {\n\t\t\tsuffix = NULL;\n\t\t}\n\t}\n\n\tparams->volnamesz = suffix ?\n\t\tsuffix - params->volname : strlen(params->volname);\n\n\t_debug(\"cell %*.*s [%p]\",\n\t       cellnamesz, cellnamesz, cellname ?: \"\", params->cell);\n\n\t/* lookup the cell record */\n\tif (cellname || !params->cell) {\n\t\tcell = afs_cell_lookup(cellname, cellnamesz, true);\n\t\tif (IS_ERR(cell)) {\n\t\t\tprintk(KERN_ERR \"kAFS: unable to lookup cell '%*.*s'\\n\",\n\t\t\t       cellnamesz, cellnamesz, cellname ?: \"\");\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tafs_put_cell(params->cell);\n\t\tparams->cell = cell;\n\t}\n\n\t_debug(\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\",\n\t       params->cell->name, params->cell,\n\t       params->volnamesz, params->volnamesz, params->volname,\n\t       suffix ?: \"-\", params->type, params->force ? \" FORCE\" : \"\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "143-192",
    "snippet": "static int afs_parse_options(struct afs_mount_params *params,\n\t\t\t     char *options, const char **devname)\n{\n\tstruct afs_cell *cell;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint token;\n\n\t_enter(\"%s\", options);\n\n\toptions[PAGE_SIZE - 1] = 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, afs_options_list, args);\n\t\tswitch (token) {\n\t\tcase afs_opt_cell:\n\t\t\tcell = afs_cell_lookup(args[0].from,\n\t\t\t\t\t       args[0].to - args[0].from,\n\t\t\t\t\t       false);\n\t\t\tif (IS_ERR(cell))\n\t\t\t\treturn PTR_ERR(cell);\n\t\t\tafs_put_cell(params->cell);\n\t\t\tparams->cell = cell;\n\t\t\tbreak;\n\n\t\tcase afs_opt_rwpath:\n\t\t\tparams->rwpath = 1;\n\t\t\tbreak;\n\n\t\tcase afs_opt_vol:\n\t\t\t*devname = args[0].from;\n\t\t\tbreak;\n\n\t\tcase afs_opt_autocell:\n\t\t\tparams->autocell = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t\t       \" Unknown or invalid mount option: '%s'\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t afs_options_list = {\n\t{ afs_opt_cell,\t\t\"cell=%s\"\t},\n\t{ afs_opt_rwpath,\t\"rwpath\"\t},\n\t{ afs_opt_vol,\t\t\"vol=%s\"\t},\n\t{ afs_opt_autocell,\t\"autocell\"\t},\n\t{ afs_no_opt,\t\tNULL\t\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kAFS:\"\n\t\t\t       \" Unknown or invalid mount option: '%s'\\n\"",
            "p"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_cell",
          "args": [
            "params->cell"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_cell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "343-370",
          "snippet": "void afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);\n\nvoid afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cell"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cell"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_cell_lookup",
          "args": [
            "args[0].from",
            "args[0].to - args[0].from",
            "false"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "268-320",
          "snippet": "struct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,\n\t\t\t\t bool dns_cell)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\\\"%*.*s\\\",\", namesz, namesz, name ?: \"\");\n\n\tdown_read(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\n\tif (name) {\n\t\t/* if the cell was named, look for it in the cell record list */\n\t\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\t\tif (strncmp(cell->name, name, namesz) == 0) {\n\t\t\t\tafs_get_cell(cell);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tcell = ERR_PTR(-ENOENT);\n\t\tif (dns_cell)\n\t\t\tgoto create_cell;\n\tfound:\n\t\t;\n\t} else {\n\t\tcell = afs_cell_root;\n\t\tif (!cell) {\n\t\t\t/* this should not happen unless user tries to mount\n\t\t\t * when root cell is not set. Return an impossibly\n\t\t\t * bizarre errno to alert the user. Things like\n\t\t\t * ENOENT might be \"more appropriate\" but they happen\n\t\t\t * for other reasons.\n\t\t\t */\n\t\t\tcell = ERR_PTR(-EDESTADDRREQ);\n\t\t} else {\n\t\t\tafs_get_cell(cell);\n\t\t}\n\n\t}\n\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\ncreate_cell:\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\n\tcell = afs_cell_create(name, namesz, NULL, true);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_cells);",
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_RWSEM(afs_cells_sem);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(afs_cells);\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_RWSEM(afs_cells_sem);\nstatic struct afs_cell *afs_cell_root;\n\nstruct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,\n\t\t\t\t bool dns_cell)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\\\"%*.*s\\\",\", namesz, namesz, name ?: \"\");\n\n\tdown_read(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\n\tif (name) {\n\t\t/* if the cell was named, look for it in the cell record list */\n\t\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\t\tif (strncmp(cell->name, name, namesz) == 0) {\n\t\t\t\tafs_get_cell(cell);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tcell = ERR_PTR(-ENOENT);\n\t\tif (dns_cell)\n\t\t\tgoto create_cell;\n\tfound:\n\t\t;\n\t} else {\n\t\tcell = afs_cell_root;\n\t\tif (!cell) {\n\t\t\t/* this should not happen unless user tries to mount\n\t\t\t * when root cell is not set. Return an impossibly\n\t\t\t * bizarre errno to alert the user. Things like\n\t\t\t * ENOENT might be \"more appropriate\" but they happen\n\t\t\t * for other reasons.\n\t\t\t */\n\t\t\tcell = ERR_PTR(-EDESTADDRREQ);\n\t\t} else {\n\t\t\tafs_get_cell(cell);\n\t\t}\n\n\t}\n\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\ncreate_cell:\n\tread_unlock(&afs_cells_lock);\n\tup_read(&afs_cells_sem);\n\n\tcell = afs_cell_create(name, namesz, NULL, true);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "afs_options_list",
            "args"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s\"",
            "options"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const match_table_t afs_options_list = {\n\t{ afs_opt_cell,\t\t\"cell=%s\"\t},\n\t{ afs_opt_rwpath,\t\"rwpath\"\t},\n\t{ afs_opt_vol,\t\t\"vol=%s\"\t},\n\t{ afs_opt_autocell,\t\"autocell\"\t},\n\t{ afs_no_opt,\t\tNULL\t\t},\n};\n\nstatic int afs_parse_options(struct afs_mount_params *params,\n\t\t\t     char *options, const char **devname)\n{\n\tstruct afs_cell *cell;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint token;\n\n\t_enter(\"%s\", options);\n\n\toptions[PAGE_SIZE - 1] = 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, afs_options_list, args);\n\t\tswitch (token) {\n\t\tcase afs_opt_cell:\n\t\t\tcell = afs_cell_lookup(args[0].from,\n\t\t\t\t\t       args[0].to - args[0].from,\n\t\t\t\t\t       false);\n\t\t\tif (IS_ERR(cell))\n\t\t\t\treturn PTR_ERR(cell);\n\t\t\tafs_put_cell(params->cell);\n\t\t\tparams->cell = cell;\n\t\t\tbreak;\n\n\t\tcase afs_opt_rwpath:\n\t\t\tparams->rwpath = 1;\n\t\t\tbreak;\n\n\t\tcase afs_opt_vol:\n\t\t\t*devname = args[0].from;\n\t\t\tbreak;\n\n\t\tcase afs_opt_autocell:\n\t\t\tparams->autocell = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t\t       \" Unknown or invalid mount option: '%s'\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "116-136",
    "snippet": "void __exit afs_fs_exit(void)\n{\n\t_enter(\"\");\n\n\tafs_mntpt_kill_timer();\n\tunregister_filesystem(&afs_fs_type);\n\n\tif (atomic_read(&afs_count_active_inodes) != 0) {\n\t\tprintk(\"kAFS: %d active inode objects still present\\n\",\n\t\t       atomic_read(&afs_count_active_inodes));\n\t\tBUG();\n\t}\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(afs_inode_cachep);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_destroy_inode(struct inode *inode);",
      "struct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};",
      "static struct kmem_cache *afs_inode_cachep;",
      "static atomic_t afs_count_active_inodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "afs_inode_cachep"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: %d active inode objects still present\\n\"",
            "atomic_read(&afs_count_active_inodes)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_count_active_inodes"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_count_active_inodes"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&afs_fs_type"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_mntpt_kill_timer",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "afs_mntpt_kill_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/mntpt.c",
          "lines": "264-270",
          "snippet": "void afs_mntpt_kill_timer(void)\n{\n\t_enter(\"\");\n\n\tASSERT(list_empty(&afs_vfsmounts));\n\tcancel_delayed_work_sync(&afs_mntpt_expiry_timer);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_vfsmounts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(afs_vfsmounts);\n\nvoid afs_mntpt_kill_timer(void)\n{\n\t_enter(\"\");\n\n\tASSERT(list_empty(&afs_vfsmounts));\n\tcancel_delayed_work_sync(&afs_mntpt_expiry_timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstruct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nvoid __exit afs_fs_exit(void)\n{\n\t_enter(\"\");\n\n\tafs_mntpt_kill_timer();\n\tunregister_filesystem(&afs_fs_type);\n\n\tif (atomic_read(&afs_count_active_inodes) != 0) {\n\t\tprintk(\"kAFS: %d active inode objects still present\\n\",\n\t\t       atomic_read(&afs_count_active_inodes));\n\t\tBUG();\n\t}\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(afs_inode_cachep);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_fs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
    "lines": "81-111",
    "snippet": "int __init afs_fs_init(void)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* create ourselves an inode cache */\n\tatomic_set(&afs_count_active_inodes, 0);\n\n\tret = -ENOMEM;\n\tafs_inode_cachep = kmem_cache_create(\"afs_inode_cache\",\n\t\t\t\t\t     sizeof(struct afs_vnode),\n\t\t\t\t\t     0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     afs_i_init_once);\n\tif (!afs_inode_cachep) {\n\t\tprintk(KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\");\n\t\treturn ret;\n\t}\n\n\t/* now export our filesystem to lesser mortals */\n\tret = register_filesystem(&afs_fs_type);\n\tif (ret < 0) {\n\t\tkmem_cache_destroy(afs_inode_cachep);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/sched.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_destroy_inode(struct inode *inode);",
      "struct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};",
      "static struct kmem_cache *afs_inode_cachep;",
      "static atomic_t afs_count_active_inodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "afs_inode_cachep"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&afs_fs_type"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\""
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"afs_inode_cache\"",
            "sizeof(struct afs_vnode)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "afs_i_init_once"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&afs_count_active_inodes",
            "0"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstruct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nint __init afs_fs_init(void)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* create ourselves an inode cache */\n\tatomic_set(&afs_count_active_inodes, 0);\n\n\tret = -ENOMEM;\n\tafs_inode_cachep = kmem_cache_create(\"afs_inode_cache\",\n\t\t\t\t\t     sizeof(struct afs_vnode),\n\t\t\t\t\t     0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     afs_i_init_once);\n\tif (!afs_inode_cachep) {\n\t\tprintk(KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\");\n\t\treturn ret;\n\t}\n\n\t/* now export our filesystem to lesser mortals */\n\tret = register_filesystem(&afs_fs_type);\n\tif (ret < 0) {\n\t\tkmem_cache_destroy(afs_inode_cachep);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  }
]