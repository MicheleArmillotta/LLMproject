[
  {
    "function_name": "__ntfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2967-3110",
    "snippet": "int __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "ni->vol"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed (error %i):  Run chkdsk.\"",
            "-err"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "vi"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\""
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_mft_record",
          "args": [
            "tni",
            "tm",
            "sync"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "write_mft_record_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "669-844",
          "snippet": "int write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tm"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tm"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "tni"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Writing %i extent inodes.\"",
            "ni->nr_extents"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "ni"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_ntfs_record_dirty",
          "args": [
            "ctx->ntfs_ino->page",
            "ctx->ntfs_ino->page_ofs"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "mark_ntfs_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "1729-1775",
          "snippet": "void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoTestSetDirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\"",
            "vi->i_ino",
            "(long long)sle64_to_cpu(si->last_access_time)",
            "(long long)sle64_to_cpu(nt)"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "nt"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utc2ntfs",
          "args": [
            "vi->i_atime"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "utc2ntfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/time.h",
          "lines": "48-56",
          "snippet": "static inline sle64 utc2ntfs(const struct timespec ts)\n{\n\t/*\n\t * Convert the seconds to 100ns intervals, add the nano-seconds\n\t * converted to 100ns intervals, and then add the NTFS time offset.\n\t */\n\treturn cpu_to_sle64((s64)ts.tv_sec * 10000000 + ts.tv_nsec / 100 +\n\t\t\tNTFS_TIME_OFFSET);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include <asm/div64.h>\t\t/* For do_div(). */",
            "#include <linux/time.h>\t\t/* For current_kernel_time(). */"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include <asm/div64.h>\t\t/* For do_div(). */\n#include <linux/time.h>\t\t/* For current_kernel_time(). */\n\n#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)\n\nstatic inline sle64 utc2ntfs(const struct timespec ts)\n{\n\t/*\n\t * Convert the seconds to 100ns intervals, add the nano-seconds\n\t * converted to 100ns intervals, and then add the NTFS time offset.\n\t */\n\treturn cpu_to_sle64((s64)ts.tv_sec * 10000000 + ts.tv_nsec / 100 +\n\t\t\tNTFS_TIME_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_offset"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_STANDARD_INFORMATION",
            "NULL",
            "0",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "m"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoClearDirty",
          "args": [
            "ni"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for %sinode 0x%lx.\"",
            "NInoAttr(ni) ? \"attr \" : \"\"",
            "vi->i_ino"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2891-2947",
    "snippet": "int ntfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *vi = dentry->d_inode;\n\tint err;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\terr = inode_change_ok(vi, attr);\n\tif (err)\n\t\tgoto out;\n\t/* We do not support NTFS ACLs yet. */\n\tif (ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in user/group/mode are not \"\n\t\t\t\t\"supported yet, ignoring.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tif (attr->ia_size != i_size_read(vi)) {\n\t\t\tntfs_inode *ni = NTFS_I(vi);\n\t\t\t/*\n\t\t\t * FIXME: For now we do not support resizing of\n\t\t\t * compressed or encrypted files yet.\n\t\t\t */\n\t\t\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\t\t\tntfs_warning(vi->i_sb, \"Changes in inode size \"\n\t\t\t\t\t\t\"are not supported yet for \"\n\t\t\t\t\t\t\"%s files, ignoring.\",\n\t\t\t\t\t\tNInoCompressed(ni) ?\n\t\t\t\t\t\t\"compressed\" : \"encrypted\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t} else {\n\t\t\t\ttruncate_setsize(vi, attr->ia_size);\n\t\t\t\tntfs_truncate_vfs(vi);\n\t\t\t}\n\t\t\tif (err || ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We skipped the truncate but must still update\n\t\t\t * timestamps.\n\t\t\t */\n\t\t\tia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_ATIME)\n\t\tvi->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tvi->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tvi->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tmark_inode_dirty(vi);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "vi"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_ctime",
            "vi->i_sb->s_time_gran"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_mtime",
            "vi->i_sb->s_time_gran"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_atime",
            "vi->i_sb->s_time_gran"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_truncate_vfs",
          "args": [
            "vi"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_truncate_vfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2872-2874",
          "snippet": "void ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nvoid ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "vi",
            "attr->ia_size"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Changes in inode size \"\n\t\t\t\t\t\t\"are not supported yet for \"\n\t\t\t\t\t\t\"%s files, ignoring.\"",
            "NInoCompressed(ni) ?\n\t\t\t\t\t\t\"compressed\" : \"encrypted\""
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Changes in user/group/mode are not \"\n\t\t\t\t\"supported yet, ignoring.\""
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "vi",
            "attr"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint ntfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *vi = dentry->d_inode;\n\tint err;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\terr = inode_change_ok(vi, attr);\n\tif (err)\n\t\tgoto out;\n\t/* We do not support NTFS ACLs yet. */\n\tif (ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in user/group/mode are not \"\n\t\t\t\t\"supported yet, ignoring.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tif (attr->ia_size != i_size_read(vi)) {\n\t\t\tntfs_inode *ni = NTFS_I(vi);\n\t\t\t/*\n\t\t\t * FIXME: For now we do not support resizing of\n\t\t\t * compressed or encrypted files yet.\n\t\t\t */\n\t\t\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\t\t\tntfs_warning(vi->i_sb, \"Changes in inode size \"\n\t\t\t\t\t\t\"are not supported yet for \"\n\t\t\t\t\t\t\"%s files, ignoring.\",\n\t\t\t\t\t\tNInoCompressed(ni) ?\n\t\t\t\t\t\t\"compressed\" : \"encrypted\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t} else {\n\t\t\t\ttruncate_setsize(vi, attr->ia_size);\n\t\t\t\tntfs_truncate_vfs(vi);\n\t\t\t}\n\t\t\tif (err || ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We skipped the truncate but must still update\n\t\t\t * timestamps.\n\t\t\t */\n\t\t\tia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_ATIME)\n\t\tvi->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tvi->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tvi->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\tvi->i_sb->s_time_gran);\n\tmark_inode_dirty(vi);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_truncate_vfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2872-2874",
    "snippet": "void ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_truncate",
          "args": [
            "vi"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_truncate_vfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2872-2874",
          "snippet": "void ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nvoid ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}"
  },
  {
    "function_name": "ntfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2364-2861",
    "snippet": "int ntfs_truncate(struct inode *vi)\n{\n\ts64 new_size, old_size, nr_freed, new_alloc_size, old_alloc_size;\n\tVCN highest_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni, *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tconst char *te = \"  Leaving file length out of sync with i_size.\";\n\tint err, mp_size, size_change, alloc_change;\n\tu32 attr_len;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tBUG_ON(NInoMstProtected(ni));\n\tBUG_ON(ni->nr_extents < 0);\nretry_truncate:\n\t/*\n\t * Lock the runlist for writing and map the mft record to ensure it is\n\t * safe to mess with the attribute runlist and sizes.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tntfs_error(vi->i_sb, \"Failed to map mft record for inode 0x%lx \"\n\t\t\t\t\"(error code %d).%s\", vi->i_ino, err, te);\n\t\tctx = NULL;\n\t\tm = NULL;\n\t\tgoto old_bad_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate a search context for \"\n\t\t\t\t\"inode 0x%lx (not enough memory).%s\",\n\t\t\t\tvi->i_ino, te);\n\t\terr = -ENOMEM;\n\t\tgoto old_bad_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(vi->i_sb, \"Open attribute is missing from \"\n\t\t\t\t\t\"mft record.  Inode 0x%lx is corrupt.  \"\n\t\t\t\t\t\"Run chkdsk.%s\", vi->i_ino, te);\n\t\t\terr = -EIO;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute in \"\n\t\t\t\t\t\"inode 0x%lx (error code %d).%s\",\n\t\t\t\t\tvi->i_ino, err, te);\n\t\tgoto old_bad_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * The i_size of the vfs inode is the new size for the attribute value.\n\t */\n\tnew_size = i_size_read(vi);\n\t/* The current size of the attribute value is the old size. */\n\told_size = ntfs_attr_size(a);\n\t/* Calculate the new allocated size. */\n\tif (NInoNonResident(ni))\n\t\tnew_alloc_size = (new_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\telse\n\t\tnew_alloc_size = (new_size + 7) & ~7;\n\t/* The current allocated size is the old allocated size. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_alloc_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * The change in the file size.  This will be 0 if no change, >0 if the\n\t * size is growing, and <0 if the size is shrinking.\n\t */\n\tsize_change = -1;\n\tif (new_size - old_size >= 0) {\n\t\tsize_change = 1;\n\t\tif (new_size == old_size)\n\t\t\tsize_change = 0;\n\t}\n\t/* As above for the allocated size. */\n\talloc_change = -1;\n\tif (new_alloc_size - old_alloc_size >= 0) {\n\t\talloc_change = 1;\n\t\tif (new_alloc_size == old_alloc_size)\n\t\t\talloc_change = 0;\n\t}\n\t/*\n\t * If neither the size nor the allocation are being changed there is\n\t * nothing to do.\n\t */\n\tif (!size_change && !alloc_change)\n\t\tgoto unm_done;\n\t/* If the size is changing, check if new size is allowed in $AttrDef. */\n\tif (size_change) {\n\t\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_size);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Truncate would cause the \"\n\t\t\t\t\t\t\"inode 0x%lx to %simum size \"\n\t\t\t\t\t\t\"for its attribute type \"\n\t\t\t\t\t\t\"(0x%x).  Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tnew_size > old_size ? \"exceed \"\n\t\t\t\t\t\t\"the max\" : \"go under the min\",\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EFBIG;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Inode 0x%lx has unknown \"\n\t\t\t\t\t\t\"attribute type 0x%x.  \"\n\t\t\t\t\t\t\"Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\t/* Reset the vfs inode size to the old size. */\n\t\t\ti_size_write(vi, old_size);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in inode size are not \"\n\t\t\t\t\"supported yet for %s files, ignoring.\",\n\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\"encrypted\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto bad_out;\n\t}\n\tif (a->non_resident)\n\t\tgoto do_non_resident_truncate;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Resize the attribute record to best fit the new attribute size. */\n\tif (new_size < vol->mft_record_size &&\n\t\t\t!ntfs_resident_attr_value_resize(m, a, new_size)) {\n\t\t/* The resize succeeded! */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t/* Update the sizes in the ntfs inode and all is done. */\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\t/*\n\t\t * Note ntfs_resident_attr_value_resize() has already done any\n\t\t * necessary data clearing in the attribute record.  When the\n\t\t * file is being shrunk vmtruncate() will already have cleared\n\t\t * the top part of the last partial page, i.e. since this is\n\t\t * the resident case this is the page with index 0.  However,\n\t\t * when the file is being expanded, the page cache page data\n\t\t * between the old data_size, i.e. old_size, and the new_size\n\t\t * has not been zeroed.  Fortunately, we do not need to zero it\n\t\t * either since on one hand it will either already be zero due\n\t\t * to both readpage and writepage clearing partial page data\n\t\t * beyond i_size in which case there is nothing to do or in the\n\t\t * case of the file being mmap()ped at the same time, POSIX\n\t\t * specifies that the behaviour is unspecified thus we do not\n\t\t * have to do anything.  This means that in our implementation\n\t\t * in the rare case that the file is mmap()ped and a write\n\t\t * occurred into the mmap()ped region just beyond the file size\n\t\t * and writepage has not yet been called to write out the page\n\t\t * (which would clear the area beyond the file size) and we now\n\t\t * extend the file size to incorporate this dirty region\n\t\t * outside the file size, a write of the page would result in\n\t\t * this data being written to disk instead of being cleared.\n\t\t * Given both POSIX and the Linux mmap(2) man page specify that\n\t\t * this corner case is undefined, we choose to leave it like\n\t\t * that as this is much simpler for us as we cannot lock the\n\t\t * relevant page now since we are holding too many ntfs locks\n\t\t * which would result in a lock reversal deadlock.\n\t\t */\n\t\tni->initialized_size = new_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tgoto unm_done;\n\t}\n\t/* If the above resize failed, this must be an attribute extension. */\n\tBUG_ON(size_change < 0);\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path as it only ever can happen\n\t * once for any given file.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the truncation process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, old_size);\n\tif (likely(!err))\n\t\tgoto retry_truncate;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, attribute \"\n\t\t\t\t\"type 0x%x, because the conversion from \"\n\t\t\t\t\"resident to non-resident attribute failed \"\n\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tif (err == -ENOSPC)\n\t\tntfs_error(vol->sb, \"Not enough space in the mft record/on \"\n\t\t\t\t\"disk for the non-resident attribute value.  \"\n\t\t\t\t\"This case is not implemented yet.\");\n\telse /* if (err == -EPERM) */\n\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\"non-resident.  This case is not implemented \"\n\t\t\t\t\"yet.\");\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_truncate:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (alloc_change < 0) {\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tif (highest_vcn > 0 &&\n\t\t\t\told_alloc_size >> vol->cluster_size_bits >\n\t\t\t\thighest_vcn + 1) {\n\t\t\t/*\n\t\t\t * This attribute has multiple extents.  Not yet\n\t\t\t * supported.\n\t\t\t */\n\t\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because the \"\n\t\t\t\t\t\"attribute is highly fragmented (it \"\n\t\t\t\t\t\"consists of multiple extents) and \"\n\t\t\t\t\t\"this case is not implemented yet.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type));\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto bad_out;\n\t\t}\n\t}\n\t/*\n\t * If the size is shrinking, need to reduce the initialized_size and\n\t * the data_size before reducing the allocation.\n\t */\n\tif (size_change < 0) {\n\t\t/*\n\t\t * Make the valid size smaller (i_size is already up-to-date).\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tif (new_size < ni->initialized_size) {\n\t\t\tni->initialized_size = new_size;\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\t\t\tcpu_to_sle64(new_size);\n\t\t}\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* If the allocated size is not changing, we are done. */\n\t\tif (!alloc_change)\n\t\t\tgoto unm_done;\n\t\t/*\n\t\t * If the size is shrinking it makes no sense for the\n\t\t * allocation to be growing.\n\t\t */\n\t\tBUG_ON(alloc_change > 0);\n\t} else /* if (size_change >= 0) */ {\n\t\t/*\n\t\t * The file size is growing or staying the same but the\n\t\t * allocation can be shrinking, growing or staying the same.\n\t\t */\n\t\tif (alloc_change > 0) {\n\t\t\t/*\n\t\t\t * We need to extend the allocation and possibly update\n\t\t\t * the data size.  If we are updating the data size,\n\t\t\t * since we are not touching the initialized_size we do\n\t\t\t * not need to worry about the actual data on disk.\n\t\t\t * And as far as the page cache is concerned, there\n\t\t\t * will be no pages beyond the old data size and any\n\t\t\t * partial region in the last page between the old and\n\t\t\t * new data size (or the end of the page if the new\n\t\t\t * data size is outside the page) does not need to be\n\t\t\t * modified as explained above for the resident\n\t\t\t * attribute truncate case.  To do this, we simply drop\n\t\t\t * the locks we hold and leave all the work to our\n\t\t\t * friendly helper ntfs_attr_extend_allocation().\n\t\t\t */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\terr = ntfs_attr_extend_allocation(ni, new_size,\n\t\t\t\t\tsize_change > 0 ? new_size : -1, -1);\n\t\t\t/*\n\t\t\t * ntfs_attr_extend_allocation() will have done error\n\t\t\t * output already.\n\t\t\t */\n\t\t\tgoto done;\n\t\t}\n\t\tif (!alloc_change)\n\t\t\tgoto alloc_done;\n\t}\n\t/* alloc_change < 0 */\n\t/* Free the clusters. */\n\tnr_freed = ntfs_cluster_free(ni, new_alloc_size >>\n\t\t\tvol->cluster_size_bits, -1, ctx);\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tif (unlikely(nr_freed < 0)) {\n\t\tntfs_error(vol->sb, \"Failed to release cluster(s) (error code \"\n\t\t\t\t\"%lli).  Unmount and run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\", (long long)nr_freed);\n\t\tNVolSetErrors(vol);\n\t\tnr_freed = 0;\n\t}\n\t/* Truncate the runlist. */\n\terr = ntfs_rl_truncate_nolock(vol, &ni->runlist,\n\t\t\tnew_alloc_size >> vol->cluster_size_bits);\n\t/*\n\t * If the runlist truncation failed and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (unlikely(err || IS_ERR(m))) {\n\t\tntfs_error(vol->sb, \"Failed to %s (error code %li).%s\",\n\t\t\t\tIS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\",\n\t\t\t\tIS_ERR(m) ? PTR_ERR(m) : err, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/* Get the size for the shrunk mapping pairs array for the runlist. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, ni->runlist.rl, 0, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because determining the \"\n\t\t\t\t\"size for the mapping pairs failed with error \"\n\t\t\t\t\"code %i.%s\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), mp_size, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/*\n\t * Shrink the attribute record for the new mapping pairs array.  Note,\n\t * this cannot fail since we are making the attribute smaller thus by\n\t * definition there is enough space to do so.\n\t */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tBUG_ON(err);\n\t/*\n\t * Generate the mapping pairs array directly into the attribute record.\n\t */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, ni->runlist.rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because building the \"\n\t\t\t\t\"mapping pairs failed with error code %i.%s\",\n\t\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t\terr, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/* Update the allocated/compressed size as well as the highest vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tif (nr_freed) {\n\t\t\tni->itype.compressed.size -= nr_freed <<\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tBUG_ON(ni->itype.compressed.size < 0);\n\t\t\ta->data.non_resident.compressed_size = cpu_to_sle64(\n\t\t\t\t\tni->itype.compressed.size);\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t}\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * We have shrunk the allocation.  If this is a shrinking truncate we\n\t * have already dealt with the initialized_size and the data_size above\n\t * and we are done.  If the truncate is only changing the allocation\n\t * and not the data_size, we are also done.  If this is an extending\n\t * truncate, need to extend the data_size now which is ensured by the\n\t * fact that @size_change is positive.\n\t */\nalloc_done:\n\t/*\n\t * If the size is growing, need to update it now.  If it is shrinking,\n\t * we have already updated it above (before the allocation change).\n\t */\n\tif (size_change > 0)\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t/* Ensure the modified mft record is written out. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nunm_done:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\ndone:\n\t/* Update the mtime and ctime on the base inode. */\n\t/* normally ->truncate shouldn't update ctime or mtime,\n\t * but ntfs did before so it got a copy & paste version\n\t * of file_update_time.  one day someone should fix this\n\t * for real.\n\t */\n\tif (!IS_NOCMTIME(VFS_I(base_ni)) && !IS_RDONLY(VFS_I(base_ni))) {\n\t\tstruct timespec now = current_fs_time(VFS_I(base_ni)->i_sb);\n\t\tint sync_it = 0;\n\n\t\tif (!timespec_equal(&VFS_I(base_ni)->i_mtime, &now) ||\n\t\t    !timespec_equal(&VFS_I(base_ni)->i_ctime, &now))\n\t\t\tsync_it = 1;\n\t\tVFS_I(base_ni)->i_mtime = now;\n\t\tVFS_I(base_ni)->i_ctime = now;\n\n\t\tif (sync_it)\n\t\t\tmark_inode_dirty_sync(VFS_I(base_ni));\n\t}\n\n\tif (likely(!err)) {\n\t\tNInoClearTruncateFailed(ni);\n\t\tntfs_debug(\"Done.\");\n\t}\n\treturn err;\nold_bad_out:\n\told_size = -1;\nbad_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse if (old_size >= 0)\n\t\ti_size_write(vi, old_size);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nout:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\nconv_err_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse\n\t\ti_size_write(vi, old_size);\n\tgoto out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vi",
            "old_size"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetTruncateFailed",
          "args": [
            "ni"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed.  Returning error code %i.\"",
            "err"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetTruncateFailed",
          "args": [
            "ni"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoClearTruncateFailed",
          "args": [
            "ni"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "VFS_I(base_ni)"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "base_ni"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&VFS_I(base_ni)->i_ctime",
            "&now"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&VFS_I(base_ni)->i_mtime",
            "&now"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "VFS_I(base_ni)->i_sb"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "VFS_I(base_ni)"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOCMTIME",
          "args": [
            "VFS_I(base_ni)"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "new_size"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->itype.compressed.size < 0"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because building the \"\n\t\t\t\t\"mapping pairs failed with error code %i.%s\"",
            "vi->i_ino",
            "(unsigned)le32_to_cpu(ni->type)",
            "err",
            "es"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ni->type"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset)",
            "mp_size",
            "ni->runlist.rl",
            "0",
            "-1",
            "NULL"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.mapping_pairs_offset"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "m",
            "a",
            "mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset)"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size <= 0"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "ni->runlist.rl",
            "0",
            "-1"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err || IS_ERR(m)"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_truncate_nolock",
          "args": [
            "vol",
            "&ni->runlist",
            "new_alloc_size >> vol->cluster_size_bits"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1499-1621",
          "snippet": "int ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_freed < 0"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free",
          "args": [
            "ni",
            "new_alloc_size >>\n\t\t\tvol->cluster_size_bits",
            "-1",
            "ctx"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "107-111",
          "snippet": "static inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_extend_allocation",
          "args": [
            "ni",
            "new_size",
            "size_change > 0 ? new_size : -1",
            "-1"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1904-2471",
          "snippet": "s64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\ns64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "alloc_change > 0"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.highest_vcn"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"This attribute type may not be \"\n\t\t\t\t\"non-resident.  This case is not implemented \"\n\t\t\t\t\"yet.\""
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in the mft record/on \"\n\t\t\t\t\"disk for the non-resident attribute value.  \"\n\t\t\t\t\"This case is not implemented yet.\""
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -EPERM && err != -ENOSPC"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_make_non_resident",
          "args": [
            "ni",
            "old_size"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_make_non_resident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1535-1843",
          "snippet": "int ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size_change < 0"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_resident_attr_value_resize",
          "args": [
            "m",
            "a",
            "new_size"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_resident_attr_value_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1479-1499",
          "snippet": "int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Changes in inode size are not \"\n\t\t\t\t\"supported yet for %s files, ignoring.\"",
            "NInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\"encrypted\""
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_size_bounds_check",
          "args": [
            "vol",
            "ni->type",
            "new_size"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_size_bounds_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1342-1365",
          "snippet": "int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_size",
          "args": [
            "a"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.h",
          "lines": "81-86",
          "snippet": "static inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include \"endian.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include \"endian.h\"\n\nstatic inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->nr_extents < 0"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoMstProtected(ni)"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "S_ISDIR(vi->i_mode)"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vi->i_mode"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(ni)"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint ntfs_truncate(struct inode *vi)\n{\n\ts64 new_size, old_size, nr_freed, new_alloc_size, old_alloc_size;\n\tVCN highest_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni, *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tconst char *te = \"  Leaving file length out of sync with i_size.\";\n\tint err, mp_size, size_change, alloc_change;\n\tu32 attr_len;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tBUG_ON(NInoMstProtected(ni));\n\tBUG_ON(ni->nr_extents < 0);\nretry_truncate:\n\t/*\n\t * Lock the runlist for writing and map the mft record to ensure it is\n\t * safe to mess with the attribute runlist and sizes.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tntfs_error(vi->i_sb, \"Failed to map mft record for inode 0x%lx \"\n\t\t\t\t\"(error code %d).%s\", vi->i_ino, err, te);\n\t\tctx = NULL;\n\t\tm = NULL;\n\t\tgoto old_bad_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate a search context for \"\n\t\t\t\t\"inode 0x%lx (not enough memory).%s\",\n\t\t\t\tvi->i_ino, te);\n\t\terr = -ENOMEM;\n\t\tgoto old_bad_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(vi->i_sb, \"Open attribute is missing from \"\n\t\t\t\t\t\"mft record.  Inode 0x%lx is corrupt.  \"\n\t\t\t\t\t\"Run chkdsk.%s\", vi->i_ino, te);\n\t\t\terr = -EIO;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute in \"\n\t\t\t\t\t\"inode 0x%lx (error code %d).%s\",\n\t\t\t\t\tvi->i_ino, err, te);\n\t\tgoto old_bad_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * The i_size of the vfs inode is the new size for the attribute value.\n\t */\n\tnew_size = i_size_read(vi);\n\t/* The current size of the attribute value is the old size. */\n\told_size = ntfs_attr_size(a);\n\t/* Calculate the new allocated size. */\n\tif (NInoNonResident(ni))\n\t\tnew_alloc_size = (new_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\telse\n\t\tnew_alloc_size = (new_size + 7) & ~7;\n\t/* The current allocated size is the old allocated size. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_alloc_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * The change in the file size.  This will be 0 if no change, >0 if the\n\t * size is growing, and <0 if the size is shrinking.\n\t */\n\tsize_change = -1;\n\tif (new_size - old_size >= 0) {\n\t\tsize_change = 1;\n\t\tif (new_size == old_size)\n\t\t\tsize_change = 0;\n\t}\n\t/* As above for the allocated size. */\n\talloc_change = -1;\n\tif (new_alloc_size - old_alloc_size >= 0) {\n\t\talloc_change = 1;\n\t\tif (new_alloc_size == old_alloc_size)\n\t\t\talloc_change = 0;\n\t}\n\t/*\n\t * If neither the size nor the allocation are being changed there is\n\t * nothing to do.\n\t */\n\tif (!size_change && !alloc_change)\n\t\tgoto unm_done;\n\t/* If the size is changing, check if new size is allowed in $AttrDef. */\n\tif (size_change) {\n\t\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_size);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Truncate would cause the \"\n\t\t\t\t\t\t\"inode 0x%lx to %simum size \"\n\t\t\t\t\t\t\"for its attribute type \"\n\t\t\t\t\t\t\"(0x%x).  Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tnew_size > old_size ? \"exceed \"\n\t\t\t\t\t\t\"the max\" : \"go under the min\",\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EFBIG;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Inode 0x%lx has unknown \"\n\t\t\t\t\t\t\"attribute type 0x%x.  \"\n\t\t\t\t\t\t\"Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\t/* Reset the vfs inode size to the old size. */\n\t\t\ti_size_write(vi, old_size);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in inode size are not \"\n\t\t\t\t\"supported yet for %s files, ignoring.\",\n\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\"encrypted\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto bad_out;\n\t}\n\tif (a->non_resident)\n\t\tgoto do_non_resident_truncate;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Resize the attribute record to best fit the new attribute size. */\n\tif (new_size < vol->mft_record_size &&\n\t\t\t!ntfs_resident_attr_value_resize(m, a, new_size)) {\n\t\t/* The resize succeeded! */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t/* Update the sizes in the ntfs inode and all is done. */\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\t/*\n\t\t * Note ntfs_resident_attr_value_resize() has already done any\n\t\t * necessary data clearing in the attribute record.  When the\n\t\t * file is being shrunk vmtruncate() will already have cleared\n\t\t * the top part of the last partial page, i.e. since this is\n\t\t * the resident case this is the page with index 0.  However,\n\t\t * when the file is being expanded, the page cache page data\n\t\t * between the old data_size, i.e. old_size, and the new_size\n\t\t * has not been zeroed.  Fortunately, we do not need to zero it\n\t\t * either since on one hand it will either already be zero due\n\t\t * to both readpage and writepage clearing partial page data\n\t\t * beyond i_size in which case there is nothing to do or in the\n\t\t * case of the file being mmap()ped at the same time, POSIX\n\t\t * specifies that the behaviour is unspecified thus we do not\n\t\t * have to do anything.  This means that in our implementation\n\t\t * in the rare case that the file is mmap()ped and a write\n\t\t * occurred into the mmap()ped region just beyond the file size\n\t\t * and writepage has not yet been called to write out the page\n\t\t * (which would clear the area beyond the file size) and we now\n\t\t * extend the file size to incorporate this dirty region\n\t\t * outside the file size, a write of the page would result in\n\t\t * this data being written to disk instead of being cleared.\n\t\t * Given both POSIX and the Linux mmap(2) man page specify that\n\t\t * this corner case is undefined, we choose to leave it like\n\t\t * that as this is much simpler for us as we cannot lock the\n\t\t * relevant page now since we are holding too many ntfs locks\n\t\t * which would result in a lock reversal deadlock.\n\t\t */\n\t\tni->initialized_size = new_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tgoto unm_done;\n\t}\n\t/* If the above resize failed, this must be an attribute extension. */\n\tBUG_ON(size_change < 0);\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path as it only ever can happen\n\t * once for any given file.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the truncation process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, old_size);\n\tif (likely(!err))\n\t\tgoto retry_truncate;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, attribute \"\n\t\t\t\t\"type 0x%x, because the conversion from \"\n\t\t\t\t\"resident to non-resident attribute failed \"\n\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tif (err == -ENOSPC)\n\t\tntfs_error(vol->sb, \"Not enough space in the mft record/on \"\n\t\t\t\t\"disk for the non-resident attribute value.  \"\n\t\t\t\t\"This case is not implemented yet.\");\n\telse /* if (err == -EPERM) */\n\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\"non-resident.  This case is not implemented \"\n\t\t\t\t\"yet.\");\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_truncate:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (alloc_change < 0) {\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tif (highest_vcn > 0 &&\n\t\t\t\told_alloc_size >> vol->cluster_size_bits >\n\t\t\t\thighest_vcn + 1) {\n\t\t\t/*\n\t\t\t * This attribute has multiple extents.  Not yet\n\t\t\t * supported.\n\t\t\t */\n\t\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because the \"\n\t\t\t\t\t\"attribute is highly fragmented (it \"\n\t\t\t\t\t\"consists of multiple extents) and \"\n\t\t\t\t\t\"this case is not implemented yet.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type));\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto bad_out;\n\t\t}\n\t}\n\t/*\n\t * If the size is shrinking, need to reduce the initialized_size and\n\t * the data_size before reducing the allocation.\n\t */\n\tif (size_change < 0) {\n\t\t/*\n\t\t * Make the valid size smaller (i_size is already up-to-date).\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tif (new_size < ni->initialized_size) {\n\t\t\tni->initialized_size = new_size;\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\t\t\tcpu_to_sle64(new_size);\n\t\t}\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* If the allocated size is not changing, we are done. */\n\t\tif (!alloc_change)\n\t\t\tgoto unm_done;\n\t\t/*\n\t\t * If the size is shrinking it makes no sense for the\n\t\t * allocation to be growing.\n\t\t */\n\t\tBUG_ON(alloc_change > 0);\n\t} else /* if (size_change >= 0) */ {\n\t\t/*\n\t\t * The file size is growing or staying the same but the\n\t\t * allocation can be shrinking, growing or staying the same.\n\t\t */\n\t\tif (alloc_change > 0) {\n\t\t\t/*\n\t\t\t * We need to extend the allocation and possibly update\n\t\t\t * the data size.  If we are updating the data size,\n\t\t\t * since we are not touching the initialized_size we do\n\t\t\t * not need to worry about the actual data on disk.\n\t\t\t * And as far as the page cache is concerned, there\n\t\t\t * will be no pages beyond the old data size and any\n\t\t\t * partial region in the last page between the old and\n\t\t\t * new data size (or the end of the page if the new\n\t\t\t * data size is outside the page) does not need to be\n\t\t\t * modified as explained above for the resident\n\t\t\t * attribute truncate case.  To do this, we simply drop\n\t\t\t * the locks we hold and leave all the work to our\n\t\t\t * friendly helper ntfs_attr_extend_allocation().\n\t\t\t */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\terr = ntfs_attr_extend_allocation(ni, new_size,\n\t\t\t\t\tsize_change > 0 ? new_size : -1, -1);\n\t\t\t/*\n\t\t\t * ntfs_attr_extend_allocation() will have done error\n\t\t\t * output already.\n\t\t\t */\n\t\t\tgoto done;\n\t\t}\n\t\tif (!alloc_change)\n\t\t\tgoto alloc_done;\n\t}\n\t/* alloc_change < 0 */\n\t/* Free the clusters. */\n\tnr_freed = ntfs_cluster_free(ni, new_alloc_size >>\n\t\t\tvol->cluster_size_bits, -1, ctx);\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tif (unlikely(nr_freed < 0)) {\n\t\tntfs_error(vol->sb, \"Failed to release cluster(s) (error code \"\n\t\t\t\t\"%lli).  Unmount and run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\", (long long)nr_freed);\n\t\tNVolSetErrors(vol);\n\t\tnr_freed = 0;\n\t}\n\t/* Truncate the runlist. */\n\terr = ntfs_rl_truncate_nolock(vol, &ni->runlist,\n\t\t\tnew_alloc_size >> vol->cluster_size_bits);\n\t/*\n\t * If the runlist truncation failed and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (unlikely(err || IS_ERR(m))) {\n\t\tntfs_error(vol->sb, \"Failed to %s (error code %li).%s\",\n\t\t\t\tIS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\",\n\t\t\t\tIS_ERR(m) ? PTR_ERR(m) : err, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/* Get the size for the shrunk mapping pairs array for the runlist. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, ni->runlist.rl, 0, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because determining the \"\n\t\t\t\t\"size for the mapping pairs failed with error \"\n\t\t\t\t\"code %i.%s\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), mp_size, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/*\n\t * Shrink the attribute record for the new mapping pairs array.  Note,\n\t * this cannot fail since we are making the attribute smaller thus by\n\t * definition there is enough space to do so.\n\t */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tBUG_ON(err);\n\t/*\n\t * Generate the mapping pairs array directly into the attribute record.\n\t */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, ni->runlist.rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because building the \"\n\t\t\t\t\"mapping pairs failed with error code %i.%s\",\n\t\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t\terr, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t/* Update the allocated/compressed size as well as the highest vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tif (nr_freed) {\n\t\t\tni->itype.compressed.size -= nr_freed <<\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tBUG_ON(ni->itype.compressed.size < 0);\n\t\t\ta->data.non_resident.compressed_size = cpu_to_sle64(\n\t\t\t\t\tni->itype.compressed.size);\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t}\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * We have shrunk the allocation.  If this is a shrinking truncate we\n\t * have already dealt with the initialized_size and the data_size above\n\t * and we are done.  If the truncate is only changing the allocation\n\t * and not the data_size, we are also done.  If this is an extending\n\t * truncate, need to extend the data_size now which is ensured by the\n\t * fact that @size_change is positive.\n\t */\nalloc_done:\n\t/*\n\t * If the size is growing, need to update it now.  If it is shrinking,\n\t * we have already updated it above (before the allocation change).\n\t */\n\tif (size_change > 0)\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t/* Ensure the modified mft record is written out. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nunm_done:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\ndone:\n\t/* Update the mtime and ctime on the base inode. */\n\t/* normally ->truncate shouldn't update ctime or mtime,\n\t * but ntfs did before so it got a copy & paste version\n\t * of file_update_time.  one day someone should fix this\n\t * for real.\n\t */\n\tif (!IS_NOCMTIME(VFS_I(base_ni)) && !IS_RDONLY(VFS_I(base_ni))) {\n\t\tstruct timespec now = current_fs_time(VFS_I(base_ni)->i_sb);\n\t\tint sync_it = 0;\n\n\t\tif (!timespec_equal(&VFS_I(base_ni)->i_mtime, &now) ||\n\t\t    !timespec_equal(&VFS_I(base_ni)->i_ctime, &now))\n\t\t\tsync_it = 1;\n\t\tVFS_I(base_ni)->i_mtime = now;\n\t\tVFS_I(base_ni)->i_ctime = now;\n\n\t\tif (sync_it)\n\t\t\tmark_inode_dirty_sync(VFS_I(base_ni));\n\t}\n\n\tif (likely(!err)) {\n\t\tNInoClearTruncateFailed(ni);\n\t\tntfs_debug(\"Done.\");\n\t}\n\treturn err;\nold_bad_out:\n\told_size = -1;\nbad_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse if (old_size >= 0)\n\t\ti_size_write(vi, old_size);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nout:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\nconv_err_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse\n\t\ti_size_write(vi, old_size);\n\tgoto out;\n}"
  },
  {
    "function_name": "ntfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2313-2339",
    "snippet": "int ntfs_show_options(struct seq_file *sf, struct dentry *root)\n{\n\tntfs_volume *vol = NTFS_SB(root->d_sb);\n\tint i;\n\n\tseq_printf(sf, \",uid=%i\", from_kuid_munged(&init_user_ns, vol->uid));\n\tseq_printf(sf, \",gid=%i\", from_kgid_munged(&init_user_ns, vol->gid));\n\tif (vol->fmask == vol->dmask)\n\t\tseq_printf(sf, \",umask=0%o\", vol->fmask);\n\telse {\n\t\tseq_printf(sf, \",fmask=0%o\", vol->fmask);\n\t\tseq_printf(sf, \",dmask=0%o\", vol->dmask);\n\t}\n\tseq_printf(sf, \",nls=%s\", vol->nls_map->charset);\n\tif (NVolCaseSensitive(vol))\n\t\tseq_printf(sf, \",case_sensitive\");\n\tif (NVolShowSystemFiles(vol))\n\t\tseq_printf(sf, \",show_sys_files\");\n\tif (!NVolSparseEnabled(vol))\n\t\tseq_printf(sf, \",disable_sparse\");\n\tfor (i = 0; on_errors_arr[i].val; i++) {\n\t\tif (on_errors_arr[i].val & vol->on_errors)\n\t\t\tseq_printf(sf, \",errors=%s\", on_errors_arr[i].str);\n\t}\n\tseq_printf(sf, \",mft_zone_multiplier=%i\", vol->mft_zone_multiplier);\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\",mft_zone_multiplier=%i\"",
            "vol->mft_zone_multiplier"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolShowSystemFiles",
          "args": [
            "vol"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolCaseSensitive",
          "args": [
            "vol"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "vol->gid"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "vol->uid"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nint ntfs_show_options(struct seq_file *sf, struct dentry *root)\n{\n\tntfs_volume *vol = NTFS_SB(root->d_sb);\n\tint i;\n\n\tseq_printf(sf, \",uid=%i\", from_kuid_munged(&init_user_ns, vol->uid));\n\tseq_printf(sf, \",gid=%i\", from_kgid_munged(&init_user_ns, vol->gid));\n\tif (vol->fmask == vol->dmask)\n\t\tseq_printf(sf, \",umask=0%o\", vol->fmask);\n\telse {\n\t\tseq_printf(sf, \",fmask=0%o\", vol->fmask);\n\t\tseq_printf(sf, \",dmask=0%o\", vol->dmask);\n\t}\n\tseq_printf(sf, \",nls=%s\", vol->nls_map->charset);\n\tif (NVolCaseSensitive(vol))\n\t\tseq_printf(sf, \",case_sensitive\");\n\tif (NVolShowSystemFiles(vol))\n\t\tseq_printf(sf, \",show_sys_files\");\n\tif (!NVolSparseEnabled(vol))\n\t\tseq_printf(sf, \",disable_sparse\");\n\tfor (i = 0; on_errors_arr[i].val; i++) {\n\t\tif (on_errors_arr[i].val & vol->on_errors)\n\t\t\tseq_printf(sf, \",errors=%s\", on_errors_arr[i].str);\n\t}\n\tseq_printf(sf, \",mft_zone_multiplier=%i\", vol->mft_zone_multiplier);\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_evict_big_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2259-2301",
    "snippet": "void ntfs_evict_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\ttruncate_inode_pages_final(&vi->i_data);\n\tclear_inode(vi);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tbool was_bad = (is_bad_inode(vi));\n\n\t\t/* Committing the inode also commits all extent inodes. */\n\t\tntfs_commit_inode(vi);\n\n\t\tif (!was_bad && (is_bad_inode(vi) || NInoDirty(ni))) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to commit dirty inode \"\n\t\t\t\t\t\"0x%lx.  Losing data!\", vi->i_ino);\n\t\t\t// FIXME:  Do something!!!\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\t/* No need to lock at this stage as no one else has a reference. */\n\tif (ni->nr_extents > 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ni->nr_extents; i++)\n\t\t\tntfs_clear_extent_inode(ni->ext.extent_ntfs_inos[i]);\n\t\tkfree(ni->ext.extent_ntfs_inos);\n\t}\n\n\t__ntfs_clear_inode(ni);\n\n\tif (NInoAttr(ni)) {\n\t\t/* Release the base inode if we are holding it. */\n\t\tif (ni->nr_extents == -1) {\n\t\t\tiput(VFS_I(ni->ext.base_ntfs_ino));\n\t\t\tni->nr_extents = 0;\n\t\t\tni->ext.base_ntfs_ino = NULL;\n\t\t}\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "VFS_I(ni->ext.base_ntfs_ino)"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni->ext.base_ntfs_ino"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_clear_inode",
          "args": [
            "ni"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2198-2225",
          "snippet": "static void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ni->ext.extent_ntfs_inos"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_clear_extent_inode",
          "args": [
            "ni->ext.extent_ntfs_inos[i]"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_clear_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2227-2247",
          "snippet": "void ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to commit dirty inode \"\n\t\t\t\t\t\"0x%lx.  Losing data!\"",
            "vi->i_ino"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "ni"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "vi"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_commit_inode",
          "args": [
            "vi"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "312-317",
          "snippet": "static inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "ni"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&vi->i_data"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nvoid ntfs_evict_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\ttruncate_inode_pages_final(&vi->i_data);\n\tclear_inode(vi);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tbool was_bad = (is_bad_inode(vi));\n\n\t\t/* Committing the inode also commits all extent inodes. */\n\t\tntfs_commit_inode(vi);\n\n\t\tif (!was_bad && (is_bad_inode(vi) || NInoDirty(ni))) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to commit dirty inode \"\n\t\t\t\t\t\"0x%lx.  Losing data!\", vi->i_ino);\n\t\t\t// FIXME:  Do something!!!\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\t/* No need to lock at this stage as no one else has a reference. */\n\tif (ni->nr_extents > 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ni->nr_extents; i++)\n\t\t\tntfs_clear_extent_inode(ni->ext.extent_ntfs_inos[i]);\n\t\tkfree(ni->ext.extent_ntfs_inos);\n\t}\n\n\t__ntfs_clear_inode(ni);\n\n\tif (NInoAttr(ni)) {\n\t\t/* Release the base inode if we are holding it. */\n\t\tif (ni->nr_extents == -1) {\n\t\t\tiput(VFS_I(ni->ext.base_ntfs_ino));\n\t\t\tni->nr_extents = 0;\n\t\t\tni->ext.base_ntfs_ino = NULL;\n\t\t}\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "ntfs_clear_extent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2227-2247",
    "snippet": "void ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_destroy_extent_inode",
          "args": [
            "ni"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_destroy_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "367-374",
          "snippet": "static void ntfs_destroy_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tkmem_cache_free(ntfs_inode_cache, ni);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void ntfs_destroy_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tkmem_cache_free(ntfs_inode_cache, ni);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_clear_inode",
          "args": [
            "ni"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2198-2225",
          "snippet": "static void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ni->vol->sb",
            "\"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\""
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "VFS_I(ni->ext.base_ntfs_ino)"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni->ext.base_ntfs_ino"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "ni"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->nr_extents != -1"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(ni)"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "ni->mft_no"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}"
  },
  {
    "function_name": "__ntfs_clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "2198-2225",
    "snippet": "static void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ni->name"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni->name"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->attr_list_rl.lock"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "ni->attr_list_rl.rl"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->attr_list_rl.lock"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t/* Free all alocated memory. */\n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t/* Catch bugs... */\n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}"
  },
  {
    "function_name": "ntfs_read_inode_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "1776-2196",
    "snippet": "int ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() and sync_page() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);",
      "static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "m"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "vi"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed. Marking inode as bad.\""
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\""
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ni->mrec_lock",
            "&mft_ni_mrec_lock_key"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ni->runlist.lock",
            "&mft_ni_runlist_lock_key"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\"",
            "(unsigned long long)highest_vcn",
            "(unsigned long long)last_vcn - 1"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\""
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\""
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\""
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\""
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.lowest_vcn"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "vi"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_read_locked_inode",
          "args": [
            "vi"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT is too big! Aborting.\""
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\""
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\"",
            "PTR_ERR(nrl)"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nrl"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nrl"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_decompress",
          "args": [
            "vol",
            "a",
            "ni->runlist.rl"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "749-978",
          "snippet": "runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\""
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_DATA",
            "NULL",
            "0",
            "0",
            "next_vcn",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSEQNO_LE",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "AT_DATA"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "al_entry->length"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ni->attr_list",
            "(u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset)",
            "le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\""
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_attribute_list",
          "args": [
            "vol",
            "&ni->attr_list_rl",
            "ni->attr_list",
            "ni->attr_list_size",
            "sle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "load_attribute_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "710-805",
          "snippet": "int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ni->attr_list_rl.rl"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ni->attr_list_rl.rl"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetAttrListNonResident",
          "args": [
            "ni"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "ni->attr_list_size"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_size",
          "args": [
            "a"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.h",
          "lines": "81-86",
          "snippet": "static inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include \"endian.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include \"endian.h\"\n\nstatic inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\""
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetAttrList",
          "args": [
            "ni"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\""
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -ENOENT"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "m"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"MST fixup failed. $MFT is corrupt.\""
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "post_read_mst_fixup",
          "args": [
            "(NTFS_RECORD*)m",
            "vol->mft_record_size"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "post_read_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "42-100",
          "snippet": "int post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nint post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)m + (i << sb->s_blocksize_bits)",
            "bh->b_data",
            "sb->s_blocksize"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Device read failed.\""
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block++"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to allocate buffer for $MFT record 0.\""
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetSparseDisabled",
          "args": [
            "ni"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetMstProtected",
          "args": [
            "ni"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetNonResident",
          "args": [
            "ni"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_init_big_inode",
          "args": [
            "vi"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_big_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "286-293",
          "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() and sync_page() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}"
  },
  {
    "function_name": "ntfs_read_locked_index_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "1493-1739",
    "snippet": "static int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)\n{\n\tloff_t bvi_size;\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni, *bni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tINDEX_ROOT *ir;\n\tu8 *ir_end, *index_end;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\tntfs_init_big_inode(vi);\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\t/* Map the mft record for the base inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the index root attribute. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Set up the state. */\n\tif (unlikely(a->non_resident)) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/* Ensure the attribute name is placed before the value. */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Compressed/encrypted/sparse index root is not allowed, except for\n\t * directories of course but those are not dealt with here.\n\t */\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_ENCRYPTED |\n\t\t\tATTR_IS_SPARSE)) {\n\t\tntfs_error(vi->i_sb, \"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\tir = (INDEX_ROOT*)((u8*)a + le16_to_cpu(a->data.resident.value_offset));\n\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\tif (index_end > ir_end) {\n\t\tntfs_error(vi->i_sb, \"Index is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (ir->type) {\n\t\tntfs_error(vi->i_sb, \"Index type is not 0 (type is 0x%x).\",\n\t\t\t\tle32_to_cpu(ir->type));\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.collation_rule = ir->collation_rule;\n\tntfs_debug(\"Index collation rule is 0x%x.\",\n\t\t\tle32_to_cpu(ir->collation_rule));\n\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\tif (!is_power_of_2(ni->itype.index.block_size)) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a power of \"\n\t\t\t\t\"two.\", ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) > PAGE_CACHE_SIZE \"\n\t\t\t\t\"(%ld) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, PAGE_CACHE_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) < NTFS_BLOCK_SIZE \"\n\t\t\t\t\"(%i) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, NTFS_BLOCK_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.block_size_bits = ffs(ni->itype.index.block_size) - 1;\n\t/* Determine the size of a vcn in the index. */\n\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t} else {\n\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t}\n\t/* Check for presence of index allocation attribute. */\n\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t/* No index allocation. */\n\t\tvi->i_size = ni->initialized_size = ni->allocated_size = 0;\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto skip_large_index_stuff;\n\t} /* LARGE_INDEX:  Index allocation present.  Setup state. */\n\tNInoSetIndexAllocPresent(ni);\n\t/* Find index allocation attribute. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\");\n\t\telse\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\tif (!a->non_resident) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Ensure the attribute name is placed before the mapping pairs array.\n\t */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_SPARSE) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is sparse.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->data.non_resident.lowest_vcn) {\n\t\tntfs_error(vi->i_sb, \"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\");\n\t\tgoto unm_err_out;\n\t}\n\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\tni->initialized_size = sle64_to_cpu(\n\t\t\ta->data.non_resident.initialized_size);\n\tni->allocated_size = sle64_to_cpu(a->data.non_resident.allocated_size);\n\t/*\n\t * We are done with the mft record, so we release it.  Otherwise\n\t * we would deadlock in ntfs_attr_iget().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tctx = NULL;\n\t/* Get the index bitmap attribute inode. */\n\tbvi = ntfs_attr_iget(base_vi, AT_BITMAP, ni->name, ni->name_len);\n\tif (IS_ERR(bvi)) {\n\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bvi);\n\t\tgoto unm_err_out;\n\t}\n\tbni = NTFS_I(bvi);\n\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\tNInoSparse(bni)) {\n\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\");\n\t\tgoto iput_unm_err_out;\n\t}\n\t/* Consistency check bitmap size vs. index allocation size. */\n\tbvi_size = i_size_read(bvi);\n\tif ((bvi_size << 3) < (vi->i_size >> ni->itype.index.block_size_bits)) {\n\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) for \"\n\t\t\t\t\"index allocation (0x%llx).\", bvi_size << 3,\n\t\t\t\tvi->i_size);\n\t\tgoto iput_unm_err_out;\n\t}\n\tiput(bvi);\nskip_large_index_stuff:\n\t/* Setup the operations for this index inode. */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode doesn't go away and attach it to the\n\t * index inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vi->i_sb, \"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\", err, vi->i_ino,\n\t\t\tni->name_len);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "vi"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\"",
            "err",
            "vi->i_ino",
            "ni->name_len"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bvi"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "base_vi"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bvi"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\""
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "bni"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "bni"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "bni"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "bvi"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bvi"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to get bitmap attribute.\""
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bvi"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_iget",
          "args": [
            "base_vi",
            "AT_BITMAP",
            "ni->name",
            "ni->name_len"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "228-265",
          "snippet": "struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.allocated_size"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\""
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute is sparse.\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\""
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\""
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset))"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.mapping_pairs_offset"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\""
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\""
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_INDEX_ALLOCATION",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetIndexAllocPresent",
          "args": [
            "ni"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "ni->itype.index.block_size"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "ni->itype.index.block_size"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ir->index_block_size"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Index collation rule is 0x%x.\"",
            "le32_to_cpu(ir->collation_rule)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Index is corrupt.\""
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ROOT attribute is corrupt.\""
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\""
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset))"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ROOT attribute is not resident.\""
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->non_resident"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\""
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "vi",
            "base_vi->i_nlink"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_init_big_inode",
          "args": [
            "vi"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_big_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "286-293",
          "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "vi->i_sb"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)\n{\n\tloff_t bvi_size;\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni, *bni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tINDEX_ROOT *ir;\n\tu8 *ir_end, *index_end;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\tntfs_init_big_inode(vi);\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\t/* Map the mft record for the base inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the index root attribute. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Set up the state. */\n\tif (unlikely(a->non_resident)) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/* Ensure the attribute name is placed before the value. */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Compressed/encrypted/sparse index root is not allowed, except for\n\t * directories of course but those are not dealt with here.\n\t */\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_ENCRYPTED |\n\t\t\tATTR_IS_SPARSE)) {\n\t\tntfs_error(vi->i_sb, \"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\tir = (INDEX_ROOT*)((u8*)a + le16_to_cpu(a->data.resident.value_offset));\n\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\tif (index_end > ir_end) {\n\t\tntfs_error(vi->i_sb, \"Index is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (ir->type) {\n\t\tntfs_error(vi->i_sb, \"Index type is not 0 (type is 0x%x).\",\n\t\t\t\tle32_to_cpu(ir->type));\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.collation_rule = ir->collation_rule;\n\tntfs_debug(\"Index collation rule is 0x%x.\",\n\t\t\tle32_to_cpu(ir->collation_rule));\n\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\tif (!is_power_of_2(ni->itype.index.block_size)) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a power of \"\n\t\t\t\t\"two.\", ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) > PAGE_CACHE_SIZE \"\n\t\t\t\t\"(%ld) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, PAGE_CACHE_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) < NTFS_BLOCK_SIZE \"\n\t\t\t\t\"(%i) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, NTFS_BLOCK_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.block_size_bits = ffs(ni->itype.index.block_size) - 1;\n\t/* Determine the size of a vcn in the index. */\n\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t} else {\n\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t}\n\t/* Check for presence of index allocation attribute. */\n\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t/* No index allocation. */\n\t\tvi->i_size = ni->initialized_size = ni->allocated_size = 0;\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto skip_large_index_stuff;\n\t} /* LARGE_INDEX:  Index allocation present.  Setup state. */\n\tNInoSetIndexAllocPresent(ni);\n\t/* Find index allocation attribute. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\");\n\t\telse\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\tif (!a->non_resident) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Ensure the attribute name is placed before the mapping pairs array.\n\t */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_SPARSE) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is sparse.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->data.non_resident.lowest_vcn) {\n\t\tntfs_error(vi->i_sb, \"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\");\n\t\tgoto unm_err_out;\n\t}\n\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\tni->initialized_size = sle64_to_cpu(\n\t\t\ta->data.non_resident.initialized_size);\n\tni->allocated_size = sle64_to_cpu(a->data.non_resident.allocated_size);\n\t/*\n\t * We are done with the mft record, so we release it.  Otherwise\n\t * we would deadlock in ntfs_attr_iget().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tctx = NULL;\n\t/* Get the index bitmap attribute inode. */\n\tbvi = ntfs_attr_iget(base_vi, AT_BITMAP, ni->name, ni->name_len);\n\tif (IS_ERR(bvi)) {\n\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bvi);\n\t\tgoto unm_err_out;\n\t}\n\tbni = NTFS_I(bvi);\n\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\tNInoSparse(bni)) {\n\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\");\n\t\tgoto iput_unm_err_out;\n\t}\n\t/* Consistency check bitmap size vs. index allocation size. */\n\tbvi_size = i_size_read(bvi);\n\tif ((bvi_size << 3) < (vi->i_size >> ni->itype.index.block_size_bits)) {\n\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) for \"\n\t\t\t\t\"index allocation (0x%llx).\", bvi_size << 3,\n\t\t\t\tvi->i_size);\n\t\tgoto iput_unm_err_out;\n\t}\n\tiput(bvi);\nskip_large_index_stuff:\n\t/* Setup the operations for this index inode. */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode doesn't go away and attach it to the\n\t * index inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vi->i_sb, \"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\", err, vi->i_ino,\n\t\t\tni->name_len);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_read_locked_attr_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "1227-1458",
    "snippet": "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\tntfs_init_big_inode(vi);\n\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the attribute. */\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto unm_err_out;\n\ta = ctx->attr;\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tNInoSetCompressed(ni);\n\t\t\tif ((ni->type != AT_DATA) || (ni->type == AT_DATA &&\n\t\t\t\t\tni->name_len)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"attribute but compression is \"\n\t\t\t\t\t\t\"disabled due to cluster size \"\n\t\t\t\t\t\t\"(%i) > 4kiB.\",\n\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK) !=\n\t\t\t\t\tATTR_IS_COMPRESSED) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\"compression method.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * The compressed/sparse flag set in an index root just means\n\t\t * to compress all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is %s.  Please \"\n\t\t\t\t\t\"report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\",\n\t\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\t\"sparse\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tif (NInoCompressed(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The encryption flag set in an index root just means to\n\t\t * encrypt all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->type != AT_DATA) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tNInoSetEncrypted(ni);\n\t}\n\tif (!a->non_resident) {\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoMstProtected(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\ta->data.resident.value_length);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\tntfs_error(vi->i_sb, \"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else {\n\t\tNInoSetNonResident(ni);\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found non-standard \"\n\t\t\t\t\t\t\"compression unit (%u instead \"\n\t\t\t\t\t\t\"of 4).  Cannot handle this.\",\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit);\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\tffs(ni->itype.compressed.\n\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit;\n\t\t\t} else {\n\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t\t}\n\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.compressed_size);\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t}\n\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\tif (NInoMstProtected(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\telse if (NInoCompressed(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\tif ((NInoCompressed(ni) || NInoSparse(ni)) && ni->type != AT_INDEX_ROOT)\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode does not go away and attach it to the\n\t * attribute inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\", err, vi->i_ino, ni->type, ni->name_len,\n\t\t\tbase_vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "vi"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\"",
            "err",
            "vi->i_ino",
            "ni->type",
            "ni->name_len",
            "base_vi->i_ino"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "base_vi"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.allocated_size"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\""
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "ni->itype.compressed.\n\t\t\t\t\t\tblock_size"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\""
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset))"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.mapping_pairs_offset"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetNonResident",
          "args": [
            "ni"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\""
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\""
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\""
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset))"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetEncrypted",
          "args": [
            "ni"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\""
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\""
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetSparse",
          "args": [
            "ni"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found unknown \"\n\t\t\t\t\t\t\"compression method.\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetCompressed",
          "args": [
            "ni"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "vi",
            "base_vi->i_nlink"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "base_vi"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_init_big_inode",
          "args": [
            "vi"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_big_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "286-293",
          "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "vi->i_sb"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\tntfs_init_big_inode(vi);\n\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the attribute. */\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto unm_err_out;\n\ta = ctx->attr;\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tNInoSetCompressed(ni);\n\t\t\tif ((ni->type != AT_DATA) || (ni->type == AT_DATA &&\n\t\t\t\t\tni->name_len)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"attribute but compression is \"\n\t\t\t\t\t\t\"disabled due to cluster size \"\n\t\t\t\t\t\t\"(%i) > 4kiB.\",\n\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK) !=\n\t\t\t\t\tATTR_IS_COMPRESSED) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\"compression method.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * The compressed/sparse flag set in an index root just means\n\t\t * to compress all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is %s.  Please \"\n\t\t\t\t\t\"report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\",\n\t\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\t\"sparse\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tif (NInoCompressed(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The encryption flag set in an index root just means to\n\t\t * encrypt all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->type != AT_DATA) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tNInoSetEncrypted(ni);\n\t}\n\tif (!a->non_resident) {\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoMstProtected(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\ta->data.resident.value_length);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\tntfs_error(vi->i_sb, \"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else {\n\t\tNInoSetNonResident(ni);\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found non-standard \"\n\t\t\t\t\t\t\"compression unit (%u instead \"\n\t\t\t\t\t\t\"of 4).  Cannot handle this.\",\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit);\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\tffs(ni->itype.compressed.\n\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit;\n\t\t\t} else {\n\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t\t}\n\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.compressed_size);\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t}\n\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\tif (NInoMstProtected(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\telse if (NInoCompressed(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\tif ((NInoCompressed(ni) || NInoSparse(ni)) && ni->type != AT_INDEX_ROOT)\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode does not go away and attach it to the\n\t * attribute inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\", err, vi->i_ino, ni->type, ni->name_len,\n\t\t\tbase_vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_read_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "550-1203",
    "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "vi"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\"",
            "err",
            "vi->i_ino"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bvi"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "vi->i_mode"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.resident.value_offset"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.allocated_size"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetNonResident",
          "args": [
            "ni"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetEncrypted",
          "args": [
            "ni"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetSparse",
          "args": [
            "ni"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\""
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetCompressed",
          "args": [
            "ni"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$DATA attribute is missing.\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_extended_system_file",
          "args": [
            "ctx"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_is_extended_system_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "458-522",
          "snippet": "static int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)\n{\n\tint nr_links, err;\n\n\t/* Restart search. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Get number of hard links. */\n\tnr_links = le16_to_cpu(ctx->mrec->link_count);\n\n\t/* Loop through all hard links. */\n\twhile (!(err = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx))) {\n\t\tFILE_NAME_ATTR *file_name_attr;\n\t\tATTR_RECORD *attr = ctx->attr;\n\t\tu8 *p, *p2;\n\n\t\tnr_links--;\n\t\t/*\n\t\t * Maximum sanity checking as we are called on an inode that\n\t\t * we suspect might be corrupt.\n\t\t */\n\t\tp = (u8*)attr + le32_to_cpu(attr->length);\n\t\tif (p < (u8*)ctx->mrec || (u8*)p > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_in_use)) {\nerr_corrupt_attr:\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->non_resident) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->flags) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!(attr->data.resident.flags & RESIDENT_ATTR_IS_INDEXED)) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfile_name_attr = (FILE_NAME_ATTR*)((u8*)attr +\n\t\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\t\tp2 = (u8*)attr + le32_to_cpu(attr->data.resident.value_length);\n\t\tif (p2 < (u8*)attr || p2 > p)\n\t\t\tgoto err_corrupt_attr;\n\t\t/* This attribute is ok, but is it in the $Extend directory? */\n\t\tif (MREF_LE(file_name_attr->parent_directory) == FILE_Extend)\n\t\t\treturn 1;\t/* YES, it's an extended system file. */\n\t}\n\tif (unlikely(err != -ENOENT))\n\t\treturn err;\n\tif (unlikely(nr_links)) {\n\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\t/* NO, it is not an extended system file. */\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)\n{\n\tint nr_links, err;\n\n\t/* Restart search. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Get number of hard links. */\n\tnr_links = le16_to_cpu(ctx->mrec->link_count);\n\n\t/* Loop through all hard links. */\n\twhile (!(err = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx))) {\n\t\tFILE_NAME_ATTR *file_name_attr;\n\t\tATTR_RECORD *attr = ctx->attr;\n\t\tu8 *p, *p2;\n\n\t\tnr_links--;\n\t\t/*\n\t\t * Maximum sanity checking as we are called on an inode that\n\t\t * we suspect might be corrupt.\n\t\t */\n\t\tp = (u8*)attr + le32_to_cpu(attr->length);\n\t\tif (p < (u8*)ctx->mrec || (u8*)p > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_in_use)) {\nerr_corrupt_attr:\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->non_resident) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->flags) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!(attr->data.resident.flags & RESIDENT_ATTR_IS_INDEXED)) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfile_name_attr = (FILE_NAME_ATTR*)((u8*)attr +\n\t\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\t\tp2 = (u8*)attr + le32_to_cpu(attr->data.resident.value_length);\n\t\tif (p2 < (u8*)attr || p2 > p)\n\t\t\tgoto err_corrupt_attr;\n\t\t/* This attribute is ok, but is it in the $Extend directory? */\n\t\tif (MREF_LE(file_name_attr->parent_directory) == FILE_Extend)\n\t\t\treturn 1;\t/* YES, it's an extended system file. */\n\t}\n\tif (unlikely(err != -ENOENT))\n\t\treturn err;\n\tif (unlikely(nr_links)) {\n\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\t/* NO, it is not an extended system file. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_DATA",
            "NULL",
            "0",
            "0",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bvi"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "bni"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "bni"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "bni"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "bvi"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bvi"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to get bitmap attribute.\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bvi"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_iget",
          "args": [
            "vi",
            "AT_BITMAP",
            "I30",
            "4"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "228-265",
          "snippet": "struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset))"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetIndexAllocPresent",
          "args": [
            "ni"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetMstProtected",
          "args": [
            "ni"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Directory index is corrupt.\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetSparse",
          "args": [
            "ni"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetEncrypted",
          "args": [
            "ni"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetCompressed",
          "args": [
            "ni"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset))"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a->non_resident"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vi->i_mode"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ni->attr_list",
            "(u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset)",
            "le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_attribute_list",
          "args": [
            "vol",
            "&ni->attr_list_rl",
            "ni->attr_list",
            "ni->attr_list_size",
            "sle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "load_attribute_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "710-805",
          "snippet": "int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ni->attr_list_rl.rl"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ni->attr_list_rl.rl"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_decompress",
          "args": [
            "vol",
            "a",
            "NULL"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "749-978",
          "snippet": "runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\""
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetAttrListNonResident",
          "args": [
            "ni"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "ni->attr_list_size"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_size",
          "args": [
            "a"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.h",
          "lines": "81-86",
          "snippet": "static inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include \"endian.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include \"endian.h\"\n\nstatic inline s64 ntfs_attr_size(const ATTR_RECORD *a)\n{\n\tif (!a->non_resident)\n\t\treturn (s64)le32_to_cpu(a->data.resident.value_length);\n\treturn sle64_to_cpu(a->data.non_resident.data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\"",
            "vi->i_ino"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetAttrList",
          "args": [
            "ni"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Attribute list found in inode 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -ENOENT"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs2utc",
          "args": [
            "si->last_access_time"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs2utc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/time.h",
          "lines": "85-98",
          "snippet": "static inline struct timespec ntfs2utc(const sle64 time)\n{\n\tstruct timespec ts;\n\n\t/* Subtract the NTFS time offset. */\n\tu64 t = (u64)(sle64_to_cpu(time) - NTFS_TIME_OFFSET);\n\t/*\n\t * Convert the time to 1-second intervals and the remainder to\n\t * 1-nano-second intervals.\n\t */\n\tts.tv_nsec = do_div(t, 10000000) * 100;\n\tts.tv_sec = t;\n\treturn ts;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include <asm/div64.h>\t\t/* For do_div(). */",
            "#include <linux/time.h>\t\t/* For current_kernel_time(). */"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include <asm/div64.h>\t\t/* For do_div(). */\n#include <linux/time.h>\t\t/* For current_kernel_time(). */\n\n#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)\n\nstatic inline struct timespec ntfs2utc(const sle64 time)\n{\n\tstruct timespec ts;\n\n\t/* Subtract the NTFS time offset. */\n\tu64 t = (u64)(sle64_to_cpu(time) - NTFS_TIME_OFFSET);\n\t/*\n\t * Convert the time to 1-second intervals and the remainder to\n\t * 1-nano-second intervals.\n\t */\n\tts.tv_nsec = do_div(t, 10000000) * 100;\n\tts.tv_sec = t;\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "vi",
            "1"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "vi"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Inode is an extent inode!\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Inode is not in use!\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "m"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_init_big_inode",
          "args": [
            "vi"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_big_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "286-293",
          "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "vi->i_sb"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_is_extended_system_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "458-522",
    "snippet": "static int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)\n{\n\tint nr_links, err;\n\n\t/* Restart search. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Get number of hard links. */\n\tnr_links = le16_to_cpu(ctx->mrec->link_count);\n\n\t/* Loop through all hard links. */\n\twhile (!(err = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx))) {\n\t\tFILE_NAME_ATTR *file_name_attr;\n\t\tATTR_RECORD *attr = ctx->attr;\n\t\tu8 *p, *p2;\n\n\t\tnr_links--;\n\t\t/*\n\t\t * Maximum sanity checking as we are called on an inode that\n\t\t * we suspect might be corrupt.\n\t\t */\n\t\tp = (u8*)attr + le32_to_cpu(attr->length);\n\t\tif (p < (u8*)ctx->mrec || (u8*)p > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_in_use)) {\nerr_corrupt_attr:\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->non_resident) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->flags) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!(attr->data.resident.flags & RESIDENT_ATTR_IS_INDEXED)) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfile_name_attr = (FILE_NAME_ATTR*)((u8*)attr +\n\t\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\t\tp2 = (u8*)attr + le32_to_cpu(attr->data.resident.value_length);\n\t\tif (p2 < (u8*)attr || p2 > p)\n\t\t\tgoto err_corrupt_attr;\n\t\t/* This attribute is ok, but is it in the $Extend directory? */\n\t\tif (MREF_LE(file_name_attr->parent_directory) == FILE_Extend)\n\t\t\treturn 1;\t/* YES, it's an extended system file. */\n\t}\n\tif (unlikely(err != -ENOENT))\n\t\treturn err;\n\tif (unlikely(nr_links)) {\n\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\t/* NO, it is not an extended system file. */\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ctx->ntfs_ino->vol->sb",
            "\"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_links"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -ENOENT"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "file_name_attr->parent_directory"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "attr->data.resident.value_length"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "attr->data.resident.value_offset"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ctx->ntfs_ino->vol->sb",
            "\"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ctx->ntfs_ino->vol->sb",
            "\"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ctx->ntfs_ino->vol->sb",
            "\"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ctx->ntfs_ino->vol->sb",
            "\"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_FILE_NAME",
            "NULL",
            "0",
            "0",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)\n{\n\tint nr_links, err;\n\n\t/* Restart search. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Get number of hard links. */\n\tnr_links = le16_to_cpu(ctx->mrec->link_count);\n\n\t/* Loop through all hard links. */\n\twhile (!(err = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx))) {\n\t\tFILE_NAME_ATTR *file_name_attr;\n\t\tATTR_RECORD *attr = ctx->attr;\n\t\tu8 *p, *p2;\n\n\t\tnr_links--;\n\t\t/*\n\t\t * Maximum sanity checking as we are called on an inode that\n\t\t * we suspect might be corrupt.\n\t\t */\n\t\tp = (u8*)attr + le32_to_cpu(attr->length);\n\t\tif (p < (u8*)ctx->mrec || (u8*)p > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_in_use)) {\nerr_corrupt_attr:\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->non_resident) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->flags) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!(attr->data.resident.flags & RESIDENT_ATTR_IS_INDEXED)) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfile_name_attr = (FILE_NAME_ATTR*)((u8*)attr +\n\t\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\t\tp2 = (u8*)attr + le32_to_cpu(attr->data.resident.value_length);\n\t\tif (p2 < (u8*)attr || p2 > p)\n\t\t\tgoto err_corrupt_attr;\n\t\t/* This attribute is ok, but is it in the $Extend directory? */\n\t\tif (MREF_LE(file_name_attr->parent_directory) == FILE_Extend)\n\t\t\treturn 1;\t/* YES, it's an extended system file. */\n\t}\n\tif (unlikely(err != -ENOENT))\n\t\treturn err;\n\tif (unlikely(nr_links)) {\n\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\t/* NO, it is not an extended system file. */\n}"
  },
  {
    "function_name": "ntfs_new_extent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "428-443",
    "snippet": "inline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,\n\t\tunsigned long mft_no)\n{\n\tntfs_inode *ni = ntfs_alloc_extent_inode();\n\n\tntfs_debug(\"Entering.\");\n\tif (likely(ni != NULL)) {\n\t\t__ntfs_init_inode(sb, ni);\n\t\tlockdep_set_class(&ni->mrec_lock, &extent_inode_mrec_lock_key);\n\t\tni->mft_no = mft_no;\n\t\tni->type = AT_UNUSED;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\t}\n\treturn ni;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_class_key extent_inode_mrec_lock_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ni->mrec_lock",
            "&extent_inode_mrec_lock_key"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_init_inode",
          "args": [
            "sb",
            "ni"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "394-419",
          "snippet": "void __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key attr_list_rl_lock_class;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic struct lock_class_key attr_list_rl_lock_class;\n\nvoid __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ni != NULL"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_alloc_extent_inode",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_alloc_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "353-365",
          "snippet": "static inline ntfs_inode *ntfs_alloc_extent_inode(void)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn ni;\n\t}\n\tntfs_error(NULL, \"Allocation of NTFS inode structure failed.\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline ntfs_inode *ntfs_alloc_extent_inode(void)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn ni;\n\t}\n\tntfs_error(NULL, \"Allocation of NTFS inode structure failed.\");\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic struct lock_class_key extent_inode_mrec_lock_key;\n\ninline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,\n\t\tunsigned long mft_no)\n{\n\tntfs_inode *ni = ntfs_alloc_extent_inode();\n\n\tntfs_debug(\"Entering.\");\n\tif (likely(ni != NULL)) {\n\t\t__ntfs_init_inode(sb, ni);\n\t\tlockdep_set_class(&ni->mrec_lock, &extent_inode_mrec_lock_key);\n\t\tni->mft_no = mft_no;\n\t\tni->type = AT_UNUSED;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\t}\n\treturn ni;\n}"
  },
  {
    "function_name": "__ntfs_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "394-419",
    "snippet": "void __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_class_key attr_list_rl_lock_class;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ni->attr_list_rl.lock",
            "&attr_list_rl_lock_class"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_init_runlist",
          "args": [
            "&ni->attr_list_rl"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.h",
          "lines": "59-63",
          "snippet": "static inline void ntfs_init_runlist(runlist *rl)\n{\n\trl->rl = NULL;\n\tinit_rwsem(&rl->lock);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"layout.h\"\n#include \"types.h\"\n\nstatic inline void ntfs_init_runlist(runlist *rl)\n{\n\trl->rl = NULL;\n\tinit_rwsem(&rl->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ni->count",
            "1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&ni->size_lock"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic struct lock_class_key attr_list_rl_lock_class;\n\nvoid __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}"
  },
  {
    "function_name": "ntfs_destroy_extent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "367-374",
    "snippet": "static void ntfs_destroy_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tkmem_cache_free(ntfs_inode_cache, ni);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_inode_cache",
            "ni"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ni->count"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->page"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void ntfs_destroy_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tkmem_cache_free(ntfs_inode_cache, ni);\n}"
  },
  {
    "function_name": "ntfs_alloc_extent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "353-365",
    "snippet": "static inline ntfs_inode *ntfs_alloc_extent_inode(void)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn ni;\n\t}\n\tntfs_error(NULL, \"Allocation of NTFS inode structure failed.\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "NULL",
            "\"Allocation of NTFS inode structure failed.\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ni != NULL"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ntfs_inode_cache",
            "GFP_NOFS"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline ntfs_inode *ntfs_alloc_extent_inode(void)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn ni;\n\t}\n\tntfs_error(NULL, \"Allocation of NTFS inode structure failed.\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "ntfs_destroy_big_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "342-351",
    "snippet": "void ntfs_destroy_big_inode(struct inode *inode)\n{\n\tntfs_inode *ni = NTFS_I(inode);\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tcall_rcu(&inode->i_rcu, ntfs_i_callback);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ntfs_i_callback"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ni->count"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->page"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "inode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_destroy_big_inode(struct inode *inode)\n{\n\tntfs_inode *ni = NTFS_I(inode);\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tcall_rcu(&inode->i_rcu, ntfs_i_callback);\n}"
  },
  {
    "function_name": "ntfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "336-340",
    "snippet": "static void ntfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ntfs_big_inode_cache, NTFS_I(inode));\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_big_inode_cache",
            "NTFS_I(inode)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "inode"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic void ntfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ntfs_big_inode_cache, NTFS_I(inode));\n}"
  },
  {
    "function_name": "ntfs_alloc_big_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "322-334",
    "snippet": "struct inode *ntfs_alloc_big_inode(struct super_block *sb)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_big_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn VFS_I(ni);\n\t}\n\tntfs_error(sb, \"Allocation of NTFS big inode structure failed.\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Allocation of NTFS big inode structure failed.\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ni != NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ntfs_big_inode_cache",
            "GFP_NOFS"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstruct inode *ntfs_alloc_big_inode(struct super_block *sb)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_big_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn VFS_I(ni);\n\t}\n\tntfs_error(sb, \"Allocation of NTFS big inode structure failed.\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "ntfs_index_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "286-320",
    "snippet": "struct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,\n\t\tu32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad index inodes around.  This also\n\t * simplifies things in that we never need to check for bad index\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vi"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "vi"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_read_locked_index_inode",
          "args": [
            "base_vi",
            "vi"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_index_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "1493-1739",
          "snippet": "static int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)\n{\n\tloff_t bvi_size;\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni, *bni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tINDEX_ROOT *ir;\n\tu8 *ir_end, *index_end;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\tntfs_init_big_inode(vi);\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\t/* Map the mft record for the base inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the index root attribute. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Set up the state. */\n\tif (unlikely(a->non_resident)) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/* Ensure the attribute name is placed before the value. */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Compressed/encrypted/sparse index root is not allowed, except for\n\t * directories of course but those are not dealt with here.\n\t */\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_ENCRYPTED |\n\t\t\tATTR_IS_SPARSE)) {\n\t\tntfs_error(vi->i_sb, \"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\tir = (INDEX_ROOT*)((u8*)a + le16_to_cpu(a->data.resident.value_offset));\n\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\tif (index_end > ir_end) {\n\t\tntfs_error(vi->i_sb, \"Index is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (ir->type) {\n\t\tntfs_error(vi->i_sb, \"Index type is not 0 (type is 0x%x).\",\n\t\t\t\tle32_to_cpu(ir->type));\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.collation_rule = ir->collation_rule;\n\tntfs_debug(\"Index collation rule is 0x%x.\",\n\t\t\tle32_to_cpu(ir->collation_rule));\n\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\tif (!is_power_of_2(ni->itype.index.block_size)) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a power of \"\n\t\t\t\t\"two.\", ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) > PAGE_CACHE_SIZE \"\n\t\t\t\t\"(%ld) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, PAGE_CACHE_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) < NTFS_BLOCK_SIZE \"\n\t\t\t\t\"(%i) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, NTFS_BLOCK_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.block_size_bits = ffs(ni->itype.index.block_size) - 1;\n\t/* Determine the size of a vcn in the index. */\n\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t} else {\n\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t}\n\t/* Check for presence of index allocation attribute. */\n\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t/* No index allocation. */\n\t\tvi->i_size = ni->initialized_size = ni->allocated_size = 0;\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto skip_large_index_stuff;\n\t} /* LARGE_INDEX:  Index allocation present.  Setup state. */\n\tNInoSetIndexAllocPresent(ni);\n\t/* Find index allocation attribute. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\");\n\t\telse\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\tif (!a->non_resident) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Ensure the attribute name is placed before the mapping pairs array.\n\t */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_SPARSE) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is sparse.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->data.non_resident.lowest_vcn) {\n\t\tntfs_error(vi->i_sb, \"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\");\n\t\tgoto unm_err_out;\n\t}\n\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\tni->initialized_size = sle64_to_cpu(\n\t\t\ta->data.non_resident.initialized_size);\n\tni->allocated_size = sle64_to_cpu(a->data.non_resident.allocated_size);\n\t/*\n\t * We are done with the mft record, so we release it.  Otherwise\n\t * we would deadlock in ntfs_attr_iget().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tctx = NULL;\n\t/* Get the index bitmap attribute inode. */\n\tbvi = ntfs_attr_iget(base_vi, AT_BITMAP, ni->name, ni->name_len);\n\tif (IS_ERR(bvi)) {\n\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bvi);\n\t\tgoto unm_err_out;\n\t}\n\tbni = NTFS_I(bvi);\n\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\tNInoSparse(bni)) {\n\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\");\n\t\tgoto iput_unm_err_out;\n\t}\n\t/* Consistency check bitmap size vs. index allocation size. */\n\tbvi_size = i_size_read(bvi);\n\tif ((bvi_size << 3) < (vi->i_size >> ni->itype.index.block_size_bits)) {\n\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) for \"\n\t\t\t\t\"index allocation (0x%llx).\", bvi_size << 3,\n\t\t\t\tvi->i_size);\n\t\tgoto iput_unm_err_out;\n\t}\n\tiput(bvi);\nskip_large_index_stuff:\n\t/* Setup the operations for this index inode. */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode doesn't go away and attach it to the\n\t * index inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vi->i_sb, \"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\", err, vi->i_ino,\n\t\t\tni->name_len);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)\n{\n\tloff_t bvi_size;\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni, *bni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tINDEX_ROOT *ir;\n\tu8 *ir_end, *index_end;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\tntfs_init_big_inode(vi);\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\t/* Map the mft record for the base inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the index root attribute. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Set up the state. */\n\tif (unlikely(a->non_resident)) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/* Ensure the attribute name is placed before the value. */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Compressed/encrypted/sparse index root is not allowed, except for\n\t * directories of course but those are not dealt with here.\n\t */\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_ENCRYPTED |\n\t\t\tATTR_IS_SPARSE)) {\n\t\tntfs_error(vi->i_sb, \"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\tir = (INDEX_ROOT*)((u8*)a + le16_to_cpu(a->data.resident.value_offset));\n\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\tif (index_end > ir_end) {\n\t\tntfs_error(vi->i_sb, \"Index is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (ir->type) {\n\t\tntfs_error(vi->i_sb, \"Index type is not 0 (type is 0x%x).\",\n\t\t\t\tle32_to_cpu(ir->type));\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.collation_rule = ir->collation_rule;\n\tntfs_debug(\"Index collation rule is 0x%x.\",\n\t\t\tle32_to_cpu(ir->collation_rule));\n\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\tif (!is_power_of_2(ni->itype.index.block_size)) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a power of \"\n\t\t\t\t\"two.\", ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) > PAGE_CACHE_SIZE \"\n\t\t\t\t\"(%ld) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, PAGE_CACHE_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) < NTFS_BLOCK_SIZE \"\n\t\t\t\t\"(%i) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, NTFS_BLOCK_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.block_size_bits = ffs(ni->itype.index.block_size) - 1;\n\t/* Determine the size of a vcn in the index. */\n\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t} else {\n\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t}\n\t/* Check for presence of index allocation attribute. */\n\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t/* No index allocation. */\n\t\tvi->i_size = ni->initialized_size = ni->allocated_size = 0;\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto skip_large_index_stuff;\n\t} /* LARGE_INDEX:  Index allocation present.  Setup state. */\n\tNInoSetIndexAllocPresent(ni);\n\t/* Find index allocation attribute. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\");\n\t\telse\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\tif (!a->non_resident) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * Ensure the attribute name is placed before the mapping pairs array.\n\t */\n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_SPARSE) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is sparse.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->data.non_resident.lowest_vcn) {\n\t\tntfs_error(vi->i_sb, \"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\");\n\t\tgoto unm_err_out;\n\t}\n\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\tni->initialized_size = sle64_to_cpu(\n\t\t\ta->data.non_resident.initialized_size);\n\tni->allocated_size = sle64_to_cpu(a->data.non_resident.allocated_size);\n\t/*\n\t * We are done with the mft record, so we release it.  Otherwise\n\t * we would deadlock in ntfs_attr_iget().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tctx = NULL;\n\t/* Get the index bitmap attribute inode. */\n\tbvi = ntfs_attr_iget(base_vi, AT_BITMAP, ni->name, ni->name_len);\n\tif (IS_ERR(bvi)) {\n\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bvi);\n\t\tgoto unm_err_out;\n\t}\n\tbni = NTFS_I(bvi);\n\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\tNInoSparse(bni)) {\n\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\");\n\t\tgoto iput_unm_err_out;\n\t}\n\t/* Consistency check bitmap size vs. index allocation size. */\n\tbvi_size = i_size_read(bvi);\n\tif ((bvi_size << 3) < (vi->i_size >> ni->itype.index.block_size_bits)) {\n\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) for \"\n\t\t\t\t\"index allocation (0x%llx).\", bvi_size << 3,\n\t\t\t\tvi->i_size);\n\t\tgoto iput_unm_err_out;\n\t}\n\tiput(bvi);\nskip_large_index_stuff:\n\t/* Setup the operations for this index inode. */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode doesn't go away and attach it to the\n\t * index inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vi->i_sb, \"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\", err, vi->i_ino,\n\t\t\tni->name_len);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vi"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "base_vi->i_sb",
            "na.mft_no",
            "(test_t)ntfs_test_inode",
            "(set_t)ntfs_init_locked_inode",
            "&na"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,\n\t\tu32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad index inodes around.  This also\n\t * simplifies things in that we never need to check for bad index\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
  },
  {
    "function_name": "ntfs_attr_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "228-265",
    "snippet": "struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vi"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "vi"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_read_locked_attr_inode",
          "args": [
            "base_vi",
            "vi"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_attr_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "1227-1458",
          "snippet": "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\tntfs_init_big_inode(vi);\n\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the attribute. */\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto unm_err_out;\n\ta = ctx->attr;\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tNInoSetCompressed(ni);\n\t\t\tif ((ni->type != AT_DATA) || (ni->type == AT_DATA &&\n\t\t\t\t\tni->name_len)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"attribute but compression is \"\n\t\t\t\t\t\t\"disabled due to cluster size \"\n\t\t\t\t\t\t\"(%i) > 4kiB.\",\n\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK) !=\n\t\t\t\t\tATTR_IS_COMPRESSED) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\"compression method.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * The compressed/sparse flag set in an index root just means\n\t\t * to compress all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is %s.  Please \"\n\t\t\t\t\t\"report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\",\n\t\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\t\"sparse\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tif (NInoCompressed(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The encryption flag set in an index root just means to\n\t\t * encrypt all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->type != AT_DATA) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tNInoSetEncrypted(ni);\n\t}\n\tif (!a->non_resident) {\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoMstProtected(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\ta->data.resident.value_length);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\tntfs_error(vi->i_sb, \"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else {\n\t\tNInoSetNonResident(ni);\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found non-standard \"\n\t\t\t\t\t\t\"compression unit (%u instead \"\n\t\t\t\t\t\t\"of 4).  Cannot handle this.\",\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit);\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\tffs(ni->itype.compressed.\n\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit;\n\t\t\t} else {\n\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t\t}\n\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.compressed_size);\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t}\n\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\tif (NInoMstProtected(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\telse if (NInoCompressed(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\tif ((NInoCompressed(ni) || NInoSparse(ni)) && ni->type != AT_INDEX_ROOT)\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode does not go away and attach it to the\n\t * attribute inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\", err, vi->i_ino, ni->type, ni->name_len,\n\t\t\tbase_vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\tntfs_init_big_inode(vi);\n\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\n\t/* Just mirror the values from the base inode. */\n\tvi->i_version\t= base_vi->i_version;\n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tvi->i_ctime\t= base_vi->i_ctime;\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\n\t/* Set inode type to zero but preserve permissions. */\n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t/* Find the attribute. */\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto unm_err_out;\n\ta = ctx->attr;\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tNInoSetCompressed(ni);\n\t\t\tif ((ni->type != AT_DATA) || (ni->type == AT_DATA &&\n\t\t\t\t\tni->name_len)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"attribute but compression is \"\n\t\t\t\t\t\t\"disabled due to cluster size \"\n\t\t\t\t\t\t\"(%i) > 4kiB.\",\n\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK) !=\n\t\t\t\t\tATTR_IS_COMPRESSED) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\"compression method.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * The compressed/sparse flag set in an index root just means\n\t\t * to compress all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is %s.  Please \"\n\t\t\t\t\t\"report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\",\n\t\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\t\"sparse\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tif (NInoCompressed(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The encryption flag set in an index root just means to\n\t\t * encrypt all files.\n\t\t */\n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->type != AT_DATA) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tNInoSetEncrypted(ni);\n\t}\n\tif (!a->non_resident) {\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoMstProtected(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\ta->data.resident.value_length);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\tntfs_error(vi->i_sb, \"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else {\n\t\tNInoSetNonResident(ni);\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found non-standard \"\n\t\t\t\t\t\t\"compression unit (%u instead \"\n\t\t\t\t\t\t\"of 4).  Cannot handle this.\",\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit);\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\tffs(ni->itype.compressed.\n\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit;\n\t\t\t} else {\n\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t\t}\n\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.compressed_size);\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t}\n\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\tif (NInoMstProtected(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\telse if (NInoCompressed(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\tif ((NInoCompressed(ni) || NInoSparse(ni)) && ni->type != AT_INDEX_ROOT)\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\t/*\n\t * Make sure the base inode does not go away and attach it to the\n\t * attribute inode.\n\t */\n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\", err, vi->i_ino, ni->type, ni->name_len,\n\t\t\tbase_vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vi"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "base_vi->i_sb",
            "na.mft_no",
            "(test_t)ntfs_test_inode",
            "(set_t)ntfs_init_locked_inode",
            "&na"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type == AT_INDEX_ALLOCATION"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
  },
  {
    "function_name": "ntfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "171-203",
    "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vi"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err == -ENOMEM"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "vi"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_read_locked_inode",
          "args": [
            "vi"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vi"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "mft_no",
            "(test_t)ntfs_test_inode",
            "(set_t)ntfs_init_locked_inode",
            "&na"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
  },
  {
    "function_name": "ntfs_init_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "105-147",
    "snippet": "static int ntfs_init_locked_inode(struct inode *vi, ntfs_attr *na)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tvi->i_ino = na->mft_no;\n\n\tni->type = na->type;\n\tif (na->type == AT_INDEX_ALLOCATION)\n\t\tNInoSetMstProtected(ni);\n\n\tni->name = na->name;\n\tni->name_len = na->name_len;\n\n\t/* If initializing a normal inode, we are done. */\n\tif (likely(na->type == AT_UNUSED)) {\n\t\tBUG_ON(na->name);\n\t\tBUG_ON(na->name_len);\n\t\treturn 0;\n\t}\n\n\t/* It is a fake inode. */\n\tNInoSetAttr(ni);\n\n\t/*\n\t * We have I30 global constant as an optimization as it is the name\n\t * in >99.9% of named attributes! The other <0.1% incur a GFP_ATOMIC\n\t * allocation but that is ok. And most attributes are unnamed anyway,\n\t * thus the fraction of named attributes with name != I30 is actually\n\t * absolutely tiny.\n\t */\n\tif (na->name_len && na->name != I30) {\n\t\tunsigned int i;\n\n\t\tBUG_ON(!na->name);\n\t\ti = na->name_len * sizeof(ntfschar);\n\t\tni->name = kmalloc(i + sizeof(ntfschar), GFP_ATOMIC);\n\t\tif (!ni->name)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ni->name, na->name, i);\n\t\tni->name[na->name_len] = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ni->name",
            "na->name",
            "i"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "i + sizeof(ntfschar)",
            "GFP_ATOMIC"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!na->name"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetAttr",
          "args": [
            "ni"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "na->name_len"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "na->name"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "na->type == AT_UNUSED"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetMstProtected",
          "args": [
            "ni"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_init_locked_inode(struct inode *vi, ntfs_attr *na)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tvi->i_ino = na->mft_no;\n\n\tni->type = na->type;\n\tif (na->type == AT_INDEX_ALLOCATION)\n\t\tNInoSetMstProtected(ni);\n\n\tni->name = na->name;\n\tni->name_len = na->name_len;\n\n\t/* If initializing a normal inode, we are done. */\n\tif (likely(na->type == AT_UNUSED)) {\n\t\tBUG_ON(na->name);\n\t\tBUG_ON(na->name_len);\n\t\treturn 0;\n\t}\n\n\t/* It is a fake inode. */\n\tNInoSetAttr(ni);\n\n\t/*\n\t * We have I30 global constant as an optimization as it is the name\n\t * in >99.9% of named attributes! The other <0.1% incur a GFP_ATOMIC\n\t * allocation but that is ok. And most attributes are unnamed anyway,\n\t * thus the fraction of named attributes with name != I30 is actually\n\t * absolutely tiny.\n\t */\n\tif (na->name_len && na->name != I30) {\n\t\tunsigned int i;\n\n\t\tBUG_ON(!na->name);\n\t\ti = na->name_len * sizeof(ntfschar);\n\t\tni->name = kmalloc(i + sizeof(ntfschar), GFP_ATOMIC);\n\t\tif (!ni->name)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ni->name, na->name, i);\n\t\tni->name[na->name_len] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_test_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
    "lines": "61-85",
    "snippet": "int ntfs_test_inode(struct inode *vi, ntfs_attr *na)\n{\n\tntfs_inode *ni;\n\n\tif (vi->i_ino != na->mft_no)\n\t\treturn 0;\n\tni = NTFS_I(vi);\n\t/* If !NInoAttr(ni), @vi is a normal file or directory inode. */\n\tif (likely(!NInoAttr(ni))) {\n\t\t/* If not looking for a normal inode this is a mismatch. */\n\t\tif (unlikely(na->type != AT_UNUSED))\n\t\t\treturn 0;\n\t} else {\n\t\t/* A fake inode describing an attribute. */\n\t\tif (ni->type != na->type)\n\t\t\treturn 0;\n\t\tif (ni->name_len != na->name_len)\n\t\t\treturn 0;\n\t\tif (na->name_len && memcmp(ni->name, na->name,\n\t\t\t\tna->name_len * sizeof(ntfschar)))\n\t\t\treturn 0;\n\t}\n\t/* Match! */\n\treturn 1;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"time.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/aio.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ntfs_read_locked_inode(struct inode *vi);",
      "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
      "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ni->name",
            "na->name",
            "na->name_len * sizeof(ntfschar)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "na->type != AT_UNUSED"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!NInoAttr(ni)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint ntfs_test_inode(struct inode *vi, ntfs_attr *na)\n{\n\tntfs_inode *ni;\n\n\tif (vi->i_ino != na->mft_no)\n\t\treturn 0;\n\tni = NTFS_I(vi);\n\t/* If !NInoAttr(ni), @vi is a normal file or directory inode. */\n\tif (likely(!NInoAttr(ni))) {\n\t\t/* If not looking for a normal inode this is a mismatch. */\n\t\tif (unlikely(na->type != AT_UNUSED))\n\t\t\treturn 0;\n\t} else {\n\t\t/* A fake inode describing an attribute. */\n\t\tif (ni->type != na->type)\n\t\t\treturn 0;\n\t\tif (ni->name_len != na->name_len)\n\t\t\treturn 0;\n\t\tif (na->name_len && memcmp(ni->name, na->name,\n\t\t\t\tna->name_len * sizeof(ntfschar)))\n\t\t\treturn 0;\n\t}\n\t/* Match! */\n\treturn 1;\n}"
  }
]