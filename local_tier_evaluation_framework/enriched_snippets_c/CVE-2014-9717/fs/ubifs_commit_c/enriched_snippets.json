[
  {
    "function_name": "_index(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "565-734",
    "snippet": "_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint lnum, offs, len, err = 0, uninitialized_var(last_level), child_cnt;\n\tint first = 1, iip;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tunion ubifs_key uninitialized_var(lower_key), upper_key, l_key, u_key;\n\tunsigned long long uninitialized_var(last_sqnum);\n\tstruct ubifs_idx_node *idx;\n\tstruct list_head list;\n\tstruct idx_node *i;\n\tsize_t sz;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&list);\n\n\tsz = sizeof(struct idx_node) + ubifs_idx_node_sz(c, c->fanout) -\n\t     UBIFS_IDX_NODE_SZ;\n\n\t/* Start at the old zroot */\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\tiip = 0;\n\n\t/*\n\t * Traverse the index tree preorder depth-first i.e. do a node and then\n\t * its subtrees from left to right.\n\t */\n\twhile (1) {\n\t\tstruct ubifs_branch *br;\n\n\t\t/* Get the next index node */\n\t\ti = kmalloc(sz, GFP_NOFS);\n\t\tif (!i) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\ti->iip = iip;\n\t\t/* Keep the index nodes on our path in a linked list */\n\t\tlist_add_tail(&i->list, &list);\n\t\t/* Read the index node */\n\t\tidx = &i->idx;\n\t\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\t/* Validate index node */\n\t\tchild_cnt = le16_to_cpu(idx->child_cnt);\n\t\tif (child_cnt < 1 || child_cnt > c->fanout) {\n\t\t\terr = 1;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\t/* Check root level and sqnum */\n\t\t\tif (le16_to_cpu(idx->level) != d->old_zroot_level) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (le64_to_cpu(idx->ch.sqnum) != d->old_zroot_sqnum) {\n\t\t\t\terr = 3;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\t/* Set last values as though root had a parent */\n\t\t\tlast_level = le16_to_cpu(idx->level) + 1;\n\t\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum) + 1;\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &lower_key);\n\t\t\thighest_ino_key(c, &upper_key, INUM_WATERMARK);\n\t\t}\n\t\tkey_copy(c, &upper_key, &i->upper_key);\n\t\tif (le16_to_cpu(idx->level) != last_level - 1) {\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/*\n\t\t * The index is always written bottom up hence a child's sqnum\n\t\t * is always less than the parents.\n\t\t */\n\t\tif (le64_to_cpu(idx->ch.sqnum) >= last_sqnum) {\n\t\t\terr = 4;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/* Check key range */\n\t\tkey_read(c, ubifs_idx_key(c, idx), &l_key);\n\t\tbr = ubifs_idx_branch(c, idx, child_cnt - 1);\n\t\tkey_read(c, &br->key, &u_key);\n\t\tif (keys_cmp(c, &lower_key, &l_key) > 0) {\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) < 0) {\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) == 0)\n\t\t\tif (!is_hash_key(c, &u_key)) {\n\t\t\t\terr = 7;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t/* Go to next index node */\n\t\tif (le16_to_cpu(idx->level) == 0) {\n\t\t\t/* At the bottom, so go up until can go right */\n\t\t\twhile (1) {\n\t\t\t\t/* Drop the bottom of the list */\n\t\t\t\tlist_del(&i->list);\n\t\t\t\tkfree(i);\n\t\t\t\t/* No more list means we are done */\n\t\t\t\tif (list_empty(&list))\n\t\t\t\t\tgoto out;\n\t\t\t\t/* Look at the new bottom */\n\t\t\t\ti = list_entry(list.prev, struct idx_node,\n\t\t\t\t\t       list);\n\t\t\t\tidx = &i->idx;\n\t\t\t\t/* Can we go right */\n\t\t\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\t\t\tiip = iip + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t/* Nope, so go up again */\n\t\t\t\t\tiip = i->iip;\n\t\t\t}\n\t\t} else\n\t\t\t/* Go down left */\n\t\t\tiip = 0;\n\t\t/*\n\t\t * We have the parent in 'idx' and now we set up for reading the\n\t\t * child pointed to by slot 'iip'.\n\t\t */\n\t\tlast_level = le16_to_cpu(idx->level);\n\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum);\n\t\tbr = ubifs_idx_branch(c, idx, iip);\n\t\tlnum = le32_to_cpu(br->lnum);\n\t\toffs = le32_to_cpu(br->offs);\n\t\tlen = le32_to_cpu(br->len);\n\t\tkey_read(c, &br->key, &lower_key);\n\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\tbr = ubifs_idx_branch(c, idx, iip + 1);\n\t\t\tkey_read(c, &br->key, &upper_key);\n\t\t} else\n\t\t\tkey_copy(c, &i->upper_key, &upper_key);\n\t}\nout:\n\terr = dbg_old_index_check_init(c, zroot);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"dumping index node (iip=%d)\", i->iip);\n\tubifs_dump_node(c, idx);\n\tlist_del(&i->list);\n\tkfree(i);\n\tif (!list_empty(&list)) {\n\t\ti = list_entry(list.prev, struct idx_node, list);\n\t\tubifs_err(\"dumping parent index node\");\n\t\tubifs_dump_node(c, &i->idx);\n\t}\nout_free:\n\twhile (!list_empty(&list)) {\n\t\ti = list_entry(list.next, struct idx_node, list);\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n\tubifs_err(\"failed, error %d\", err);\n\tif (err > 0)\n\t\terr = -EINVAL;\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iled, err",
          "args": [
            "r %d\", err);\n\tif (",
            "r >"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubif",
          "args": [
            "_"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "ld_commit(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
          "lines": "479-493",
          "snippet": "should_commit(struct ubifs_info *c)\n{\n\tint ret = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BACKGROUND) {\n\t\tdbg_cmt(\"commit required now\");\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t} else\n\t\tdbg_cmt(\"commit not requested\");\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tret = 1;\n\tspin_unlock(&c->cs_lock);\n\treturn ret;\n}\n\n/*\n * Every",
          "includes": [
            "fs.h\"\n\n/*\n * nothin",
            "ux/slab.h>\n#include \"ubi",
            "ux/kthread.h>\n#include <lin",
            "ux/freezer.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nshould_commit(struct ubifs_info *c)\n{\n\tint ret = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BACKGROUND) {\n\t\tdbg_cmt(\"commit required now\");\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t} else\n\t\tdbg_cmt(\"commit not requested\");\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tret = 1;\n\tspin_unlock(&c->cs_lock);\n\treturn ret;\n}\n\n/*\n * Every"
        }
      },
      {
        "call_info": {
          "callee": "list);",
          "args": [
            "kfree(i)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.next, s",
          "args": [
            "ruct idx_",
            "de, lit);\n\t\tli",
            "_del"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist)) {",
          "args": [
            "= li"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, &i->idx);",
          "args": [
            "out_fre"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping par",
          "args": [
            "nt index node\");\n\t\tubifs_du"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.prev, s",
          "args": [
            "ruct idx_",
            "de, lit);\n\t\tub",
            "s_er"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist)) {",
          "args": [
            "= li"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(!li",
          "args": [
            "t"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list);",
          "args": [
            "free(i);"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, idx);\n\tli",
          "args": [
            "t",
            "el("
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping ind",
          "args": [
            "x node (iip=%d)\", i->iip);\n\tu",
            "fs_dum"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_check_init(c, zroot);",
          "args": [
            "f",
            "err)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->upper",
          "args": [
            "k",
            ", &upper_key)",
            "}\nout:\n\te"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key,",
          "args": [
            "&",
            "per_key)",
            "} else"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, iip",
          "args": [
            ";",
            "key_rea"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->child_c",
          "args": [
            "t)) {\n\t\t\tbr ="
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key,",
          "args": [
            "&",
            "wer_key)",
            "if (iip"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->len);",
          "args": [
            "ey_read"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->offs);",
          "args": [
            "len = le"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->lnum);",
          "args": [
            "offs = l"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, iip)",
          "args": [
            "lnu",
            "= l"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->ch.sqnu",
          "args": [
            ");\n\t\tbr = ubi"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "last_sqn"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->child_c",
          "args": [
            "t)) {\n\t\t\t\t\tiip"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.prev, s",
          "args": [
            "ruct idx_",
            "de,",
            "x ="
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist))",
          "args": [
            "goto"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "/* N",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list);",
          "args": [
            "kfree("
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level)",
          "args": [
            "= 0) {"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &u_key))",
          "args": [
            "err"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_ke",
          "args": [
            ",",
            "u_key) ==",
            "if"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_ke",
          "args": [
            ",",
            "u_key) < 0",
            "{\n\t\t\te"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_ke",
          "args": [
            ",",
            "l_key) > 0",
            "{\n\t\t\te"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key,",
          "args": [
            "&",
            "key);",
            "(keys"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, chil",
          "args": [
            "_",
            "t -",
            ");\n\t\tkey_read"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_idx",
          "args": [
            "k",
            "(c, idx), &l_key);",
            "= ubi"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, idx), &l_",
          "args": [
            "e",
            ";"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->ch.sqnu",
          "args": [
            ") >= last_sqn"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level)",
          "args": [
            "= last_lev"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_ke",
          "args": [
            ",",
            "i->upper_k",
            ");\n\t\tif (le16"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &upper_ke",
          "args": [
            ",",
            "NUM_WATERM",
            "K);\n\t\t}\n\t\tkey_"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_idx",
          "args": [
            "k",
            "(c, idx), &lower_key)",
            "highest"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, idx), &lo",
          "args": [
            "e",
            "key"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->ch.sqnu",
          "args": [
            ") + 1;\n\t\t\tkey"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level)",
          "args": [
            "1;\n\t\t\tlas"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->ch.sqnu",
          "args": [
            ") != d->old_z"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level)",
          "args": [
            "= d->old_z"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->child_c",
          "args": [
            "t);\n\t\tif (chil"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, idx, UBIF",
          "args": [
            "_",
            "X_N",
            "E, len, lnum,",
            "fs)",
            "if",
            "err)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&i->list, &l",
          "args": [
            "st);\n\t\t/",
            "Read"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FP_NOFS",
          "args": [
            ";",
            "if (!i)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->fanout",
          "args": [
            "UBI"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&list);\n\n\tsz",
          "args": [
            "= siz"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\n_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint lnum, offs, len, err = 0, uninitialized_var(last_level), child_cnt;\n\tint first = 1, iip;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tunion ubifs_key uninitialized_var(lower_key), upper_key, l_key, u_key;\n\tunsigned long long uninitialized_var(last_sqnum);\n\tstruct ubifs_idx_node *idx;\n\tstruct list_head list;\n\tstruct idx_node *i;\n\tsize_t sz;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&list);\n\n\tsz = sizeof(struct idx_node) + ubifs_idx_node_sz(c, c->fanout) -\n\t     UBIFS_IDX_NODE_SZ;\n\n\t/* Start at the old zroot */\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\tiip = 0;\n\n\t/*\n\t * Traverse the index tree preorder depth-first i.e. do a node and then\n\t * its subtrees from left to right.\n\t */\n\twhile (1) {\n\t\tstruct ubifs_branch *br;\n\n\t\t/* Get the next index node */\n\t\ti = kmalloc(sz, GFP_NOFS);\n\t\tif (!i) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\ti->iip = iip;\n\t\t/* Keep the index nodes on our path in a linked list */\n\t\tlist_add_tail(&i->list, &list);\n\t\t/* Read the index node */\n\t\tidx = &i->idx;\n\t\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\t/* Validate index node */\n\t\tchild_cnt = le16_to_cpu(idx->child_cnt);\n\t\tif (child_cnt < 1 || child_cnt > c->fanout) {\n\t\t\terr = 1;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\t/* Check root level and sqnum */\n\t\t\tif (le16_to_cpu(idx->level) != d->old_zroot_level) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (le64_to_cpu(idx->ch.sqnum) != d->old_zroot_sqnum) {\n\t\t\t\terr = 3;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\t/* Set last values as though root had a parent */\n\t\t\tlast_level = le16_to_cpu(idx->level) + 1;\n\t\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum) + 1;\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &lower_key);\n\t\t\thighest_ino_key(c, &upper_key, INUM_WATERMARK);\n\t\t}\n\t\tkey_copy(c, &upper_key, &i->upper_key);\n\t\tif (le16_to_cpu(idx->level) != last_level - 1) {\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/*\n\t\t * The index is always written bottom up hence a child's sqnum\n\t\t * is always less than the parents.\n\t\t */\n\t\tif (le64_to_cpu(idx->ch.sqnum) >= last_sqnum) {\n\t\t\terr = 4;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/* Check key range */\n\t\tkey_read(c, ubifs_idx_key(c, idx), &l_key);\n\t\tbr = ubifs_idx_branch(c, idx, child_cnt - 1);\n\t\tkey_read(c, &br->key, &u_key);\n\t\tif (keys_cmp(c, &lower_key, &l_key) > 0) {\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) < 0) {\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) == 0)\n\t\t\tif (!is_hash_key(c, &u_key)) {\n\t\t\t\terr = 7;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t/* Go to next index node */\n\t\tif (le16_to_cpu(idx->level) == 0) {\n\t\t\t/* At the bottom, so go up until can go right */\n\t\t\twhile (1) {\n\t\t\t\t/* Drop the bottom of the list */\n\t\t\t\tlist_del(&i->list);\n\t\t\t\tkfree(i);\n\t\t\t\t/* No more list means we are done */\n\t\t\t\tif (list_empty(&list))\n\t\t\t\t\tgoto out;\n\t\t\t\t/* Look at the new bottom */\n\t\t\t\ti = list_entry(list.prev, struct idx_node,\n\t\t\t\t\t       list);\n\t\t\t\tidx = &i->idx;\n\t\t\t\t/* Can we go right */\n\t\t\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\t\t\tiip = iip + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t/* Nope, so go up again */\n\t\t\t\t\tiip = i->iip;\n\t\t\t}\n\t\t} else\n\t\t\t/* Go down left */\n\t\t\tiip = 0;\n\t\t/*\n\t\t * We have the parent in 'idx' and now we set up for reading the\n\t\t * child pointed to by slot 'iip'.\n\t\t */\n\t\tlast_level = le16_to_cpu(idx->level);\n\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum);\n\t\tbr = ubifs_idx_branch(c, idx, iip);\n\t\tlnum = le32_to_cpu(br->lnum);\n\t\toffs = le32_to_cpu(br->offs);\n\t\tlen = le32_to_cpu(br->len);\n\t\tkey_read(c, &br->key, &lower_key);\n\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\tbr = ubifs_idx_branch(c, idx, iip + 1);\n\t\t\tkey_read(c, &br->key, &upper_key);\n\t\t} else\n\t\t\tkey_copy(c, &i->upper_key, &upper_key);\n\t}\nout:\n\terr = dbg_old_index_check_init(c, zroot);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"dumping index node (iip=%d)\", i->iip);\n\tubifs_dump_node(c, idx);\n\tlist_del(&i->list);\n\tkfree(i);\n\tif (!list_empty(&list)) {\n\t\ti = list_entry(list.prev, struct idx_node, list);\n\t\tubifs_err(\"dumping parent index node\");\n\t\tubifs_dump_node(c, &i->idx);\n\t}\nout_free:\n\twhile (!list_empty(&list)) {\n\t\ti = list_entry(list.next, struct idx_node, list);\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n\tubifs_err(\"failed, error %d\", err);\n\tif (err > 0)\n\t\terr = -EINVAL;\n\treturn err;\n}"
  },
  {
    "function_name": "_check_init(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "526-550",
    "snippet": "ndex_check_init(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tstruct ubifs_idx_node *idx;\n\tint lnum, offs, len, err = 0;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\td->old_zroot = *zroot;\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err)\n\t\tgoto out;\n\n\td->old_zroot_level = le16_to_cpu(idx->level);\n\td->old_zroot_sqnum = le64_to_cpu(idx->ch.sqnum);\nout:\n\tkfree(idx);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx->ch.sqnu",
          "args": [
            ");\nout:\n\tkfre"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "d->old_zr"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, idx, UBIF",
          "args": [
            "_",
            "X_N",
            "E, len, lnum,",
            "fs)",
            "if",
            "rr)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_idx_n",
          "args": [
            "de_sz, GFP_NOFS);",
            "f (!idx)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nndex_check_init(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tstruct ubifs_idx_node *idx;\n\tint lnum, offs, len, err = 0;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\td->old_zroot = *zroot;\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err)\n\t\tgoto out;\n\n\td->old_zroot_level = le16_to_cpu(idx->level);\n\td->old_zroot_sqnum = le64_to_cpu(idx->ch.sqnum);\nout:\n\tkfree(idx);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "ld_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "479-493",
    "snippet": "should_commit(struct ubifs_info *c)\n{\n\tint ret = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BACKGROUND) {\n\t\tdbg_cmt(\"commit required now\");\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t} else\n\t\tdbg_cmt(\"commit not requested\");\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tret = 1;\n\tspin_unlock(&c->cs_lock);\n\treturn ret;\n}\n\n/*\n * Every",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return re"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it not",
          "args": [
            "equested\");\n\tif (c->cm"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it requ",
          "args": [
            "red now\");\n\t\tc->cmt_s"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "if (c->cm"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nshould_commit(struct ubifs_info *c)\n{\n\tint ret = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BACKGROUND) {\n\t\tdbg_cmt(\"commit required now\");\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t} else\n\t\tdbg_cmt(\"commit not requested\");\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tret = 1;\n\tspin_unlock(&c->cs_lock);\n\treturn ret;\n}\n\n/*\n * Every"
  },
  {
    "function_name": "mit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "411-466",
    "snippet": "_commit(struct ubifs_info *c)\n{\n\tint err = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\t/*\n\t\t * We set the commit state to 'running required' to indicate\n\t\t * that we want it to complete as quickly as possible.\n\t\t */\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tspin_unlock(&c->cs_lock);\n\n\t/* Ok, the commit is indeed needed */\n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\t/*\n\t * Since we unlocked 'c->cs_lock', the state may have changed, so\n\t * re-check it.\n\t */\n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out_cmt_unlock;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tup_write(&c->commit_sem);\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\tspin_unlock(&c->cs_lock);\n\n\terr = do_commit(c);\n\treturn err;\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return er"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_s",
          "args": [
            "m);\nout:\n\tspin"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "return",
          "args": [
            "r"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "err = do"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it(c);\n\t}\n\tc->c",
          "args": [
            "t"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return w"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "/*\n\t * Si"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "/* Ok, t"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it(c);\n\t}\n\tspin",
          "args": [
            "u"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return w"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "if (c->cm"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\n_commit(struct ubifs_info *c)\n{\n\tint err = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\t/*\n\t\t * We set the commit state to 'running required' to indicate\n\t\t * that we want it to complete as quickly as possible.\n\t\t */\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tspin_unlock(&c->cs_lock);\n\n\t/* Ok, the commit is indeed needed */\n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\t/*\n\t * Since we unlocked 'c->cs_lock', the state may have changed, so\n\t * re-check it.\n\t */\n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out_cmt_unlock;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tup_write(&c->commit_sem);\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\tspin_unlock(&c->cs_lock);\n\n\terr = do_commit(c);\n\treturn err;\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "it(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "387-402",
    "snippet": "it_for_commit(struct ubifs_info *c)\n{\n\tdbg_cmt(\"pid %d goes sleep\", current->pid);\n\n\t/*\n\t * The following sleeps if the condition is false, and will be woken\n\t * when the commit ends. It is possible, although very unlikely, that we\n\t * will wake up and see the subsequent commit running, rather than the\n\t * one we were waiting for, and go back to sleep.  However, we will be\n\t * woken again, so there is no danger of sleeping forever.\n\t */\n\twait_event(c->cmt_wq, c->cmt_state != COMMIT_RUNNING_BACKGROUND &&\n\t\t\t      c->cmt_state != COMMIT_RUNNING_REQUIRED);\n\tdbg_cmt(\"commit finished, pid %d woke up\", current->pid);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "it fini",
          "args": [
            "hed, pid %d woke up\", current->pi",
            ";\n\treturn 0;"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cmt_wq, c",
          "args": [
            ">cmt_stat",
            "!= COMMIT_RUNNING_BACKGROUND &&\n\t\t\t      c->cmt_state != COMMIT_RUNNING_REQUIRED);\n\tdbg_cmt(\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d goes",
          "args": [
            "sleep\", current->pi",
            ";\n\n\t/*\n\t * T"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nit_for_commit(struct ubifs_info *c)\n{\n\tdbg_cmt(\"pid %d goes sleep\", current->pid);\n\n\t/*\n\t * The following sleeps if the condition is false, and will be woken\n\t * when the commit ends. It is possible, although very unlikely, that we\n\t * will wake up and see the subsequent commit running, rather than the\n\t * one we were waiting for, and go back to sleep.  However, we will be\n\t * woken again, so there is no danger of sleeping forever.\n\t */\n\twait_event(c->cmt_wq, c->cmt_state != COMMIT_RUNNING_BACKGROUND &&\n\t\t\t      c->cmt_state != COMMIT_RUNNING_REQUIRED);\n\tdbg_cmt(\"commit finished, pid %d woke up\", current->pid);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_bg_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "368-379",
    "snippet": "quest_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_RESTING) {\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_BACKGROUND));\n\t\tc->cmt_state = COMMIT_BACKGROUND;\n\t\tspin_unlock(&c->cs_lock);\n\t\tubifs_wake_up_bgt(c);\n\t} else\n\t\tspin_unlock(&c->cs_lock);\n}\n\n/**\n * wait",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "}\n\n/**\n *"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bgt(c);\n\t} else",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "ubifs_wa"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s, ne",
          "args": [
            ": %s\", dbg_cstate(",
            ">cmt_state),\n\t\t\tdbg_csta",
            "MMIT_BACKGROUND));\n\t\tc->cmt_s"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMIT_BACKG",
          "args": [
            "OUND));\n\t\tc->cmt_"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cmt_state",
          "args": [
            ",\n\t\t\tdbg_cst"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "if (c->cm"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nquest_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_RESTING) {\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_BACKGROUND));\n\t\tc->cmt_state = COMMIT_BACKGROUND;\n\t\tspin_unlock(&c->cs_lock);\n\t\tubifs_wake_up_bgt(c);\n\t} else\n\t\tspin_unlock(&c->cs_lock);\n}\n\n/**\n * wait"
  },
  {
    "function_name": "required(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "338-359",
    "snippet": "mmit_required(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tswitch (c->cmt_state) {\n\tcase COMMIT_RESTING:\n\tcase COMMIT_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_REQUIRED));\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_RUNNING_REQUIRED));\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_REQUIRED:\n\tcase COMMIT_RUNNING_REQUIRED:\n\tcase COMMIT_BROKEN:\n\t\tbreak;\n\t}\n\tspin_unlock(&c->cs_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "}\n\n/**\n *"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s, ne",
          "args": [
            ": %s\", dbg_cstate(",
            ">cmt_state),\n\t\t\tdbg_csta",
            "MMIT_RUNNING_REQUIRED));\n\t\tc->cmt_s"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMIT_RUNNI",
          "args": [
            "G_REQUIRED));\n\t\tc->cmt_"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cmt_state",
          "args": [
            ",\n\t\t\tdbg_cst"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s, ne",
          "args": [
            ": %s\", dbg_cstate(",
            ">cmt_state),\n\t\t\tdbg_csta",
            "MMIT_REQUIRED));\n\t\tc->cmt_s"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMIT_REQUI",
          "args": [
            "ED));\n\t\tc->cmt_"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cmt_state",
          "args": [
            ",\n\t\t\tdbg_cst"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "switch (c"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nmmit_required(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tswitch (c->cmt_state) {\n\tcase COMMIT_RESTING:\n\tcase COMMIT_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_REQUIRED));\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_RUNNING_REQUIRED));\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_REQUIRED:\n\tcase COMMIT_RUNNING_REQUIRED:\n\tcase COMMIT_BROKEN:\n\t\tbreak;\n\t}\n\tspin_unlock(&c->cs_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ad(void *info)",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "287-329",
    "snippet": "thread(void *info)\n{\n\tint err;\n\tstruct ubifs_info *c = info;\n\n\tubifs_msg(\"background thread \\\"%s\\\" started, PID %d\",\n\t\t  c->bgt_name, current->pid);\n\tset_freezable();\n\n\twhile (1) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t/* Check if there is something to do */\n\t\tif (!c->need_bgt) {\n\t\t\t/*\n\t\t\t * Nothing prevents us from going sleep now and\n\t\t\t * be never woken up and block the task which\n\t\t\t * could wait in 'kthread_stop()' forever.\n\t\t\t */\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t} else\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\tc->need_bgt = 0;\n\t\terr = ubifs_bg_wbufs_sync(c);\n\t\tif (err)\n\t\t\tubifs_ro_mode(c, err);\n\n\t\trun_bg_commit(c);\n\t\tcond_resched();\n\t}\n\n\tubifs_msg(\"background thread \\\"%s\\\" stops\", c->bgt_name);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ckground",
          "args": [
            "hread \\\"%s\\\" stops\", c->bgt_name",
            "return 0;"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\n\t}\n\n\tubif",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t\tcond_r",
          "args": [
            "s"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);",
          "args": [
            "u",
            "bg_"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sync(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_state(TASK_RUNNING",
          "args": [
            ";\n\n\t\tc->need"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contin",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_stop())\n\t\t\t\tbreak",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tate(TASK_INTERRU",
          "args": [
            "TIBLE);\n\t\t/* Check"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "())\n\t\t\tcontin",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_stop())\n\t\t\tbreak;",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "();\n\n\twhile (",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ckground",
          "args": [
            "hread \\\"%s\\\" started, PID %d\",\n\t\t  c->bgt_",
            "current->pi",
            ";\n\tset_freez"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nthread(void *info)\n{\n\tint err;\n\tstruct ubifs_info *c = info;\n\n\tubifs_msg(\"background thread \\\"%s\\\" started, PID %d\",\n\t\t  c->bgt_name, current->pid);\n\tset_freezable();\n\n\twhile (1) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t/* Check if there is something to do */\n\t\tif (!c->need_bgt) {\n\t\t\t/*\n\t\t\t * Nothing prevents us from going sleep now and\n\t\t\t * be never woken up and block the task which\n\t\t\t * could wait in 'kthread_stop()' forever.\n\t\t\t */\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t} else\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\tc->need_bgt = 0;\n\t\terr = ubifs_bg_wbufs_sync(c);\n\t\tif (err)\n\t\t\tubifs_ro_mode(c, err);\n\n\t\trun_bg_commit(c);\n\t\tcond_resched();\n\t}\n\n\tubifs_msg(\"background thread \\\"%s\\\" stops\", c->bgt_name);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "244-273",
    "snippet": "n_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\t/*\n\t * Run background commit only if background commit was requested or if\n\t * commit is required.\n\t */\n\tif (c->cmt_state != COMMIT_BACKGROUND &&\n\t    c->cmt_state != COMMIT_REQUIRED)\n\t\tgoto out;\n\tspin_unlock(&c->cs_lock);\n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\telse if (c->cmt_state == COMMIT_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_BACKGROUND;\n\telse\n\t\tgoto out_cmt_unlock;\n\tspin_unlock(&c->cs_lock);\n\n\treturn do_commit(c);\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return 0;"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_s",
          "args": [
            "m);\nout:\n\tspin"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "out_cmt",
          "args": [
            "u"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return d"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "if (c->cm"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "down_wri"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "/*\n\t * Ru"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nn_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\t/*\n\t * Run background commit only if background commit was requested or if\n\t * commit is required.\n\t */\n\tif (c->cmt_state != COMMIT_BACKGROUND &&\n\t    c->cmt_state != COMMIT_REQUIRED)\n\t\tgoto out;\n\tspin_unlock(&c->cs_lock);\n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\telse if (c->cmt_state == COMMIT_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_BACKGROUND;\n\telse\n\t\tgoto out_cmt_unlock;\n\tspin_unlock(&c->cs_lock);\n\n\treturn do_commit(c);\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "109-235",
    "snippet": "_commit(struct ubifs_info *c)\n{\n\tint err, new_ltail_lnum, old_ltail_lnum, i;\n\tstruct ubifs_zbranch zroot;\n\tstruct ubifs_lp_stats lst;\n\n\tdbg_cmt(\"start\");\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_up;\n\t}\n\n\tif (nothing_to_commit(c)) {\n\t\tup_write(&c->commit_sem);\n\t\terr = 0;\n\t\tgoto out_cancel;\n\t}\n\n\t/* Sync all write buffers (necessary for recovery) */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\tgoto out_up;\n\t}\n\n\tc->cmt_no += 1;\n\terr = ubifs_gc_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = dbg_check_lprops(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_log_start_commit(c, &new_ltail_lnum);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_tnc_start_commit(c, &zroot);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_lpt_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_orphan_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\n\tubifs_get_lp_stats(c, &lst);\n\n\tup_write(&c->commit_sem);\n\n\terr = ubifs_tnc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_orphan_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_old_index(c, &zroot);\n\tif (err)\n\t\tgoto out;\n\n\tc->mst_node->cmt_no      = cpu_to_le64(c->cmt_no);\n\tc->mst_node->log_lnum    = cpu_to_le32(new_ltail_lnum);\n\tc->mst_node->root_lnum   = cpu_to_le32(zroot.lnum);\n\tc->mst_node->root_offs   = cpu_to_le32(zroot.offs);\n\tc->mst_node->root_len    = cpu_to_le32(zroot.len);\n\tc->mst_node->ihead_lnum  = cpu_to_le32(c->ihead_lnum);\n\tc->mst_node->ihead_offs  = cpu_to_le32(c->ihead_offs);\n\tc->mst_node->index_size  = cpu_to_le64(c->bi.old_idx_sz);\n\tc->mst_node->lpt_lnum    = cpu_to_le32(c->lpt_lnum);\n\tc->mst_node->lpt_offs    = cpu_to_le32(c->lpt_offs);\n\tc->mst_node->nhead_lnum  = cpu_to_le32(c->nhead_lnum);\n\tc->mst_node->nhead_offs  = cpu_to_le32(c->nhead_offs);\n\tc->mst_node->ltab_lnum   = cpu_to_le32(c->ltab_lnum);\n\tc->mst_node->ltab_offs   = cpu_to_le32(c->ltab_offs);\n\tc->mst_node->lsave_lnum  = cpu_to_le32(c->lsave_lnum);\n\tc->mst_node->lsave_offs  = cpu_to_le32(c->lsave_offs);\n\tc->mst_node->lscan_lnum  = cpu_to_le32(c->lscan_lnum);\n\tc->mst_node->empty_lebs  = cpu_to_le32(lst.empty_lebs);\n\tc->mst_node->idx_lebs    = cpu_to_le32(lst.idx_lebs);\n\tc->mst_node->total_free  = cpu_to_le64(lst.total_free);\n\tc->mst_node->total_dirty = cpu_to_le64(lst.total_dirty);\n\tc->mst_node->total_used  = cpu_to_le64(lst.total_used);\n\tc->mst_node->total_dead  = cpu_to_le64(lst.total_dead);\n\tc->mst_node->total_dark  = cpu_to_le64(lst.total_dark);\n\tif (c->no_orphs)\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\telse\n\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\n\told_ltail_lnum = c->ltail_lnum;\n\terr = ubifs_log_end_commit(c, new_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_log_post_commit(c, old_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_gc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_post_commit(c);\n\tif (err)\n\t\tgoto out;\n\nout_cancel:\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_RESTING;\n\twake_up(&c->cmt_wq);\n\tdbg_cmt(\"commit end\");\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n\nout_up:\n\tup_write(&c->commit_sem);\nout:\n\tubifs_err(\"commit failed, error %d\", err);\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_BROKEN;\n\twake_up(&c->cmt_wq);\n\tspin_unlock(&c->cs_lock);\n\tubifs_ro_mode(c, err);\n\treturn err;\n}\n\n/**\n * run_",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(c, err);\n\tre",
          "args": [
            "u",
            "er"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "ubifs_ro_"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mt_wq);",
          "args": [
            "spin_unlo"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "c->cmt_st"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmit fail",
          "args": [
            "d, error %d\", err);\n\tspin",
            "ock"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_s",
          "args": [
            "m);\nout:\n\tubif"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->cs_lock)",
          "args": [
            "return 0;"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it end\"",
          "args": [
            ";\n\tspin_unlo"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mt_wq);",
          "args": [
            "dbg_cmt(\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cs_lock)",
          "args": [
            "c->cmt_st"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_commit(c);\n\tif (err",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit(c);\n\tif (err",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_commit(c, old_ltail",
          "args": [
            "l",
            "m);\n\tif (err)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_commit(c, new_ltail",
          "args": [
            "l",
            "m);\n\tif (err)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_NO",
          "args": [
            "ORPHS);\n\n\told_ltai"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_NO",
          "args": [
            "ORPHS);\n\telse\n\t\tc-"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.total_da",
          "args": [
            "k);\n\tif (c->no"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.total_de",
          "args": [
            "d);\n\tc->mst_no"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.total_us",
          "args": [
            "d);\n\tc->mst_no"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.total_di",
          "args": [
            "ty);\n\tc->mst_no"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.total_fr",
          "args": [
            "e);\n\tc->mst_no"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.idx_lebs",
          "args": [
            ";\n\tc->mst_no"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.empty_le",
          "args": [
            "s);\n\tc->mst_no"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lscan_lnu",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lsave_off",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lsave_lnu",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ltab_offs",
          "args": [
            ";\n\tc->mst_no"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ltab_lnum",
          "args": [
            ";\n\tc->mst_no"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->nhead_off",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->nhead_lnu",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lpt_offs)",
          "args": [
            "c->mst_no"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lpt_lnum)",
          "args": [
            "c->mst_no"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->bi.old_id",
          "args": [
            "_sz);\n\tc->mst_no"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ihead_off",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ihead_lnu",
          "args": [
            ");\n\tc->mst_no"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.len);",
          "args": [
            "c->mst_no"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.offs);",
          "args": [
            "c->mst_no"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.lnum);",
          "args": [
            "c->mst_no"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_ltail_ln",
          "args": [
            "m);\n\tc->mst_no"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->cmt_no);",
          "args": [
            "c->mst_no"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_index(c, &zroot);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_commit(c);\n\tif (err",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_commit(c);\n\tif (err",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_commit(c);\n\tif (err",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stats(c, &lst);",
          "args": [
            "p",
            "rite"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_commit(c);\n\tif (err",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_commit(c);\n\tif (err",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_commit(c, &zroot);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_commit(c, &new_ltai",
          "args": [
            "_",
            "um);\n\tif (err)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\tif (err",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_commit(c);\n\tif (err",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\t\tif (err)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmit(c)) {\n\t\tup_w",
          "args": [
            "i"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\n\tif (c->r"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t\");\n\tu",
          "args": [
            "ifs_ass"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\n_commit(struct ubifs_info *c)\n{\n\tint err, new_ltail_lnum, old_ltail_lnum, i;\n\tstruct ubifs_zbranch zroot;\n\tstruct ubifs_lp_stats lst;\n\n\tdbg_cmt(\"start\");\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_up;\n\t}\n\n\tif (nothing_to_commit(c)) {\n\t\tup_write(&c->commit_sem);\n\t\terr = 0;\n\t\tgoto out_cancel;\n\t}\n\n\t/* Sync all write buffers (necessary for recovery) */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\tgoto out_up;\n\t}\n\n\tc->cmt_no += 1;\n\terr = ubifs_gc_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = dbg_check_lprops(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_log_start_commit(c, &new_ltail_lnum);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_tnc_start_commit(c, &zroot);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_lpt_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_orphan_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\n\tubifs_get_lp_stats(c, &lst);\n\n\tup_write(&c->commit_sem);\n\n\terr = ubifs_tnc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_orphan_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_old_index(c, &zroot);\n\tif (err)\n\t\tgoto out;\n\n\tc->mst_node->cmt_no      = cpu_to_le64(c->cmt_no);\n\tc->mst_node->log_lnum    = cpu_to_le32(new_ltail_lnum);\n\tc->mst_node->root_lnum   = cpu_to_le32(zroot.lnum);\n\tc->mst_node->root_offs   = cpu_to_le32(zroot.offs);\n\tc->mst_node->root_len    = cpu_to_le32(zroot.len);\n\tc->mst_node->ihead_lnum  = cpu_to_le32(c->ihead_lnum);\n\tc->mst_node->ihead_offs  = cpu_to_le32(c->ihead_offs);\n\tc->mst_node->index_size  = cpu_to_le64(c->bi.old_idx_sz);\n\tc->mst_node->lpt_lnum    = cpu_to_le32(c->lpt_lnum);\n\tc->mst_node->lpt_offs    = cpu_to_le32(c->lpt_offs);\n\tc->mst_node->nhead_lnum  = cpu_to_le32(c->nhead_lnum);\n\tc->mst_node->nhead_offs  = cpu_to_le32(c->nhead_offs);\n\tc->mst_node->ltab_lnum   = cpu_to_le32(c->ltab_lnum);\n\tc->mst_node->ltab_offs   = cpu_to_le32(c->ltab_offs);\n\tc->mst_node->lsave_lnum  = cpu_to_le32(c->lsave_lnum);\n\tc->mst_node->lsave_offs  = cpu_to_le32(c->lsave_offs);\n\tc->mst_node->lscan_lnum  = cpu_to_le32(c->lscan_lnum);\n\tc->mst_node->empty_lebs  = cpu_to_le32(lst.empty_lebs);\n\tc->mst_node->idx_lebs    = cpu_to_le32(lst.idx_lebs);\n\tc->mst_node->total_free  = cpu_to_le64(lst.total_free);\n\tc->mst_node->total_dirty = cpu_to_le64(lst.total_dirty);\n\tc->mst_node->total_used  = cpu_to_le64(lst.total_used);\n\tc->mst_node->total_dead  = cpu_to_le64(lst.total_dead);\n\tc->mst_node->total_dark  = cpu_to_le64(lst.total_dark);\n\tif (c->no_orphs)\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\telse\n\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\n\told_ltail_lnum = c->ltail_lnum;\n\terr = ubifs_log_end_commit(c, new_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_log_post_commit(c, old_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_gc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_post_commit(c);\n\tif (err)\n\t\tgoto out;\n\nout_cancel:\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_RESTING;\n\twake_up(&c->cmt_wq);\n\tdbg_cmt(\"commit end\");\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n\nout_up:\n\tup_write(&c->commit_sem);\nout:\n\tubifs_err(\"commit failed, error %d\", err);\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_BROKEN;\n\twake_up(&c->cmt_wq);\n\tspin_unlock(&c->cs_lock);\n\tubifs_ro_mode(c, err);\n\treturn err;\n}\n\n/**\n * run_"
  },
  {
    "function_name": "mmit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
    "lines": "68-99",
    "snippet": "thing_to_commit(struct ubifs_info *c)\n{\n\t/*\n\t * During mounting or remounting from R/O mode to R/W mode we may\n\t * commit for various recovery-related reasons.\n\t */\n\tif (c->mounting || c->remounting_rw)\n\t\treturn 0;\n\n\t/*\n\t * If the root TNC node is dirty, we definitely have something to\n\t * commit.\n\t */\n\tif (c->zroot.znode && ubifs_zn_dirty(c->zroot.znode))\n\t\treturn 0;\n\n\t/*\n\t * Even though the TNC is clean, the LPT tree may have dirty nodes. For\n\t * example, this may happen if the budgeting subsystem invoked GC to\n\t * make some free space, and the GC found an LEB with only dirty and\n\t * free space. In this case GC would just change the lprops of this\n\t * LEB (by turning all space into free space) and unmap it.\n\t */\n\tif (c->nroot && test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tubifs_assert(atomic_long_read(&c->dirty_zn_cnt) == 0);\n\tubifs_assert(c->dirty_pn_cnt == 0);\n\tubifs_assert(c->dirty_nn_cnt == 0);\n\n\treturn 1;\n}\n\n/**\n * do_c",
    "includes": [
      "fs.h\"\n\n/*\n * nothin",
      "ux/slab.h>\n#include \"ubi",
      "ux/kthread.h>\n#include <lin",
      "ux/freezer.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->dirty_nn_",
          "args": [
            "nt == 0);\n\n\treturn 1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->dirty_pn_",
          "args": [
            "nt == 0);\n\tubifs_ass"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_",
          "args": [
            "ead(&c->dirty_zn_cnt) == 0);\n\tubifs_ass"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt) == 0);\n\tubi"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&c->nroot->",
            "ags))\n\t\treturn 0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(c->zroot.zno",
          "args": [
            "e))\n\t\treturn 0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\nthing_to_commit(struct ubifs_info *c)\n{\n\t/*\n\t * During mounting or remounting from R/O mode to R/W mode we may\n\t * commit for various recovery-related reasons.\n\t */\n\tif (c->mounting || c->remounting_rw)\n\t\treturn 0;\n\n\t/*\n\t * If the root TNC node is dirty, we definitely have something to\n\t * commit.\n\t */\n\tif (c->zroot.znode && ubifs_zn_dirty(c->zroot.znode))\n\t\treturn 0;\n\n\t/*\n\t * Even though the TNC is clean, the LPT tree may have dirty nodes. For\n\t * example, this may happen if the budgeting subsystem invoked GC to\n\t * make some free space, and the GC found an LEB with only dirty and\n\t * free space. In this case GC would just change the lprops of this\n\t * LEB (by turning all space into free space) and unmap it.\n\t */\n\tif (c->nroot && test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tubifs_assert(atomic_long_read(&c->dirty_zn_cnt) == 0);\n\tubifs_assert(c->dirty_pn_cnt == 0);\n\tubifs_assert(c->dirty_nn_cnt == 0);\n\n\treturn 1;\n}\n\n/**\n * do_c"
  }
]