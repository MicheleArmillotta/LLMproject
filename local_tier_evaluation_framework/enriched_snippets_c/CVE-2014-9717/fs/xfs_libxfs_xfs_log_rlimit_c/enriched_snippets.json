[
  {
    "function_name": "xfs_log_calc_minimum_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
    "lines": "94-148",
    "snippet": "int\nxfs_log_calc_minimum_size(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\ttres = {0};\n\tint\t\t\tmax_logres;\n\tint\t\t\tmin_logblks = 0;\n\tint\t\t\tlsunit = 0;\n\n\txfs_log_get_max_trans_res(mp, &tres);\n\n\tmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\n\tif (tres.tr_logcount > 1)\n\t\tmax_logres *= tres.tr_logcount;\n\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1)\n\t\tlsunit = BTOBB(mp->m_sb.sb_logsunit);\n\n\t/*\n\t * Two factors should be taken into account for calculating the minimum\n\t * log space.\n\t * 1) The fundamental limitation is that no single transaction can be\n\t *    larger than half size of the log.\n\t *\n\t *    From mkfs.xfs, this is considered by the XFS_MIN_LOG_FACTOR\n\t *    define, which is set to 3. That means we can definitely fit\n\t *    maximally sized 2 transactions in the log. We'll use this same\n\t *    value here.\n\t *\n\t * 2) If the lsunit option is specified, a transaction requires 2 LSU\n\t *    for the reservation because there are two log writes that can\n\t *    require padding - the transaction data and the commit record which\n\t *    are written separately and both can require padding to the LSU.\n\t *    Consider that we can have an active CIL reservation holding 2*LSU,\n\t *    but the CIL is not over a push threshold, in this case, if we\n\t *    don't have enough log space for at one new transaction, which\n\t *    includes another 2*LSU in the reservation, we will run into dead\n\t *    loop situation in log space grant procedure. i.e.\n\t *    xlog_grant_head_wait().\n\t *\n\t *    Hence the log size needs to be able to contain two maximally sized\n\t *    and padded transactions, which is (2 * (2 * LSU + maxlres)).\n\t *\n\t * Also, the log size should be a multiple of the log stripe unit, round\n\t * it up to lsunit boundary if lsunit is specified.\n\t */\n\tif (lsunit) {\n\t\tmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\n\t\t\t      2 * lsunit;\n\t} else\n\t\tmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\n\tmin_logblks *= XFS_MIN_LOG_FACTOR;\n\n\treturn XFS_BB_TO_FSB(mp, min_logblks);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "min_logblks"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "max_logres"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_64",
          "args": [
            "BTOBB(max_logres)",
            "lsunit"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "max_logres"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_logsunit"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_calc_unit_res",
          "args": [
            "mp",
            "tres.tr_logres"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_calc_unit_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3518-3609",
          "snippet": "int\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_get_max_trans_res",
          "args": [
            "mp",
            "&tres"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_get_max_trans_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
          "lines": "58-86",
          "snippet": "STATIC void\nxfs_log_get_max_trans_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*max_resp)\n{\n\tstruct xfs_trans_res\t*resp;\n\tstruct xfs_trans_res\t*end_resp;\n\tint\t\t\tlog_space = 0;\n\tint\t\t\tattr_space;\n\n\tattr_space = xfs_log_calc_max_attrsetm_res(mp);\n\n\tresp = (struct xfs_trans_res *)M_RES(mp);\n\tend_resp = (struct xfs_trans_res *)(M_RES(mp) + 1);\n\tfor (; resp < end_resp; resp++) {\n\t\tint\t\ttmp = resp->tr_logcount > 1 ?\n\t\t\t\t      resp->tr_logres * resp->tr_logcount :\n\t\t\t\t      resp->tr_logres;\n\t\tif (log_space < tmp) {\n\t\t\tlog_space = tmp;\n\t\t\t*max_resp = *resp;\t\t/* struct copy */\n\t\t}\n\t}\n\n\tif (attr_space > log_space) {\n\t\t*max_resp = M_RES(mp)->tr_attrsetm;\t/* struct copy */\n\t\tmax_resp->tr_logres = attr_space;\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_log_get_max_trans_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*max_resp)\n{\n\tstruct xfs_trans_res\t*resp;\n\tstruct xfs_trans_res\t*end_resp;\n\tint\t\t\tlog_space = 0;\n\tint\t\t\tattr_space;\n\n\tattr_space = xfs_log_calc_max_attrsetm_res(mp);\n\n\tresp = (struct xfs_trans_res *)M_RES(mp);\n\tend_resp = (struct xfs_trans_res *)(M_RES(mp) + 1);\n\tfor (; resp < end_resp; resp++) {\n\t\tint\t\ttmp = resp->tr_logcount > 1 ?\n\t\t\t\t      resp->tr_logres * resp->tr_logcount :\n\t\t\t\t      resp->tr_logres;\n\t\tif (log_space < tmp) {\n\t\t\tlog_space = tmp;\n\t\t\t*max_resp = *resp;\t\t/* struct copy */\n\t\t}\n\t}\n\n\tif (attr_space > log_space) {\n\t\t*max_resp = M_RES(mp)->tr_attrsetm;\t/* struct copy */\n\t\tmax_resp->tr_logres = attr_space;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_calc_minimum_size(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\ttres = {0};\n\tint\t\t\tmax_logres;\n\tint\t\t\tmin_logblks = 0;\n\tint\t\t\tlsunit = 0;\n\n\txfs_log_get_max_trans_res(mp, &tres);\n\n\tmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\n\tif (tres.tr_logcount > 1)\n\t\tmax_logres *= tres.tr_logcount;\n\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1)\n\t\tlsunit = BTOBB(mp->m_sb.sb_logsunit);\n\n\t/*\n\t * Two factors should be taken into account for calculating the minimum\n\t * log space.\n\t * 1) The fundamental limitation is that no single transaction can be\n\t *    larger than half size of the log.\n\t *\n\t *    From mkfs.xfs, this is considered by the XFS_MIN_LOG_FACTOR\n\t *    define, which is set to 3. That means we can definitely fit\n\t *    maximally sized 2 transactions in the log. We'll use this same\n\t *    value here.\n\t *\n\t * 2) If the lsunit option is specified, a transaction requires 2 LSU\n\t *    for the reservation because there are two log writes that can\n\t *    require padding - the transaction data and the commit record which\n\t *    are written separately and both can require padding to the LSU.\n\t *    Consider that we can have an active CIL reservation holding 2*LSU,\n\t *    but the CIL is not over a push threshold, in this case, if we\n\t *    don't have enough log space for at one new transaction, which\n\t *    includes another 2*LSU in the reservation, we will run into dead\n\t *    loop situation in log space grant procedure. i.e.\n\t *    xlog_grant_head_wait().\n\t *\n\t *    Hence the log size needs to be able to contain two maximally sized\n\t *    and padded transactions, which is (2 * (2 * LSU + maxlres)).\n\t *\n\t * Also, the log size should be a multiple of the log stripe unit, round\n\t * it up to lsunit boundary if lsunit is specified.\n\t */\n\tif (lsunit) {\n\t\tmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\n\t\t\t      2 * lsunit;\n\t} else\n\t\tmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\n\tmin_logblks *= XFS_MIN_LOG_FACTOR;\n\n\treturn XFS_BB_TO_FSB(mp, min_logblks);\n}"
  },
  {
    "function_name": "xfs_log_get_max_trans_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
    "lines": "58-86",
    "snippet": "STATIC void\nxfs_log_get_max_trans_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*max_resp)\n{\n\tstruct xfs_trans_res\t*resp;\n\tstruct xfs_trans_res\t*end_resp;\n\tint\t\t\tlog_space = 0;\n\tint\t\t\tattr_space;\n\n\tattr_space = xfs_log_calc_max_attrsetm_res(mp);\n\n\tresp = (struct xfs_trans_res *)M_RES(mp);\n\tend_resp = (struct xfs_trans_res *)(M_RES(mp) + 1);\n\tfor (; resp < end_resp; resp++) {\n\t\tint\t\ttmp = resp->tr_logcount > 1 ?\n\t\t\t\t      resp->tr_logres * resp->tr_logcount :\n\t\t\t\t      resp->tr_logres;\n\t\tif (log_space < tmp) {\n\t\t\tlog_space = tmp;\n\t\t\t*max_resp = *resp;\t\t/* struct copy */\n\t\t}\n\t}\n\n\tif (attr_space > log_space) {\n\t\t*max_resp = M_RES(mp)->tr_attrsetm;\t/* struct copy */\n\t\tmax_resp->tr_logres = attr_space;\n\t}\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_calc_max_attrsetm_res",
          "args": [
            "mp"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_calc_max_attrsetm_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
          "lines": "36-51",
          "snippet": "STATIC int\nxfs_log_calc_max_attrsetm_res(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\n\t       MAXNAMELEN - 1;\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tnblks += XFS_B_TO_FSB(mp, size);\n\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\n\n\treturn  M_RES(mp)->tr_attrsetm.tr_logres +\n\t\tM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_log_calc_max_attrsetm_res(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\n\t       MAXNAMELEN - 1;\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tnblks += XFS_B_TO_FSB(mp, size);\n\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\n\n\treturn  M_RES(mp)->tr_attrsetm.tr_logres +\n\t\tM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_log_get_max_trans_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*max_resp)\n{\n\tstruct xfs_trans_res\t*resp;\n\tstruct xfs_trans_res\t*end_resp;\n\tint\t\t\tlog_space = 0;\n\tint\t\t\tattr_space;\n\n\tattr_space = xfs_log_calc_max_attrsetm_res(mp);\n\n\tresp = (struct xfs_trans_res *)M_RES(mp);\n\tend_resp = (struct xfs_trans_res *)(M_RES(mp) + 1);\n\tfor (; resp < end_resp; resp++) {\n\t\tint\t\ttmp = resp->tr_logcount > 1 ?\n\t\t\t\t      resp->tr_logres * resp->tr_logcount :\n\t\t\t\t      resp->tr_logres;\n\t\tif (log_space < tmp) {\n\t\t\tlog_space = tmp;\n\t\t\t*max_resp = *resp;\t\t/* struct copy */\n\t\t}\n\t}\n\n\tif (attr_space > log_space) {\n\t\t*max_resp = M_RES(mp)->tr_attrsetm;\t/* struct copy */\n\t\tmax_resp->tr_logres = attr_space;\n\t}\n}"
  },
  {
    "function_name": "xfs_log_calc_max_attrsetm_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
    "lines": "36-51",
    "snippet": "STATIC int\nxfs_log_calc_max_attrsetm_res(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\n\t       MAXNAMELEN - 1;\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tnblks += XFS_B_TO_FSB(mp, size);\n\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\n\n\treturn  M_RES(mp)->tr_attrsetm.tr_logres +\n\t\tM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_NEXTENTADD_SPACE_RES",
          "args": [
            "mp",
            "size",
            "XFS_ATTR_FORK"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "size"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DAENTER_SPACE_RES",
          "args": [
            "mp",
            "XFS_ATTR_FORK"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize_local_max",
          "args": [
            "mp->m_attr_geo->blksize"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "825-828",
          "snippet": "static inline int xfs_attr_leaf_entsize_local_max(int bsize)\n{\n\treturn (((bsize) >> 1) + ((bsize) >> 2));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_attr_leaf_entsize_local_max(int bsize)\n{\n\treturn (((bsize) >> 1) + ((bsize) >> 2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_log_calc_max_attrsetm_res(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\n\t       MAXNAMELEN - 1;\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tnblks += XFS_B_TO_FSB(mp, size);\n\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\n\n\treturn  M_RES(mp)->tr_attrsetm.tr_logres +\n\t\tM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\n}"
  }
]