[
  {
    "function_name": "ext4_check_blockref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "223-242",
    "snippet": "int ext4_check_blockref(const char *function, unsigned int line,\n\t\t\tstruct inode *inode, __le32 *p, unsigned int max)\n{\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\t__le32 *bref = p;\n\tunsigned int blk;\n\n\twhile (bref < p+max) {\n\t\tblk = le32_to_cpu(*bref++);\n\t\tif (blk &&\n\t\t    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t    blk, 1))) {\n\t\t\tes->s_last_error_block = cpu_to_le64(blk);\n\t\t\text4_error_inode(inode, function, line, blk,\n\t\t\t\t\t \"invalid block\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "inode",
            "function",
            "line",
            "blk",
            "\"invalid block\""
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blk"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t    blk, 1)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "blk",
            "1"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*bref++"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_check_blockref(const char *function, unsigned int line,\n\t\t\tstruct inode *inode, __le32 *p, unsigned int max)\n{\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\t__le32 *bref = p;\n\tunsigned int blk;\n\n\twhile (bref < p+max) {\n\t\tblk = le32_to_cpu(*bref++);\n\t\tif (blk &&\n\t\t    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t    blk, 1))) {\n\t\t\tes->s_last_error_block = cpu_to_le64(blk);\n\t\t\text4_error_inode(inode, function, line, blk,\n\t\t\t\t\t \"invalid block\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_data_block_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "197-221",
    "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blk"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext4_system_zone",
            "node"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blk"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "sbi->s_es"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_data_block"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_release_system_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "181-190",
    "snippet": "void ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_system_zone_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_system_zone_cachep",
            "entry"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbtree_postorder_for_each_entry_safe",
          "args": [
            "entry",
            "n",
            "&EXT4_SB(sb)->system_blks",
            "node"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}"
  },
  {
    "function_name": "ext4_setup_system_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "140-178",
    "snippet": "int ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_print_tree",
          "args": [
            "EXT4_SB(sb)"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "debug_print_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "122-138",
          "snippet": "static void debug_print_tree(struct ext4_sb_info *sbi)\n{\n\tstruct rb_node *node;\n\tstruct ext4_system_zone *entry;\n\tint first = 1;\n\n\tprintk(KERN_INFO \"System zones: \");\n\tnode = rb_first(&sbi->system_blks);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tprintk(\"%s%llu-%llu\", first ? \"\" : \", \",\n\t\t       entry->start_blk, entry->start_blk + entry->count - 1);\n\t\tfirst = 0;\n\t\tnode = rb_next(node);\n\t}\n\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void debug_print_tree(struct ext4_sb_info *sbi)\n{\n\tstruct rb_node *node;\n\tstruct ext4_system_zone *entry;\n\tint first = 1;\n\n\tprintk(KERN_INFO \"System zones: \");\n\tnode = rb_first(&sbi->system_blks);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tprintk(\"%s%llu-%llu\", first ? \"\" : \", \",\n\t\t       entry->start_blk, entry->start_blk + entry->count - 1);\n\t\tfirst = 0;\n\t\tnode = rb_next(node);\n\t}\n\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_system_zone",
          "args": [
            "sbi",
            "ext4_inode_table(sb, gdp)",
            "sbi->s_itb_per_group"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "add_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "57-120",
          "snippet": "static int add_system_zone(struct ext4_sb_info *sbi,\n\t\t\t   ext4_fsblk_t start_blk,\n\t\t\t   unsigned int count)\n{\n\tstruct ext4_system_zone *new_entry = NULL, *entry;\n\tstruct rb_node **n = &sbi->system_blks.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\tif (start_blk + count > (entry->start_blk +\n\t\t\t\t\t\t entry->count))\n\t\t\t\tentry->count = (start_blk + count -\n\t\t\t\t\t\tentry->start_blk);\n\t\t\tnew_node = *n;\n\t\t\tnew_entry = rb_entry(new_node, struct ext4_system_zone,\n\t\t\t\t\t     node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!new_entry) {\n\t\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tnew_entry->start_blk = start_blk;\n\t\tnew_entry->count = count;\n\t\tnew_node = &new_entry->node;\n\n\t\trb_link_node(new_node, parent, n);\n\t\trb_insert_color(new_node, &sbi->system_blks);\n\t}\n\n\t/* Can we merge to the left? */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(entry, new_entry)) {\n\t\t\tnew_entry->start_blk = entry->start_blk;\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\n\t/* Can we merge to the right? */\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(new_entry, entry)) {\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nstatic int add_system_zone(struct ext4_sb_info *sbi,\n\t\t\t   ext4_fsblk_t start_blk,\n\t\t\t   unsigned int count)\n{\n\tstruct ext4_system_zone *new_entry = NULL, *entry;\n\tstruct rb_node **n = &sbi->system_blks.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\tif (start_blk + count > (entry->start_blk +\n\t\t\t\t\t\t entry->count))\n\t\t\t\tentry->count = (start_blk + count -\n\t\t\t\t\t\tentry->start_blk);\n\t\t\tnew_node = *n;\n\t\t\tnew_entry = rb_entry(new_node, struct ext4_system_zone,\n\t\t\t\t\t     node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!new_entry) {\n\t\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tnew_entry->start_blk = start_blk;\n\t\tnew_entry->count = count;\n\t\tnew_node = &new_entry->node;\n\n\t\trb_link_node(new_node, parent, n);\n\t\trb_insert_color(new_node, &sbi->system_blks);\n\t}\n\n\t/* Can we merge to the left? */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(entry, new_entry)) {\n\t\t\tnew_entry->start_blk = entry->start_blk;\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\n\t/* Can we merge to the right? */\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(new_entry, entry)) {\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "i"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "i"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "i"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_release_system_zone",
          "args": [
            "sb"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_release_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "181-190",
          "snippet": "void ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "BLOCK_VALIDITY"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_bg_size",
          "args": [
            "sbi"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}"
  },
  {
    "function_name": "debug_print_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "122-138",
    "snippet": "static void debug_print_tree(struct ext4_sb_info *sbi)\n{\n\tstruct rb_node *node;\n\tstruct ext4_system_zone *entry;\n\tint first = 1;\n\n\tprintk(KERN_INFO \"System zones: \");\n\tnode = rb_first(&sbi->system_blks);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tprintk(\"%s%llu-%llu\", first ? \"\" : \", \",\n\t\t       entry->start_blk, entry->start_blk + entry->count - 1);\n\t\tfirst = 0;\n\t\tnode = rb_next(node);\n\t}\n\tprintk(\"\\n\");\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structext4_system_zone",
            "node"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sbi->system_blks"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void debug_print_tree(struct ext4_sb_info *sbi)\n{\n\tstruct rb_node *node;\n\tstruct ext4_system_zone *entry;\n\tint first = 1;\n\n\tprintk(KERN_INFO \"System zones: \");\n\tnode = rb_first(&sbi->system_blks);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tprintk(\"%s%llu-%llu\", first ? \"\" : \", \",\n\t\t       entry->start_blk, entry->start_blk + entry->count - 1);\n\t\tfirst = 0;\n\t\tnode = rb_next(node);\n\t}\n\tprintk(\"\\n\");\n}"
  },
  {
    "function_name": "add_system_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "57-120",
    "snippet": "static int add_system_zone(struct ext4_sb_info *sbi,\n\t\t\t   ext4_fsblk_t start_blk,\n\t\t\t   unsigned int count)\n{\n\tstruct ext4_system_zone *new_entry = NULL, *entry;\n\tstruct rb_node **n = &sbi->system_blks.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\tif (start_blk + count > (entry->start_blk +\n\t\t\t\t\t\t entry->count))\n\t\t\t\tentry->count = (start_blk + count -\n\t\t\t\t\t\tentry->start_blk);\n\t\t\tnew_node = *n;\n\t\t\tnew_entry = rb_entry(new_node, struct ext4_system_zone,\n\t\t\t\t\t     node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!new_entry) {\n\t\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tnew_entry->start_blk = start_blk;\n\t\tnew_entry->count = count;\n\t\tnew_node = &new_entry->node;\n\n\t\trb_link_node(new_node, parent, n);\n\t\trb_insert_color(new_node, &sbi->system_blks);\n\t}\n\n\t/* Can we merge to the left? */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(entry, new_entry)) {\n\t\t\tnew_entry->start_blk = entry->start_blk;\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\n\t/* Can we merge to the right? */\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(new_entry, entry)) {\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_system_zone_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_system_zone_cachep",
            "entry"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&sbi->system_blks"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_merge",
          "args": [
            "new_entry",
            "entry"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "44-50",
          "snippet": "static inline int can_merge(struct ext4_system_zone *entry1,\n\t\t     struct ext4_system_zone *entry2)\n{\n\tif ((entry1->start_blk + entry1->count) == entry2->start_blk)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int can_merge(struct ext4_system_zone *entry1,\n\t\t     struct ext4_system_zone *entry2)\n{\n\tif ((entry1->start_blk + entry1->count) == entry2->start_blk)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structext4_system_zone",
            "node"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "new_node"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_system_zone_cachep",
            "entry"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&sbi->system_blks"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structext4_system_zone",
            "node"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "new_node"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "new_node",
            "&sbi->system_blks"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "new_node",
            "parent",
            "n"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_system_zone_cachep",
            "GFP_KERNEL"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "new_node",
            "structext4_system_zone",
            "node"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structext4_system_zone",
            "node"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nstatic int add_system_zone(struct ext4_sb_info *sbi,\n\t\t\t   ext4_fsblk_t start_blk,\n\t\t\t   unsigned int count)\n{\n\tstruct ext4_system_zone *new_entry = NULL, *entry;\n\tstruct rb_node **n = &sbi->system_blks.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\tif (start_blk + count > (entry->start_blk +\n\t\t\t\t\t\t entry->count))\n\t\t\t\tentry->count = (start_blk + count -\n\t\t\t\t\t\tentry->start_blk);\n\t\t\tnew_node = *n;\n\t\t\tnew_entry = rb_entry(new_node, struct ext4_system_zone,\n\t\t\t\t\t     node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!new_entry) {\n\t\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tnew_entry->start_blk = start_blk;\n\t\tnew_entry->count = count;\n\t\tnew_node = &new_entry->node;\n\n\t\trb_link_node(new_node, parent, n);\n\t\trb_insert_color(new_node, &sbi->system_blks);\n\t}\n\n\t/* Can we merge to the left? */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(entry, new_entry)) {\n\t\t\tnew_entry->start_blk = entry->start_blk;\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\n\t/* Can we merge to the right? */\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(new_entry, entry)) {\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &sbi->system_blks);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "44-50",
    "snippet": "static inline int can_merge(struct ext4_system_zone *entry1,\n\t\t     struct ext4_system_zone *entry2)\n{\n\tif ((entry1->start_blk + entry1->count) == entry2->start_blk)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int can_merge(struct ext4_system_zone *entry1,\n\t\t     struct ext4_system_zone *entry2)\n{\n\tif ((entry1->start_blk + entry1->count) == entry2->start_blk)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_exit_system_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "39-42",
    "snippet": "void ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_system_zone_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_system_zone_cachep"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}"
  },
  {
    "function_name": "ext4_init_system_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
    "lines": "31-37",
    "snippet": "int __init ext4_init_system_zone(void)\n{\n\text4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);\n\tif (ext4_system_zone_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_system_zone_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ext4_system_zone",
            "0"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nint __init ext4_init_system_zone(void)\n{\n\text4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);\n\tif (ext4_system_zone_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]