[
  {
    "function_name": "xfs_iflush_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "3310-3466",
    "snippet": "STATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_iodone != NULL"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_fspriv != NULL"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "mp",
            "dip"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "iip->ili_item.li_lsn"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_attach_iodone",
          "args": [
            "bp",
            "xfs_iflush_done",
            "&iip->ili_item"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_attach_iodone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "987-1009",
          "snippet": "void\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_copy_lsn",
          "args": [
            "mp->m_ail",
            "&iip->ili_flush_lsn",
            "&iip->ili_item.li_lsn"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_copy_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "151-159",
          "snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobp_check",
          "args": [
            "mp",
            "bp"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "37-57",
          "snippet": "void\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush_fork",
          "args": [
            "ip",
            "dip",
            "iip",
            "XFS_ATTR_FORK"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "792-876",
          "snippet": "void\nxfs_iflush_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\txfs_inode_log_item_t\t*iip,\n\tint\t\t\twhichfork)\n{\n\tchar\t\t\t*cp;\n\txfs_ifork_t\t\t*ifp;\n\txfs_mount_t\t\t*mp;\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\t/*\n\t * This can happen if we gave up in iformat in an error path,\n\t * for the attribute fork.\n\t */\n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (XFS_IFORK_FORMAT(ip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tASSERT((ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_fields & extflag[whichfork]));\n\t\tif ((iip->ili_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(xfs_iext_get_ext(ifp, 0));\n\t\t\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        XFS_IFORK_SIZE(ip, whichfork));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip, ip->i_df.if_u2.if_rdev);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_UUID:\n\t\tif (iip->ili_fields & XFS_ILOG_UUID) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t\t       &ip->i_df.if_u2.if_uuid,\n\t\t\t       sizeof(uuid_t));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nvoid\nxfs_iflush_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\txfs_inode_log_item_t\t*iip,\n\tint\t\t\twhichfork)\n{\n\tchar\t\t\t*cp;\n\txfs_ifork_t\t\t*ifp;\n\txfs_mount_t\t\t*mp;\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\t/*\n\t * This can happen if we gave up in iformat in an error path,\n\t * for the attribute fork.\n\t */\n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (XFS_IFORK_FORMAT(ip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tASSERT((ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_fields & extflag[whichfork]));\n\t\tif ((iip->ili_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(xfs_iext_get_ext(ifp, 0));\n\t\t\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        XFS_IFORK_SIZE(ip, whichfork));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip, ip->i_df.if_u2.if_rdev);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_UUID:\n\t\tif (iip->ili_fields & XFS_ILOG_UUID) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t\t       &ip->i_df.if_u2.if_uuid,\n\t\t\t       sizeof(uuid_t));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_to_disk",
          "args": [
            "dip",
            "&ip->i_d"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "240-287",
          "snippet": "void\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "mp",
            "XFS_PTAG_IFLUSH",
            "\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\"",
            "__func__",
            "ip->i_ino",
            "ip->i_d.di_forkoff",
            "ip"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "ip->i_d.di_forkoff > mp->m_sb.sb_inodesize",
            "mp",
            "XFS_ERRTAG_IFLUSH_6",
            "XFS_RANDOM_IFLUSH_6"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks",
            "mp",
            "XFS_ERRTAG_IFLUSH_5",
            "XFS_RANDOM_IFLUSH_5"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)",
            "mp",
            "XFS_ERRTAG_IFLUSH_4",
            "XFS_RANDOM_IFLUSH_4"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE)",
            "mp",
            "XFS_ERRTAG_IFLUSH_3",
            "XFS_RANDOM_IFLUSH_3"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "ip->i_d.di_magic != XFS_DINODE_MAGIC",
            "mp",
            "XFS_ERRTAG_IFLUSH_2",
            "XFS_RANDOM_IFLUSH_2"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_magic"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC)",
            "mp",
            "XFS_ERRTAG_IFLUSH_1",
            "XFS_RANDOM_IFLUSH_1"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DINODE_MAGIC"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "ip->i_imap.im_boffset"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version > 1"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iip != NULL && iip->ili_fields != 0"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK)"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isiflocked(ip)"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isiflocked",
          "args": [
            "ip"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isiflocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "252-255",
          "snippet": "static inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL|XFS_ILOCK_SHARED"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}"
  },
  {
    "function_name": "xfs_iflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "3215-3308",
    "snippet": "int\nxfs_iflush(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_dinode\t*dip;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_iflush_count);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\n\t*bpp = NULL;\n\n\txfs_iunpin_wait(ip);\n\n\t/*\n\t * For stale inodes we cannot rely on the backing buffer remaining\n\t * stale in cache for the remaining life of the stale inode and so\n\t * xfs_imap_to_bp() below may give us a buffer that no longer contains\n\t * inodes below. We have to check this after ensuring the inode is\n\t * unpinned so that it is safe to reclaim the stale inode after the\n\t * flush call.\n\t */\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_ifunlock(ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this inode\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an empty AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto abort_out;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk inode.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &bp, XBF_TRYLOCK,\n\t\t\t       0);\n\tif (error || !bp) {\n\t\txfs_ifunlock(ip);\n\t\treturn error;\n\t}\n\n\t/*\n\t * First flush out the inode that xfs_iflush was called with.\n\t */\n\terror = xfs_iflush_int(ip, bp);\n\tif (error)\n\t\tgoto corrupt_out;\n\n\t/*\n\t * If the buffer is pinned then push on the log now so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp))\n\t\txfs_log_force(mp, 0);\n\n\t/*\n\t * inode clustering:\n\t * see if other inodes can be gathered into this write\n\t */\n\terror = xfs_iflush_cluster(ip, bp);\n\tif (error)\n\t\tgoto cluster_corrupt_out;\n\n\t*bpp = bp;\n\treturn 0;\n\ncorrupt_out:\n\txfs_buf_relse(bp);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\ncluster_corrupt_out:\n\terror = -EFSCORRUPTED;\nabort_out:\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(ip, false);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iflush_abort",
          "args": [
            "ip",
            "false"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "698-734",
          "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 3299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush_cluster",
          "args": [
            "ip",
            "bp"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "3054-3204",
          "snippet": "STATIC int\nxfs_iflush_cluster(\n\txfs_inode_t\t*ip,\n\txfs_buf_t\t*bp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\tunsigned long\t\tfirst_index, mask;\n\tunsigned long\t\tinodes_per_cluster;\n\tint\t\t\tilist_size;\n\txfs_inode_t\t\t**ilist;\n\txfs_inode_t\t\t*iq;\n\tint\t\t\tnr_found;\n\tint\t\t\tclcount = 0;\n\tint\t\t\tbufwasdelwri;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\tinodes_per_cluster = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\tilist_size = inodes_per_cluster * sizeof(xfs_inode_t *);\n\tilist = kmem_alloc(ilist_size, KM_MAYFAIL|KM_NOFS);\n\tif (!ilist)\n\t\tgoto out_put;\n\n\tmask = ~(((mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino) & mask;\n\trcu_read_lock();\n\t/* really need a gang lookup range call here */\n\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root, (void**)ilist,\n\t\t\t\t\tfirst_index, inodes_per_cluster);\n\tif (nr_found == 0)\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_found; i++) {\n\t\tiq = ilist[i];\n\t\tif (iq == ip)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * because this is an RCU protected lookup, we could find a\n\t\t * recently freed or even reallocated inode during the lookup.\n\t\t * We need to check under the i_flags_lock for a valid inode\n\t\t * here. Skip it if it is not valid or the wrong inode.\n\t\t */\n\t\tspin_lock(&ip->i_flags_lock);\n\t\tif (!ip->i_ino ||\n\t\t    (XFS_INO_TO_AGINO(mp, iq->i_ino) & mask) != first_index) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Do an un-protected check to see if the inode is dirty and\n\t\t * is a candidate for flushing.  These checks will be repeated\n\t\t * later after the appropriate locks are acquired.\n\t\t */\n\t\tif (xfs_inode_clean(iq) && xfs_ipincount(iq) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Try to get locks.  If any are unavailable or it is pinned,\n\t\t * then this inode cannot be flushed and is skipped.\n\t\t */\n\n\t\tif (!xfs_ilock_nowait(iq, XFS_ILOCK_SHARED))\n\t\t\tcontinue;\n\t\tif (!xfs_iflock_nowait(iq)) {\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfs_ipincount(iq)) {\n\t\t\txfs_ifunlock(iq);\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * arriving here means that this inode can be flushed.  First\n\t\t * re-check that it's dirty before flushing.\n\t\t */\n\t\tif (!xfs_inode_clean(iq)) {\n\t\t\tint\terror;\n\t\t\terror = xfs_iflush_int(iq, bp);\n\t\t\tif (error) {\n\t\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\t\tgoto cluster_corrupt_out;\n\t\t\t}\n\t\t\tclcount++;\n\t\t} else {\n\t\t\txfs_ifunlock(iq);\n\t\t}\n\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t}\n\n\tif (clcount) {\n\t\tXFS_STATS_INC(xs_icluster_flushcnt);\n\t\tXFS_STATS_ADD(xs_icluster_flushinode, clcount);\n\t}\n\nout_free:\n\trcu_read_unlock();\n\tkmem_free(ilist);\nout_put:\n\txfs_perag_put(pag);\n\treturn 0;\n\n\ncluster_corrupt_out:\n\t/*\n\t * Corruption detected in the clustering loop.  Invalidate the\n\t * inode buffer and shut down the filesystem.\n\t */\n\trcu_read_unlock();\n\t/*\n\t * Clean up the buffer.  If it was delwri, just release it --\n\t * brelse can handle it with no problems.  If not, shut down the\n\t * filesystem before releasing the buffer.\n\t */\n\tbufwasdelwri = (bp->b_flags & _XBF_DELWRI_Q);\n\tif (bufwasdelwri)\n\t\txfs_buf_relse(bp);\n\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\n\tif (!bufwasdelwri) {\n\t\t/*\n\t\t * Just like incore_relse: if we have b_iodone functions,\n\t\t * mark the buffer as an error and call them.  Otherwise\n\t\t * mark it as stale and brelse.\n\t\t */\n\t\tif (bp->b_iodone) {\n\t\t\tXFS_BUF_UNDONE(bp);\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\txfs_buf_ioend(bp);\n\t\t} else {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t}\n\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(iq, false);\n\tkmem_free(ilist);\n\txfs_perag_put(pag);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iflush_cluster(\n\txfs_inode_t\t*ip,\n\txfs_buf_t\t*bp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\tunsigned long\t\tfirst_index, mask;\n\tunsigned long\t\tinodes_per_cluster;\n\tint\t\t\tilist_size;\n\txfs_inode_t\t\t**ilist;\n\txfs_inode_t\t\t*iq;\n\tint\t\t\tnr_found;\n\tint\t\t\tclcount = 0;\n\tint\t\t\tbufwasdelwri;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\tinodes_per_cluster = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\tilist_size = inodes_per_cluster * sizeof(xfs_inode_t *);\n\tilist = kmem_alloc(ilist_size, KM_MAYFAIL|KM_NOFS);\n\tif (!ilist)\n\t\tgoto out_put;\n\n\tmask = ~(((mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino) & mask;\n\trcu_read_lock();\n\t/* really need a gang lookup range call here */\n\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root, (void**)ilist,\n\t\t\t\t\tfirst_index, inodes_per_cluster);\n\tif (nr_found == 0)\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_found; i++) {\n\t\tiq = ilist[i];\n\t\tif (iq == ip)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * because this is an RCU protected lookup, we could find a\n\t\t * recently freed or even reallocated inode during the lookup.\n\t\t * We need to check under the i_flags_lock for a valid inode\n\t\t * here. Skip it if it is not valid or the wrong inode.\n\t\t */\n\t\tspin_lock(&ip->i_flags_lock);\n\t\tif (!ip->i_ino ||\n\t\t    (XFS_INO_TO_AGINO(mp, iq->i_ino) & mask) != first_index) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Do an un-protected check to see if the inode is dirty and\n\t\t * is a candidate for flushing.  These checks will be repeated\n\t\t * later after the appropriate locks are acquired.\n\t\t */\n\t\tif (xfs_inode_clean(iq) && xfs_ipincount(iq) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Try to get locks.  If any are unavailable or it is pinned,\n\t\t * then this inode cannot be flushed and is skipped.\n\t\t */\n\n\t\tif (!xfs_ilock_nowait(iq, XFS_ILOCK_SHARED))\n\t\t\tcontinue;\n\t\tif (!xfs_iflock_nowait(iq)) {\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfs_ipincount(iq)) {\n\t\t\txfs_ifunlock(iq);\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * arriving here means that this inode can be flushed.  First\n\t\t * re-check that it's dirty before flushing.\n\t\t */\n\t\tif (!xfs_inode_clean(iq)) {\n\t\t\tint\terror;\n\t\t\terror = xfs_iflush_int(iq, bp);\n\t\t\tif (error) {\n\t\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\t\tgoto cluster_corrupt_out;\n\t\t\t}\n\t\t\tclcount++;\n\t\t} else {\n\t\t\txfs_ifunlock(iq);\n\t\t}\n\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t}\n\n\tif (clcount) {\n\t\tXFS_STATS_INC(xs_icluster_flushcnt);\n\t\tXFS_STATS_ADD(xs_icluster_flushinode, clcount);\n\t}\n\nout_free:\n\trcu_read_unlock();\n\tkmem_free(ilist);\nout_put:\n\txfs_perag_put(pag);\n\treturn 0;\n\n\ncluster_corrupt_out:\n\t/*\n\t * Corruption detected in the clustering loop.  Invalidate the\n\t * inode buffer and shut down the filesystem.\n\t */\n\trcu_read_unlock();\n\t/*\n\t * Clean up the buffer.  If it was delwri, just release it --\n\t * brelse can handle it with no problems.  If not, shut down the\n\t * filesystem before releasing the buffer.\n\t */\n\tbufwasdelwri = (bp->b_flags & _XBF_DELWRI_Q);\n\tif (bufwasdelwri)\n\t\txfs_buf_relse(bp);\n\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\n\tif (!bufwasdelwri) {\n\t\t/*\n\t\t * Just like incore_relse: if we have b_iodone functions,\n\t\t * mark the buffer as an error and call them.  Otherwise\n\t\t * mark it as stale and brelse.\n\t\t */\n\t\tif (bp->b_iodone) {\n\t\t\tXFS_BUF_UNDONE(bp);\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\txfs_buf_ioend(bp);\n\t\t} else {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t}\n\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(iq, false);\n\tkmem_free(ilist);\n\txfs_perag_put(pag);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "0"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ispinned",
          "args": [
            "bp"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ispinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "356-359",
          "snippet": "static inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush_int",
          "args": [
            "ip",
            "bp"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "3310-3466",
          "snippet": "STATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "ip"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_imap_to_bp",
          "args": [
            "mp",
            "NULL",
            "&ip->i_imap",
            "&dip",
            "&bp",
            "XBF_TRYLOCK",
            "0"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_to_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "156-191",
          "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_ISTALE"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunpin_wait",
          "args": [
            "ip"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunpin_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2439-2445",
          "snippet": "void\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK)"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isiflocked(ip)"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isiflocked",
          "args": [
            "ip"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isiflocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "252-255",
          "snippet": "static inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL|XFS_ILOCK_SHARED"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_iflush_count"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iflush(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_dinode\t*dip;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_iflush_count);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\n\t*bpp = NULL;\n\n\txfs_iunpin_wait(ip);\n\n\t/*\n\t * For stale inodes we cannot rely on the backing buffer remaining\n\t * stale in cache for the remaining life of the stale inode and so\n\t * xfs_imap_to_bp() below may give us a buffer that no longer contains\n\t * inodes below. We have to check this after ensuring the inode is\n\t * unpinned so that it is safe to reclaim the stale inode after the\n\t * flush call.\n\t */\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_ifunlock(ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this inode\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an empty AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto abort_out;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk inode.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &bp, XBF_TRYLOCK,\n\t\t\t       0);\n\tif (error || !bp) {\n\t\txfs_ifunlock(ip);\n\t\treturn error;\n\t}\n\n\t/*\n\t * First flush out the inode that xfs_iflush was called with.\n\t */\n\terror = xfs_iflush_int(ip, bp);\n\tif (error)\n\t\tgoto corrupt_out;\n\n\t/*\n\t * If the buffer is pinned then push on the log now so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp))\n\t\txfs_log_force(mp, 0);\n\n\t/*\n\t * inode clustering:\n\t * see if other inodes can be gathered into this write\n\t */\n\terror = xfs_iflush_cluster(ip, bp);\n\tif (error)\n\t\tgoto cluster_corrupt_out;\n\n\t*bpp = bp;\n\treturn 0;\n\ncorrupt_out:\n\txfs_buf_relse(bp);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\ncluster_corrupt_out:\n\terror = -EFSCORRUPTED;\nabort_out:\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(ip, false);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_iflush_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "3054-3204",
    "snippet": "STATIC int\nxfs_iflush_cluster(\n\txfs_inode_t\t*ip,\n\txfs_buf_t\t*bp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\tunsigned long\t\tfirst_index, mask;\n\tunsigned long\t\tinodes_per_cluster;\n\tint\t\t\tilist_size;\n\txfs_inode_t\t\t**ilist;\n\txfs_inode_t\t\t*iq;\n\tint\t\t\tnr_found;\n\tint\t\t\tclcount = 0;\n\tint\t\t\tbufwasdelwri;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\tinodes_per_cluster = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\tilist_size = inodes_per_cluster * sizeof(xfs_inode_t *);\n\tilist = kmem_alloc(ilist_size, KM_MAYFAIL|KM_NOFS);\n\tif (!ilist)\n\t\tgoto out_put;\n\n\tmask = ~(((mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino) & mask;\n\trcu_read_lock();\n\t/* really need a gang lookup range call here */\n\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root, (void**)ilist,\n\t\t\t\t\tfirst_index, inodes_per_cluster);\n\tif (nr_found == 0)\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_found; i++) {\n\t\tiq = ilist[i];\n\t\tif (iq == ip)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * because this is an RCU protected lookup, we could find a\n\t\t * recently freed or even reallocated inode during the lookup.\n\t\t * We need to check under the i_flags_lock for a valid inode\n\t\t * here. Skip it if it is not valid or the wrong inode.\n\t\t */\n\t\tspin_lock(&ip->i_flags_lock);\n\t\tif (!ip->i_ino ||\n\t\t    (XFS_INO_TO_AGINO(mp, iq->i_ino) & mask) != first_index) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Do an un-protected check to see if the inode is dirty and\n\t\t * is a candidate for flushing.  These checks will be repeated\n\t\t * later after the appropriate locks are acquired.\n\t\t */\n\t\tif (xfs_inode_clean(iq) && xfs_ipincount(iq) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Try to get locks.  If any are unavailable or it is pinned,\n\t\t * then this inode cannot be flushed and is skipped.\n\t\t */\n\n\t\tif (!xfs_ilock_nowait(iq, XFS_ILOCK_SHARED))\n\t\t\tcontinue;\n\t\tif (!xfs_iflock_nowait(iq)) {\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfs_ipincount(iq)) {\n\t\t\txfs_ifunlock(iq);\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * arriving here means that this inode can be flushed.  First\n\t\t * re-check that it's dirty before flushing.\n\t\t */\n\t\tif (!xfs_inode_clean(iq)) {\n\t\t\tint\terror;\n\t\t\terror = xfs_iflush_int(iq, bp);\n\t\t\tif (error) {\n\t\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\t\tgoto cluster_corrupt_out;\n\t\t\t}\n\t\t\tclcount++;\n\t\t} else {\n\t\t\txfs_ifunlock(iq);\n\t\t}\n\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t}\n\n\tif (clcount) {\n\t\tXFS_STATS_INC(xs_icluster_flushcnt);\n\t\tXFS_STATS_ADD(xs_icluster_flushinode, clcount);\n\t}\n\nout_free:\n\trcu_read_unlock();\n\tkmem_free(ilist);\nout_put:\n\txfs_perag_put(pag);\n\treturn 0;\n\n\ncluster_corrupt_out:\n\t/*\n\t * Corruption detected in the clustering loop.  Invalidate the\n\t * inode buffer and shut down the filesystem.\n\t */\n\trcu_read_unlock();\n\t/*\n\t * Clean up the buffer.  If it was delwri, just release it --\n\t * brelse can handle it with no problems.  If not, shut down the\n\t * filesystem before releasing the buffer.\n\t */\n\tbufwasdelwri = (bp->b_flags & _XBF_DELWRI_Q);\n\tif (bufwasdelwri)\n\t\txfs_buf_relse(bp);\n\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\n\tif (!bufwasdelwri) {\n\t\t/*\n\t\t * Just like incore_relse: if we have b_iodone functions,\n\t\t * mark the buffer as an error and call them.  Otherwise\n\t\t * mark it as stale and brelse.\n\t\t */\n\t\tif (bp->b_iodone) {\n\t\t\tXFS_BUF_UNDONE(bp);\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\txfs_buf_ioend(bp);\n\t\t} else {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t}\n\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(iq, false);\n\tkmem_free(ilist);\n\txfs_perag_put(pag);\n\treturn -EFSCORRUPTED;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ilist"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush_abort",
          "args": [
            "iq",
            "false"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "698-734",
          "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_UNDONE",
          "args": [
            "bp"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_icluster_flushinode",
            "clcount"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_icluster_flushcnt"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "iq",
            "XFS_ILOCK_SHARED"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "iq"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush_int",
          "args": [
            "iq",
            "bp"
          ],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "3310-3466",
          "snippet": "STATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_iflush_int(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_isiflocked(ip));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip != NULL && iip->ili_fields != 0);\n\tASSERT(ip->i_d.di_version > 1);\n\n\t/* set *dip = inode's place in the buffer */\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1, XFS_RANDOM_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu magic number 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_magic != XFS_DINODE_MAGIC,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_2, XFS_RANDOM_IFLUSH_2)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x\",\n\t\t\t__func__, ip->i_ino, ip, ip->i_d.di_magic);\n\t\tgoto corrupt_out;\n\t}\n\tif (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE),\n\t\t    mp, XFS_ERRTAG_IFLUSH_3, XFS_RANDOM_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t} else if (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL),\n\t\t    mp, XFS_ERRTAG_IFLUSH_4, XFS_RANDOM_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %Lu, ptr 0x%p\",\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto corrupt_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_nextents + ip->i_d.di_anextents >\n\t\t\t\tip->i_d.di_nblocks, mp, XFS_ERRTAG_IFLUSH_5,\n\t\t\t\tXFS_RANDOM_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %Lu, \"\n\t\t\t\"total extents = %d, nblocks = %Ld, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_d.di_nextents + ip->i_d.di_anextents,\n\t\t\tip->i_d.di_nblocks, ip);\n\t\tgoto corrupt_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6, XFS_RANDOM_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p\",\n\t\t\t__func__, ip->i_ino, ip->i_d.di_forkoff, ip);\n\t\tgoto corrupt_out;\n\t}\n\n\t/*\n\t * Inode item log recovery for v2 inodes are dependent on the\n\t * di_flushiter count for correct sequencing. We bump the flush\n\t * iteration count so we can detect flushes which postdate a log record\n\t * during recovery. This is redundant as we now log every change and\n\t * hence this can't happen but we need to still do it to ensure\n\t * backwards compatibility with old kernels that predate logging all\n\t * inode changes.\n\t */\n\tif (ip->i_d.di_version < 3)\n\t\tip->i_d.di_flushiter++;\n\n\t/*\n\t * Copy the dirty parts of the inode into the on-disk\n\t * inode.  We always copy out the core of the inode,\n\t * because if the inode is dirty at all the core must\n\t * be.\n\t */\n\txfs_dinode_to_disk(dip, &ip->i_d);\n\n\t/* Wrap, we never let the log put out DI_MAX_FLUSH */\n\tif (ip->i_d.di_flushiter == DI_MAX_FLUSH)\n\t\tip->i_d.di_flushiter = 0;\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (XFS_IFORK_Q(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * We've recorded everything logged in the inode, so we'd like to clear\n\t * the ili_fields bits so we don't log and flush things unnecessarily.\n\t * However, we can't stop logging all this information until the data\n\t * we've copied into the disk buffer is written to disk.  If we did we\n\t * might overwrite the copy of the inode in the log with all the data\n\t * after re-logging only part of it, and in the face of a crash we\n\t * wouldn't have all the data we need to recover.\n\t *\n\t * What we do is move the bits to the ili_last_fields field.  When\n\t * logging the inode, these bits are moved back to the ili_fields field.\n\t * In the xfs_iflush_done() routine we clear ili_last_fields, since we\n\t * know that the information those bits represent is permanently on\n\t * disk.  As long as the flush completes before the inode is logged\n\t * again, then both ili_fields and ili_last_fields will be cleared.\n\t *\n\t * We can play with the ili_fields bits here, because the inode lock\n\t * must be held exclusively in order to set bits there and the flush\n\t * lock protects the ili_last_fields bits.  Set ili_logged so the flush\n\t * done routine can tell whether or not to look in the AIL.  Also, store\n\t * the current LSN of the inode so that we can tell whether the item has\n\t * moved in the AIL from xfs_iflush_done().  In order to read the lsn we\n\t * need the AIL lock, because it is a 64 bit value that cannot be read\n\t * atomically.\n\t */\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_logged = 1;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t/*\n\t * Attach the function xfs_iflush_done to the inode's\n\t * buffer.  This will remove the inode from the AIL\n\t * and unlock the inode's flush lock when the inode is\n\t * completely written to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_iflush_done, &iip->ili_item);\n\n\t/* update the lsn in the on disk inode if required */\n\tif (ip->i_d.di_version == 3)\n\t\tdip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);\n\n\t/* generate the checksum. */\n\txfs_dinode_calc_crc(mp, dip);\n\n\tASSERT(bp->b_fspriv != NULL);\n\tASSERT(bp->b_iodone != NULL);\n\treturn 0;\n\ncorrupt_out:\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_clean",
          "args": [
            "iq"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.h",
          "lines": "39-42",
          "snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "iq"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflock_nowait",
          "args": [
            "iq"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "234-237",
          "snippet": "static inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "iq",
            "XFS_ILOCK_SHARED"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "iq"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "iq->i_ino"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&pag->pag_ici_root",
            "(void**)ilist",
            "first_index",
            "inodes_per_cluster"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "ilist_size",
            "KM_MAYFAIL|KM_NOFS"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, ip->i_ino)"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iflush_cluster(\n\txfs_inode_t\t*ip,\n\txfs_buf_t\t*bp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\tunsigned long\t\tfirst_index, mask;\n\tunsigned long\t\tinodes_per_cluster;\n\tint\t\t\tilist_size;\n\txfs_inode_t\t\t**ilist;\n\txfs_inode_t\t\t*iq;\n\tint\t\t\tnr_found;\n\tint\t\t\tclcount = 0;\n\tint\t\t\tbufwasdelwri;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\tinodes_per_cluster = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\tilist_size = inodes_per_cluster * sizeof(xfs_inode_t *);\n\tilist = kmem_alloc(ilist_size, KM_MAYFAIL|KM_NOFS);\n\tif (!ilist)\n\t\tgoto out_put;\n\n\tmask = ~(((mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino) & mask;\n\trcu_read_lock();\n\t/* really need a gang lookup range call here */\n\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root, (void**)ilist,\n\t\t\t\t\tfirst_index, inodes_per_cluster);\n\tif (nr_found == 0)\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_found; i++) {\n\t\tiq = ilist[i];\n\t\tif (iq == ip)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * because this is an RCU protected lookup, we could find a\n\t\t * recently freed or even reallocated inode during the lookup.\n\t\t * We need to check under the i_flags_lock for a valid inode\n\t\t * here. Skip it if it is not valid or the wrong inode.\n\t\t */\n\t\tspin_lock(&ip->i_flags_lock);\n\t\tif (!ip->i_ino ||\n\t\t    (XFS_INO_TO_AGINO(mp, iq->i_ino) & mask) != first_index) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Do an un-protected check to see if the inode is dirty and\n\t\t * is a candidate for flushing.  These checks will be repeated\n\t\t * later after the appropriate locks are acquired.\n\t\t */\n\t\tif (xfs_inode_clean(iq) && xfs_ipincount(iq) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Try to get locks.  If any are unavailable or it is pinned,\n\t\t * then this inode cannot be flushed and is skipped.\n\t\t */\n\n\t\tif (!xfs_ilock_nowait(iq, XFS_ILOCK_SHARED))\n\t\t\tcontinue;\n\t\tif (!xfs_iflock_nowait(iq)) {\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfs_ipincount(iq)) {\n\t\t\txfs_ifunlock(iq);\n\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * arriving here means that this inode can be flushed.  First\n\t\t * re-check that it's dirty before flushing.\n\t\t */\n\t\tif (!xfs_inode_clean(iq)) {\n\t\t\tint\terror;\n\t\t\terror = xfs_iflush_int(iq, bp);\n\t\t\tif (error) {\n\t\t\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t\t\t\tgoto cluster_corrupt_out;\n\t\t\t}\n\t\t\tclcount++;\n\t\t} else {\n\t\t\txfs_ifunlock(iq);\n\t\t}\n\t\txfs_iunlock(iq, XFS_ILOCK_SHARED);\n\t}\n\n\tif (clcount) {\n\t\tXFS_STATS_INC(xs_icluster_flushcnt);\n\t\tXFS_STATS_ADD(xs_icluster_flushinode, clcount);\n\t}\n\nout_free:\n\trcu_read_unlock();\n\tkmem_free(ilist);\nout_put:\n\txfs_perag_put(pag);\n\treturn 0;\n\n\ncluster_corrupt_out:\n\t/*\n\t * Corruption detected in the clustering loop.  Invalidate the\n\t * inode buffer and shut down the filesystem.\n\t */\n\trcu_read_unlock();\n\t/*\n\t * Clean up the buffer.  If it was delwri, just release it --\n\t * brelse can handle it with no problems.  If not, shut down the\n\t * filesystem before releasing the buffer.\n\t */\n\tbufwasdelwri = (bp->b_flags & _XBF_DELWRI_Q);\n\tif (bufwasdelwri)\n\t\txfs_buf_relse(bp);\n\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\n\tif (!bufwasdelwri) {\n\t\t/*\n\t\t * Just like incore_relse: if we have b_iodone functions,\n\t\t * mark the buffer as an error and call them.  Otherwise\n\t\t * mark it as stale and brelse.\n\t\t */\n\t\tif (bp->b_iodone) {\n\t\t\tXFS_BUF_UNDONE(bp);\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\txfs_buf_ioend(bp);\n\t\t} else {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t}\n\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(iq, false);\n\tkmem_free(ilist);\n\txfs_perag_put(pag);\n\treturn -EFSCORRUPTED;\n}"
  },
  {
    "function_name": "xfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2781-3052",
    "snippet": "int\nxfs_rename(\n\txfs_inode_t\t*src_dp,\n\tstruct xfs_name\t*src_name,\n\txfs_inode_t\t*src_ip,\n\txfs_inode_t\t*target_dp,\n\tstruct xfs_name\t*target_name,\n\txfs_inode_t\t*target_ip,\n\tunsigned int\tflags)\n{\n\txfs_trans_t\t*tp = NULL;\n\txfs_mount_t\t*mp = src_dp->i_mount;\n\tint\t\tnew_parent;\t\t/* moving to a new dir */\n\tint\t\tsrc_is_directory;\t/* src_name is a directory */\n\tint\t\terror;\n\txfs_bmap_free_t free_list;\n\txfs_fsblock_t   first_block;\n\tint\t\tcancel_flags;\n\tint\t\tcommitted;\n\txfs_inode_t\t*inodes[4];\n\tint\t\tspaceres;\n\tint\t\tnum_inodes;\n\n\ttrace_xfs_rename(src_dp, target_dp, src_name, target_name);\n\n\tnew_parent = (src_dp != target_dp);\n\tsrc_is_directory = S_ISDIR(src_ip->i_d.di_mode);\n\n\txfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,\n\t\t\t\tinodes, &num_inodes);\n\n\txfs_bmap_init(&free_list, &first_block);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);\n\tif (error == -ENOSPC) {\n\t\tspaceres = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Attach the dquots to the inodes\n\t */\n\terror = xfs_qm_vop_rename_dqattach(inodes);\n\tif (error) {\n\t\txfs_trans_cancel(tp, cancel_flags);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Lock all the participating inodes. Depending upon whether\n\t * the target_name exists in the target directory, and\n\t * whether the target directory is the same as the source\n\t * directory, we can lock from 2 to 4 inodes.\n\t */\n\txfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Join all the inodes to the transaction. From this point on,\n\t * we can rely on either trans_commit or trans_cancel to unlock\n\t * them.\n\t */\n\txfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\n\tif (new_parent)\n\t\txfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\n\tif (target_ip)\n\t\txfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow renames\n\t * into our tree when the project IDs are the same; else the\n\t * tree quota mechanism would be circumvented.\n\t */\n\tif (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Handle RENAME_EXCHANGE flags\n\t */\n\tif (flags & RENAME_EXCHANGE) {\n\t\tif (target_ip == NULL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto error_return;\n\t\t}\n\t\terror = xfs_cross_rename(tp, src_dp, src_name, src_ip,\n\t\t\t\t\t target_dp, target_name, target_ip,\n\t\t\t\t\t &free_list, &first_block, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t\tgoto finish_rename;\n\t}\n\n\t/*\n\t * Set up the target.\n\t */\n\tif (target_ip == NULL) {\n\t\t/*\n\t\t * If there's no space reservation, check the entry will\n\t\t * fit before actually inserting it.\n\t\t */\n\t\tif (!spaceres) {\n\t\t\terror = xfs_dir_canenter(tp, target_dp, target_name);\n\t\t\tif (error)\n\t\t\t\tgoto error_return;\n\t\t}\n\t\t/*\n\t\t * If target does not exist and the rename crosses\n\t\t * directories, adjust the target directory link count\n\t\t * to account for the \"..\" reference from the new entry.\n\t\t */\n\t\terror = xfs_dir_createname(tp, target_dp, target_name,\n\t\t\t\t\t\tsrc_ip->i_ino, &first_block,\n\t\t\t\t\t\t&free_list, spaceres);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\tif (new_parent && src_is_directory) {\n\t\t\terror = xfs_bumplink(tp, target_dp);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} else { /* target_ip != NULL */\n\t\t/*\n\t\t * If target exists and it's a directory, check that both\n\t\t * target and source are directories and that target can be\n\t\t * destroyed, or that neither is a directory.\n\t\t */\n\t\tif (S_ISDIR(target_ip->i_d.di_mode)) {\n\t\t\t/*\n\t\t\t * Make sure target dir is empty.\n\t\t\t */\n\t\t\tif (!(xfs_dir_isempty(target_ip)) ||\n\t\t\t    (target_ip->i_d.di_nlink > 2)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Link the source inode under the target name.\n\t\t * If the source inode is a directory and we are moving\n\t\t * it across directories, its \"..\" entry will be\n\t\t * inconsistent until we replace that down below.\n\t\t *\n\t\t * In case there is already an entry with the same\n\t\t * name at the destination directory, remove it first.\n\t\t */\n\t\terror = xfs_dir_replace(tp, target_dp, target_name,\n\t\t\t\t\tsrc_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\t/*\n\t\t * Decrement the link count on the target since the target\n\t\t * dir no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, target_ip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\tif (src_is_directory) {\n\t\t\t/*\n\t\t\t * Drop the link from the old \".\" entry.\n\t\t\t */\n\t\t\terror = xfs_droplink(tp, target_ip);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} /* target_ip != NULL */\n\n\t/*\n\t * Remove the source.\n\t */\n\tif (new_parent && src_is_directory) {\n\t\t/*\n\t\t * Rewrite the \"..\" entry to point to the new\n\t\t * directory.\n\t\t */\n\t\terror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\n\t\t\t\t\ttarget_dp->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tASSERT(error != -EEXIST);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\t/*\n\t * We always want to hit the ctime on the source inode.\n\t *\n\t * This isn't strictly required by the standards since the source\n\t * inode isn't really being changed, but old unix file systems did\n\t * it and some incremental backup programs won't work without it.\n\t */\n\txfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\n\n\t/*\n\t * Adjust the link count on src_dp.  This is necessary when\n\t * renaming a directory, either within one parent when\n\t * the target existed, or across two parent directories.\n\t */\n\tif (src_is_directory && (new_parent || target_ip != NULL)) {\n\n\t\t/*\n\t\t * Decrement link count on src_directory since the\n\t\t * entry that's moved no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, src_dp);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\tif (error)\n\t\tgoto abort_return;\n\n\txfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\n\tif (new_parent)\n\t\txfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\n\nfinish_rename:\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * rename transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t XFS_TRANS_ABORT));\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * trans_commit will unlock src_ip, target_ip & decrement\n\t * the vnode references.\n\t */\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "target_dp",
            "XFS_ILOG_CORE"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "src_dp",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_removename",
          "args": [
            "tp",
            "src_dp",
            "src_name",
            "src_ip->i_ino",
            "&first_block",
            "&free_list",
            "spaceres"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "429-486",
          "snippet": "int\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_droplink",
          "args": [
            "tp",
            "src_dp"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_droplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1016-1041",
          "snippet": "int\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -EEXIST"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_replace",
          "args": [
            "tp",
            "src_ip",
            "&xfs_name_dotdot",
            "target_dp->i_ino",
            "&first_block",
            "&free_list",
            "spaceres"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "491-551",
          "snippet": "int\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_isempty",
          "args": [
            "target_ip"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_isempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "173-186",
          "snippet": "int\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "target_ip->i_d.di_mode"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bumplink",
          "args": [
            "tp",
            "target_dp"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bumplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1046-1059",
          "snippet": "int\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_createname",
          "args": [
            "tp",
            "target_dp",
            "target_name",
            "src_ip->i_ino",
            "&first_block",
            "&free_list",
            "spaceres"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_createname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "255-321",
          "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_canenter",
          "args": [
            "tp",
            "target_dp",
            "target_name"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_canenter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "556-563",
          "snippet": "int\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cross_rename",
          "args": [
            "tp",
            "src_dp",
            "src_name",
            "src_ip",
            "target_dp",
            "target_name",
            "target_ip",
            "&free_list",
            "&first_block",
            "spaceres"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cross_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2665-2776",
          "snippet": "STATIC int\nxfs_cross_rename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp1,\n\tstruct xfs_name\t\t*name1,\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*dp2,\n\tstruct xfs_name\t\t*name2,\n\tstruct xfs_inode\t*ip2,\n\tstruct xfs_bmap_free\t*free_list,\n\txfs_fsblock_t\t\t*first_block,\n\tint\t\t\tspaceres)\n{\n\tint\t\terror = 0;\n\tint\t\tip1_flags = 0;\n\tint\t\tip2_flags = 0;\n\tint\t\tdp2_flags = 0;\n\n\t/* Swap inode number for dirent in first parent */\n\terror = xfs_dir_replace(tp, dp1, name1,\n\t\t\t\tip2->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/* Swap inode number for dirent in second parent */\n\terror = xfs_dir_replace(tp, dp2, name2,\n\t\t\t\tip1->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If we're renaming one or more directories across different parents,\n\t * update the respective \"..\" entries (and link counts) to match the new\n\t * parents.\n\t */\n\tif (dp1 != dp2) {\n\t\tdp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\n\t\tif (S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,\n\t\t\t\t\t\tdp1->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip2 \"..\" reference to dp1 */\n\t\t\tif (!S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip1 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t}\n\n\t\tif (S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,\n\t\t\t\t\t\tdp2->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip1 \"..\" reference to dp2 */\n\t\t\tif (!S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip2 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_CHG;\n\t\t}\n\t}\n\n\tif (ip1_flags) {\n\t\txfs_trans_ichgtime(tp, ip1, ip1_flags);\n\t\txfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);\n\t}\n\tif (ip2_flags) {\n\t\txfs_trans_ichgtime(tp, ip2, ip2_flags);\n\t\txfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);\n\t}\n\tif (dp2_flags) {\n\t\txfs_trans_ichgtime(tp, dp2, dp2_flags);\n\t\txfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_cross_rename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp1,\n\tstruct xfs_name\t\t*name1,\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*dp2,\n\tstruct xfs_name\t\t*name2,\n\tstruct xfs_inode\t*ip2,\n\tstruct xfs_bmap_free\t*free_list,\n\txfs_fsblock_t\t\t*first_block,\n\tint\t\t\tspaceres)\n{\n\tint\t\terror = 0;\n\tint\t\tip1_flags = 0;\n\tint\t\tip2_flags = 0;\n\tint\t\tdp2_flags = 0;\n\n\t/* Swap inode number for dirent in first parent */\n\terror = xfs_dir_replace(tp, dp1, name1,\n\t\t\t\tip2->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/* Swap inode number for dirent in second parent */\n\terror = xfs_dir_replace(tp, dp2, name2,\n\t\t\t\tip1->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If we're renaming one or more directories across different parents,\n\t * update the respective \"..\" entries (and link counts) to match the new\n\t * parents.\n\t */\n\tif (dp1 != dp2) {\n\t\tdp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\n\t\tif (S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,\n\t\t\t\t\t\tdp1->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip2 \"..\" reference to dp1 */\n\t\t\tif (!S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip1 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t}\n\n\t\tif (S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,\n\t\t\t\t\t\tdp2->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip1 \"..\" reference to dp2 */\n\t\t\tif (!S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip2 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_CHG;\n\t\t}\n\t}\n\n\tif (ip1_flags) {\n\t\txfs_trans_ichgtime(tp, ip1, ip1_flags);\n\t\txfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);\n\t}\n\tif (ip2_flags) {\n\t\txfs_trans_ichgtime(tp, ip2, ip2_flags);\n\t\txfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);\n\t}\n\tif (dp2_flags) {\n\t\txfs_trans_ichgtime(tp, dp2, dp2_flags);\n\t\txfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip))"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "src_ip"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "target_ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_lock_inodes",
          "args": [
            "inodes",
            "num_inodes",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "342-440",
          "snippet": "void\nxfs_lock_inodes(\n\txfs_inode_t\t**ips,\n\tint\t\tinodes,\n\tuint\t\tlock_mode)\n{\n\tint\t\tattempts = 0, i, j, try_lock;\n\txfs_log_item_t\t*lp;\n\n\tASSERT(ips && (inodes >= 2)); /* we need at least two */\n\n\ttry_lock = 0;\n\ti = 0;\n\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\n\t\tif (i && (ips[i] == ips[i-1]))\t/* Already locked */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If try_lock is not set yet, make sure all locked inodes\n\t\t * are not in the AIL.\n\t\t * If any are, set try_lock to be used later.\n\t\t */\n\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = (xfs_log_item_t *)ips[j]->i_itemp;\n\t\t\t\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\t\t\t\ttry_lock++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If any of the previous locks we have locked is in the AIL,\n\t\t * we must TRY to get the second and subsequent locks. If\n\t\t * we can't get any, we must release all we have\n\t\t * and try again.\n\t\t */\n\n\t\tif (try_lock) {\n\t\t\t/* try_lock must be 0 if i is 0. */\n\t\t\t/*\n\t\t\t * try_lock means we have an inode locked\n\t\t\t * that is in the AIL.\n\t\t\t */\n\t\t\tASSERT(i != 0);\n\t\t\tif (!xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i))) {\n\t\t\t\tattempts++;\n\n\t\t\t\t/*\n\t\t\t\t * Unlock all previous guys and try again.\n\t\t\t\t * xfs_iunlock will try to push the tail\n\t\t\t\t * if the inode is in the AIL.\n\t\t\t\t */\n\n\t\t\t\tfor(j = i - 1; j >= 0; j--) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check to see if we've already\n\t\t\t\t\t * unlocked this one.\n\t\t\t\t\t * Not the first one going back,\n\t\t\t\t\t * and the inode ptr is the same.\n\t\t\t\t\t */\n\t\t\t\t\tif ((j != (i - 1)) && ips[j] ==\n\t\t\t\t\t\t\t\tips[j+1])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t\t\t}\n\n\t\t\t\tif ((attempts % 5) == 0) {\n\t\t\t\t\tdelay(1); /* Don't just spin the CPU */\n#ifdef DEBUG\n\t\t\t\t\txfs_lock_delays++;\n#endif\n\t\t\t\t}\n\t\t\t\ti = 0;\n\t\t\t\ttry_lock = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tif (attempts) {\n\t\tif (attempts < 5) xfs_small_retries++;\n\t\telse if (attempts < 100) xfs_middle_retries++;\n\t\telse xfs_lots_retries++;\n\t} else {\n\t\txfs_locked_n++;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_inodes(\n\txfs_inode_t\t**ips,\n\tint\t\tinodes,\n\tuint\t\tlock_mode)\n{\n\tint\t\tattempts = 0, i, j, try_lock;\n\txfs_log_item_t\t*lp;\n\n\tASSERT(ips && (inodes >= 2)); /* we need at least two */\n\n\ttry_lock = 0;\n\ti = 0;\n\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\n\t\tif (i && (ips[i] == ips[i-1]))\t/* Already locked */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If try_lock is not set yet, make sure all locked inodes\n\t\t * are not in the AIL.\n\t\t * If any are, set try_lock to be used later.\n\t\t */\n\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = (xfs_log_item_t *)ips[j]->i_itemp;\n\t\t\t\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\t\t\t\ttry_lock++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If any of the previous locks we have locked is in the AIL,\n\t\t * we must TRY to get the second and subsequent locks. If\n\t\t * we can't get any, we must release all we have\n\t\t * and try again.\n\t\t */\n\n\t\tif (try_lock) {\n\t\t\t/* try_lock must be 0 if i is 0. */\n\t\t\t/*\n\t\t\t * try_lock means we have an inode locked\n\t\t\t * that is in the AIL.\n\t\t\t */\n\t\t\tASSERT(i != 0);\n\t\t\tif (!xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i))) {\n\t\t\t\tattempts++;\n\n\t\t\t\t/*\n\t\t\t\t * Unlock all previous guys and try again.\n\t\t\t\t * xfs_iunlock will try to push the tail\n\t\t\t\t * if the inode is in the AIL.\n\t\t\t\t */\n\n\t\t\t\tfor(j = i - 1; j >= 0; j--) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check to see if we've already\n\t\t\t\t\t * unlocked this one.\n\t\t\t\t\t * Not the first one going back,\n\t\t\t\t\t * and the inode ptr is the same.\n\t\t\t\t\t */\n\t\t\t\t\tif ((j != (i - 1)) && ips[j] ==\n\t\t\t\t\t\t\t\tips[j+1])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t\t\t}\n\n\t\t\t\tif ((attempts % 5) == 0) {\n\t\t\t\t\tdelay(1); /* Don't just spin the CPU */\n#ifdef DEBUG\n\t\t\t\t\txfs_lock_delays++;\n#endif\n\t\t\t\t}\n\t\t\t\ti = 0;\n\t\t\t\ttry_lock = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tif (attempts) {\n\t\tif (attempts < 5) xfs_small_retries++;\n\t\telse if (attempts < 100) xfs_middle_retries++;\n\t\telse xfs_lots_retries++;\n\t} else {\n\t\txfs_locked_n++;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_rename_dqattach",
          "args": [
            "inodes"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_rename_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1869-1895",
          "snippet": "int\nxfs_qm_vop_rename_dqattach(\n\tstruct xfs_inode\t**i_tab)\n{\n\tstruct xfs_mount\t*mp = i_tab[0]->i_mount;\n\tint\t\t\ti;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tfor (i = 0; (i < 4 && i_tab[i]); i++) {\n\t\tstruct xfs_inode\t*ip = i_tab[i];\n\t\tint\t\t\terror;\n\n\t\t/*\n\t\t * Watch out for duplicate entries in the table.\n\t\t */\n\t\tif (i == 0 || ip != i_tab[i-1]) {\n\t\t\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\t\t\terror = xfs_qm_dqattach(ip, 0);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_rename_dqattach(\n\tstruct xfs_inode\t**i_tab)\n{\n\tstruct xfs_mount\t*mp = i_tab[0]->i_mount;\n\tint\t\t\ti;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tfor (i = 0; (i < 4 && i_tab[i]); i++) {\n\t\tstruct xfs_inode\t*ip = i_tab[i];\n\t\tint\t\t\terror;\n\n\t\t/*\n\t\t * Watch out for duplicate entries in the table.\n\t\t */\n\t\tif (i == 0 || ip != i_tab[i-1]) {\n\t\t\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\t\t\terror = xfs_qm_dqattach(ip, 0);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_rename",
            "0",
            "0"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RENAME_SPACE_RES",
          "args": [
            "mp",
            "target_name->len"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_RENAME"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sort_for_rename",
          "args": [
            "src_dp",
            "target_dp",
            "src_ip",
            "target_ip",
            "inodes",
            "&num_inodes"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sort_for_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2614-2658",
          "snippet": "STATIC void\nxfs_sort_for_rename(\n\txfs_inode_t\t*dp1,\t/* in: old (source) directory inode */\n\txfs_inode_t\t*dp2,\t/* in: new (target) directory inode */\n\txfs_inode_t\t*ip1,\t/* in: inode of old entry */\n\txfs_inode_t\t*ip2,\t/* in: inode of new entry, if it\n\t\t\t\t   already exists, NULL otherwise. */\n\txfs_inode_t\t**i_tab,/* out: array of inode returned, sorted */\n\tint\t\t*num_inodes)  /* out: number of inodes in array */\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\ti, j;\n\n\t/*\n\t * i_tab contains a list of pointers to inodes.  We initialize\n\t * the table here & we'll sort it.  We will then use it to\n\t * order the acquisition of the inode locks.\n\t *\n\t * Note that the table may contain duplicates.  e.g., dp1 == dp2.\n\t */\n\ti_tab[0] = dp1;\n\ti_tab[1] = dp2;\n\ti_tab[2] = ip1;\n\tif (ip2) {\n\t\t*num_inodes = 4;\n\t\ti_tab[3] = ip2;\n\t} else {\n\t\t*num_inodes = 3;\n\t\ti_tab[3] = NULL;\n\t}\n\n\t/*\n\t * Sort the elements via bubble sort.  (Remember, there are at\n\t * most 4 elements to sort, so this is adequate.)\n\t */\n\tfor (i = 0; i < *num_inodes; i++) {\n\t\tfor (j = 1; j < *num_inodes; j++) {\n\t\t\tif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\n\t\t\t\ttemp = i_tab[j];\n\t\t\t\ti_tab[j] = i_tab[j-1];\n\t\t\t\ti_tab[j-1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC void\nxfs_sort_for_rename(\n\txfs_inode_t\t*dp1,\t/* in: old (source) directory inode */\n\txfs_inode_t\t*dp2,\t/* in: new (target) directory inode */\n\txfs_inode_t\t*ip1,\t/* in: inode of old entry */\n\txfs_inode_t\t*ip2,\t/* in: inode of new entry, if it\n\t\t\t\t   already exists, NULL otherwise. */\n\txfs_inode_t\t**i_tab,/* out: array of inode returned, sorted */\n\tint\t\t*num_inodes)  /* out: number of inodes in array */\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\ti, j;\n\n\t/*\n\t * i_tab contains a list of pointers to inodes.  We initialize\n\t * the table here & we'll sort it.  We will then use it to\n\t * order the acquisition of the inode locks.\n\t *\n\t * Note that the table may contain duplicates.  e.g., dp1 == dp2.\n\t */\n\ti_tab[0] = dp1;\n\ti_tab[1] = dp2;\n\ti_tab[2] = ip1;\n\tif (ip2) {\n\t\t*num_inodes = 4;\n\t\ti_tab[3] = ip2;\n\t} else {\n\t\t*num_inodes = 3;\n\t\ti_tab[3] = NULL;\n\t}\n\n\t/*\n\t * Sort the elements via bubble sort.  (Remember, there are at\n\t * most 4 elements to sort, so this is adequate.)\n\t */\n\tfor (i = 0; i < *num_inodes; i++) {\n\t\tfor (j = 1; j < *num_inodes; j++) {\n\t\t\tif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\n\t\t\t\ttemp = i_tab[j];\n\t\t\t\ti_tab[j] = i_tab[j-1];\n\t\t\t\ti_tab[j-1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "src_ip->i_d.di_mode"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_rename",
          "args": [
            "src_dp",
            "target_dp",
            "src_name",
            "target_name"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_rename(\n\txfs_inode_t\t*src_dp,\n\tstruct xfs_name\t*src_name,\n\txfs_inode_t\t*src_ip,\n\txfs_inode_t\t*target_dp,\n\tstruct xfs_name\t*target_name,\n\txfs_inode_t\t*target_ip,\n\tunsigned int\tflags)\n{\n\txfs_trans_t\t*tp = NULL;\n\txfs_mount_t\t*mp = src_dp->i_mount;\n\tint\t\tnew_parent;\t\t/* moving to a new dir */\n\tint\t\tsrc_is_directory;\t/* src_name is a directory */\n\tint\t\terror;\n\txfs_bmap_free_t free_list;\n\txfs_fsblock_t   first_block;\n\tint\t\tcancel_flags;\n\tint\t\tcommitted;\n\txfs_inode_t\t*inodes[4];\n\tint\t\tspaceres;\n\tint\t\tnum_inodes;\n\n\ttrace_xfs_rename(src_dp, target_dp, src_name, target_name);\n\n\tnew_parent = (src_dp != target_dp);\n\tsrc_is_directory = S_ISDIR(src_ip->i_d.di_mode);\n\n\txfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,\n\t\t\t\tinodes, &num_inodes);\n\n\txfs_bmap_init(&free_list, &first_block);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);\n\tif (error == -ENOSPC) {\n\t\tspaceres = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Attach the dquots to the inodes\n\t */\n\terror = xfs_qm_vop_rename_dqattach(inodes);\n\tif (error) {\n\t\txfs_trans_cancel(tp, cancel_flags);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Lock all the participating inodes. Depending upon whether\n\t * the target_name exists in the target directory, and\n\t * whether the target directory is the same as the source\n\t * directory, we can lock from 2 to 4 inodes.\n\t */\n\txfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Join all the inodes to the transaction. From this point on,\n\t * we can rely on either trans_commit or trans_cancel to unlock\n\t * them.\n\t */\n\txfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\n\tif (new_parent)\n\t\txfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\n\tif (target_ip)\n\t\txfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow renames\n\t * into our tree when the project IDs are the same; else the\n\t * tree quota mechanism would be circumvented.\n\t */\n\tif (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Handle RENAME_EXCHANGE flags\n\t */\n\tif (flags & RENAME_EXCHANGE) {\n\t\tif (target_ip == NULL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto error_return;\n\t\t}\n\t\terror = xfs_cross_rename(tp, src_dp, src_name, src_ip,\n\t\t\t\t\t target_dp, target_name, target_ip,\n\t\t\t\t\t &free_list, &first_block, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t\tgoto finish_rename;\n\t}\n\n\t/*\n\t * Set up the target.\n\t */\n\tif (target_ip == NULL) {\n\t\t/*\n\t\t * If there's no space reservation, check the entry will\n\t\t * fit before actually inserting it.\n\t\t */\n\t\tif (!spaceres) {\n\t\t\terror = xfs_dir_canenter(tp, target_dp, target_name);\n\t\t\tif (error)\n\t\t\t\tgoto error_return;\n\t\t}\n\t\t/*\n\t\t * If target does not exist and the rename crosses\n\t\t * directories, adjust the target directory link count\n\t\t * to account for the \"..\" reference from the new entry.\n\t\t */\n\t\terror = xfs_dir_createname(tp, target_dp, target_name,\n\t\t\t\t\t\tsrc_ip->i_ino, &first_block,\n\t\t\t\t\t\t&free_list, spaceres);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\tif (new_parent && src_is_directory) {\n\t\t\terror = xfs_bumplink(tp, target_dp);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} else { /* target_ip != NULL */\n\t\t/*\n\t\t * If target exists and it's a directory, check that both\n\t\t * target and source are directories and that target can be\n\t\t * destroyed, or that neither is a directory.\n\t\t */\n\t\tif (S_ISDIR(target_ip->i_d.di_mode)) {\n\t\t\t/*\n\t\t\t * Make sure target dir is empty.\n\t\t\t */\n\t\t\tif (!(xfs_dir_isempty(target_ip)) ||\n\t\t\t    (target_ip->i_d.di_nlink > 2)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Link the source inode under the target name.\n\t\t * If the source inode is a directory and we are moving\n\t\t * it across directories, its \"..\" entry will be\n\t\t * inconsistent until we replace that down below.\n\t\t *\n\t\t * In case there is already an entry with the same\n\t\t * name at the destination directory, remove it first.\n\t\t */\n\t\terror = xfs_dir_replace(tp, target_dp, target_name,\n\t\t\t\t\tsrc_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\t/*\n\t\t * Decrement the link count on the target since the target\n\t\t * dir no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, target_ip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\tif (src_is_directory) {\n\t\t\t/*\n\t\t\t * Drop the link from the old \".\" entry.\n\t\t\t */\n\t\t\terror = xfs_droplink(tp, target_ip);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} /* target_ip != NULL */\n\n\t/*\n\t * Remove the source.\n\t */\n\tif (new_parent && src_is_directory) {\n\t\t/*\n\t\t * Rewrite the \"..\" entry to point to the new\n\t\t * directory.\n\t\t */\n\t\terror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\n\t\t\t\t\ttarget_dp->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tASSERT(error != -EEXIST);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\t/*\n\t * We always want to hit the ctime on the source inode.\n\t *\n\t * This isn't strictly required by the standards since the source\n\t * inode isn't really being changed, but old unix file systems did\n\t * it and some incremental backup programs won't work without it.\n\t */\n\txfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\n\n\t/*\n\t * Adjust the link count on src_dp.  This is necessary when\n\t * renaming a directory, either within one parent when\n\t * the target existed, or across two parent directories.\n\t */\n\tif (src_is_directory && (new_parent || target_ip != NULL)) {\n\n\t\t/*\n\t\t * Decrement link count on src_directory since the\n\t\t * entry that's moved no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, src_dp);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\tif (error)\n\t\tgoto abort_return;\n\n\txfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\n\tif (new_parent)\n\t\txfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\n\nfinish_rename:\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * rename transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t XFS_TRANS_ABORT));\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * trans_commit will unlock src_ip, target_ip & decrement\n\t * the vnode references.\n\t */\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_cross_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2665-2776",
    "snippet": "STATIC int\nxfs_cross_rename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp1,\n\tstruct xfs_name\t\t*name1,\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*dp2,\n\tstruct xfs_name\t\t*name2,\n\tstruct xfs_inode\t*ip2,\n\tstruct xfs_bmap_free\t*free_list,\n\txfs_fsblock_t\t\t*first_block,\n\tint\t\t\tspaceres)\n{\n\tint\t\terror = 0;\n\tint\t\tip1_flags = 0;\n\tint\t\tip2_flags = 0;\n\tint\t\tdp2_flags = 0;\n\n\t/* Swap inode number for dirent in first parent */\n\terror = xfs_dir_replace(tp, dp1, name1,\n\t\t\t\tip2->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/* Swap inode number for dirent in second parent */\n\terror = xfs_dir_replace(tp, dp2, name2,\n\t\t\t\tip1->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If we're renaming one or more directories across different parents,\n\t * update the respective \"..\" entries (and link counts) to match the new\n\t * parents.\n\t */\n\tif (dp1 != dp2) {\n\t\tdp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\n\t\tif (S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,\n\t\t\t\t\t\tdp1->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip2 \"..\" reference to dp1 */\n\t\t\tif (!S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip1 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t}\n\n\t\tif (S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,\n\t\t\t\t\t\tdp2->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip1 \"..\" reference to dp2 */\n\t\t\tif (!S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip2 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_CHG;\n\t\t}\n\t}\n\n\tif (ip1_flags) {\n\t\txfs_trans_ichgtime(tp, ip1, ip1_flags);\n\t\txfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);\n\t}\n\tif (ip2_flags) {\n\t\txfs_trans_ichgtime(tp, ip2, ip2_flags);\n\t\txfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);\n\t}\n\tif (dp2_flags) {\n\t\txfs_trans_ichgtime(tp, dp2, dp2_flags);\n\t\txfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "dp1",
            "XFS_ILOG_CORE"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "dp1",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bumplink",
          "args": [
            "tp",
            "dp2"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bumplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1046-1059",
          "snippet": "int\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_droplink",
          "args": [
            "tp",
            "dp1"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_droplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1016-1041",
          "snippet": "int\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip2->i_d.di_mode"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_replace",
          "args": [
            "tp",
            "ip1",
            "&xfs_name_dotdot",
            "dp2->i_ino",
            "first_block",
            "free_list",
            "spaceres"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "491-551",
          "snippet": "int\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip1->i_d.di_mode"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip1->i_d.di_mode"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip2->i_d.di_mode"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_cross_rename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp1,\n\tstruct xfs_name\t\t*name1,\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*dp2,\n\tstruct xfs_name\t\t*name2,\n\tstruct xfs_inode\t*ip2,\n\tstruct xfs_bmap_free\t*free_list,\n\txfs_fsblock_t\t\t*first_block,\n\tint\t\t\tspaceres)\n{\n\tint\t\terror = 0;\n\tint\t\tip1_flags = 0;\n\tint\t\tip2_flags = 0;\n\tint\t\tdp2_flags = 0;\n\n\t/* Swap inode number for dirent in first parent */\n\terror = xfs_dir_replace(tp, dp1, name1,\n\t\t\t\tip2->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/* Swap inode number for dirent in second parent */\n\terror = xfs_dir_replace(tp, dp2, name2,\n\t\t\t\tip1->i_ino,\n\t\t\t\tfirst_block, free_list, spaceres);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If we're renaming one or more directories across different parents,\n\t * update the respective \"..\" entries (and link counts) to match the new\n\t * parents.\n\t */\n\tif (dp1 != dp2) {\n\t\tdp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\n\t\tif (S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,\n\t\t\t\t\t\tdp1->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip2 \"..\" reference to dp1 */\n\t\t\tif (!S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip1 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t}\n\n\t\tif (S_ISDIR(ip1->i_d.di_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,\n\t\t\t\t\t\tdp2->i_ino, first_block,\n\t\t\t\t\t\tfree_list, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t/* transfer ip1 \"..\" reference to dp2 */\n\t\t\tif (!S_ISDIR(ip2->i_d.di_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\terror = xfs_bumplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Although ip2 isn't changed here, userspace needs\n\t\t\t * to be warned about the change, so that applications\n\t\t\t * relying on it (like backup ones), will properly\n\t\t\t * notify the change\n\t\t\t */\n\t\t\tip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_CHG;\n\t\t}\n\t}\n\n\tif (ip1_flags) {\n\t\txfs_trans_ichgtime(tp, ip1, ip1_flags);\n\t\txfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);\n\t}\n\tif (ip2_flags) {\n\t\txfs_trans_ichgtime(tp, ip2, ip2_flags);\n\t\txfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);\n\t}\n\tif (dp2_flags) {\n\t\txfs_trans_ichgtime(tp, dp2, dp2_flags);\n\t\txfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_sort_for_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2614-2658",
    "snippet": "STATIC void\nxfs_sort_for_rename(\n\txfs_inode_t\t*dp1,\t/* in: old (source) directory inode */\n\txfs_inode_t\t*dp2,\t/* in: new (target) directory inode */\n\txfs_inode_t\t*ip1,\t/* in: inode of old entry */\n\txfs_inode_t\t*ip2,\t/* in: inode of new entry, if it\n\t\t\t\t   already exists, NULL otherwise. */\n\txfs_inode_t\t**i_tab,/* out: array of inode returned, sorted */\n\tint\t\t*num_inodes)  /* out: number of inodes in array */\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\ti, j;\n\n\t/*\n\t * i_tab contains a list of pointers to inodes.  We initialize\n\t * the table here & we'll sort it.  We will then use it to\n\t * order the acquisition of the inode locks.\n\t *\n\t * Note that the table may contain duplicates.  e.g., dp1 == dp2.\n\t */\n\ti_tab[0] = dp1;\n\ti_tab[1] = dp2;\n\ti_tab[2] = ip1;\n\tif (ip2) {\n\t\t*num_inodes = 4;\n\t\ti_tab[3] = ip2;\n\t} else {\n\t\t*num_inodes = 3;\n\t\ti_tab[3] = NULL;\n\t}\n\n\t/*\n\t * Sort the elements via bubble sort.  (Remember, there are at\n\t * most 4 elements to sort, so this is adequate.)\n\t */\n\tfor (i = 0; i < *num_inodes; i++) {\n\t\tfor (j = 1; j < *num_inodes; j++) {\n\t\t\tif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\n\t\t\t\ttemp = i_tab[j];\n\t\t\t\ti_tab[j] = i_tab[j-1];\n\t\t\t\ti_tab[j-1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC void\nxfs_sort_for_rename(\n\txfs_inode_t\t*dp1,\t/* in: old (source) directory inode */\n\txfs_inode_t\t*dp2,\t/* in: new (target) directory inode */\n\txfs_inode_t\t*ip1,\t/* in: inode of old entry */\n\txfs_inode_t\t*ip2,\t/* in: inode of new entry, if it\n\t\t\t\t   already exists, NULL otherwise. */\n\txfs_inode_t\t**i_tab,/* out: array of inode returned, sorted */\n\tint\t\t*num_inodes)  /* out: number of inodes in array */\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\ti, j;\n\n\t/*\n\t * i_tab contains a list of pointers to inodes.  We initialize\n\t * the table here & we'll sort it.  We will then use it to\n\t * order the acquisition of the inode locks.\n\t *\n\t * Note that the table may contain duplicates.  e.g., dp1 == dp2.\n\t */\n\ti_tab[0] = dp1;\n\ti_tab[1] = dp2;\n\ti_tab[2] = ip1;\n\tif (ip2) {\n\t\t*num_inodes = 4;\n\t\ti_tab[3] = ip2;\n\t} else {\n\t\t*num_inodes = 3;\n\t\ti_tab[3] = NULL;\n\t}\n\n\t/*\n\t * Sort the elements via bubble sort.  (Remember, there are at\n\t * most 4 elements to sort, so this is adequate.)\n\t */\n\tfor (i = 0; i < *num_inodes; i++) {\n\t\tfor (j = 1; j < *num_inodes; j++) {\n\t\t\tif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\n\t\t\t\ttemp = i_tab[j];\n\t\t\t\ti_tab[j] = i_tab[j-1];\n\t\t\t\ti_tab[j-1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2474-2609",
    "snippet": "int\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_deassociate",
          "args": [
            "ip"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_deassociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "404-409",
          "snippet": "void\nxfs_filestream_deassociate(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_mru_cache_delete(ip->i_mount->m_filestream, ip->i_ino);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_filestream_deassociate(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_mru_cache_delete(ip->i_mount->m_filestream, ip->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_is_filestream",
          "args": [
            "ip"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_is_filestream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.h",
          "lines": "32-38",
          "snippet": "static inline int\nxfs_inode_is_filestream(\n\tstruct xfs_inode\t*ip)\n{\n\treturn (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||\n\t\t(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_inode_is_filestream(\n\tstruct xfs_inode\t*ip)\n{\n\treturn (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||\n\t\t(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_removename",
          "args": [
            "tp",
            "dp",
            "name",
            "ip->i_ino",
            "&first_block",
            "&free_list",
            "resblks"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "429-486",
          "snippet": "int\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_droplink",
          "args": [
            "tp",
            "ip"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_droplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1016-1041",
          "snippet": "int\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "dp",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_isempty",
          "args": [
            "ip"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_isempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "173-186",
          "snippet": "int\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink >= 2"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_lock_two_inodes",
          "args": [
            "dp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_two_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "448-487",
          "snippet": "void\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_remove",
            "0",
            "0"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_REMOVE_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_REMOVE"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_remove",
          "args": [
            "dp",
            "name"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_iunpin_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2439-2445",
    "snippet": "void\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_iunpin_wait",
          "args": [
            "ip"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iunpin_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2422-2437",
          "snippet": "static void\n__xfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IPINNED_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IPINNED_BIT);\n\n\txfs_iunpin(ip);\n\n\tdo {\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_ipincount(ip))\n\t\t\tio_schedule();\n\t} while (xfs_ipincount(ip));\n\tfinish_wait(wq, &wait.wait);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic void\n__xfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IPINNED_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IPINNED_BIT);\n\n\txfs_iunpin(ip);\n\n\tdo {\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_ipincount(ip))\n\t\t\tio_schedule();\n\t} while (xfs_ipincount(ip));\n\tfinish_wait(wq, &wait.wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}"
  },
  {
    "function_name": "__xfs_iunpin_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2422-2437",
    "snippet": "static void\n__xfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IPINNED_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IPINNED_BIT);\n\n\txfs_iunpin(ip);\n\n\tdo {\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_ipincount(ip))\n\t\t\tio_schedule();\n\t} while (xfs_ipincount(ip));\n\tfinish_wait(wq, &wait.wait);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait.wait"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunpin",
          "args": [
            "ip"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunpin_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2439-2445",
          "snippet": "void\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&ip->i_flags",
            "__XFS_IPINNED_BIT"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&ip->i_flags",
            "__XFS_IPINNED_BIT"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic void\n__xfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IPINNED_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IPINNED_BIT);\n\n\txfs_iunpin(ip);\n\n\tdo {\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_ipincount(ip))\n\t\t\tio_schedule();\n\t} while (xfs_ipincount(ip));\n\tfinish_wait(wq, &wait.wait);\n}"
  },
  {
    "function_name": "xfs_iunpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2409-2420",
    "snippet": "static void\nxfs_iunpin(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\n\ttrace_xfs_inode_unpin_nowait(ip, _RET_IP_);\n\n\t/* Give the log a push to start the unpinning I/O */\n\txfs_log_force_lsn(ip->i_mount, ip->i_itemp->ili_last_lsn, 0);\n\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_force_lsn",
          "args": [
            "ip->i_mount",
            "ip->i_itemp->ili_last_lsn",
            "0"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3452-3464",
          "snippet": "void\nxfs_log_force_lsn(\n\txfs_mount_t\t*mp,\n\txfs_lsn_t\tlsn,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, lsn);\n\terror = _xfs_log_force_lsn(mp, lsn, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_force_lsn(\n\txfs_mount_t\t*mp,\n\txfs_lsn_t\tlsn,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, lsn);\n\terror = _xfs_log_force_lsn(mp, lsn, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_unpin_nowait",
          "args": [
            "ip",
            "_RET_IP_"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL|XFS_ILOCK_SHARED"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic void\nxfs_iunpin(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\n\ttrace_xfs_inode_unpin_nowait(ip, _RET_IP_);\n\n\t/* Give the log a push to start the unpinning I/O */\n\txfs_log_force_lsn(ip->i_mount, ip->i_itemp->ili_last_lsn, 0);\n\n}"
  },
  {
    "function_name": "xfs_ifree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2357-2402",
    "snippet": "int\nxfs_ifree(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_bmap_free_t\t*flist)\n{\n\tint\t\t\terror;\n\tint\t\t\tdelete;\n\txfs_ino_t\t\tfirst_ino;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_nextents == 0);\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_d.di_size == 0 || !S_ISREG(ip->i_d.di_mode));\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\t/*\n\t * Pull the on-disk inode from the AGI unlinked list.\n\t */\n\terror = xfs_iunlink_remove(tp, ip);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_difree(tp, ip->i_ino, flist, &delete, &first_ino);\n\tif (error)\n\t\treturn error;\n\n\tip->i_d.di_mode = 0;\t\t/* mark incore inode as free */\n\tip->i_d.di_flags = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_forkoff = 0;\t\t/* mark the attr fork not in use */\n\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t/*\n\t * Bump the generation count so no one will be confused\n\t * by reincarnations of this inode.\n\t */\n\tip->i_d.di_gen++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (delete)\n\t\terror = xfs_ifree_cluster(ip, tp, first_ino);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ifree_cluster",
          "args": [
            "ip",
            "tp",
            "first_ino"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifree_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2183-2345",
          "snippet": "STATIC int\nxfs_ifree_cluster(\n\txfs_inode_t\t*free_ip,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tinum)\n{\n\txfs_mount_t\t\t*mp = free_ip->i_mount;\n\tint\t\t\tblks_per_cluster;\n\tint\t\t\tinodes_per_cluster;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\tblkno;\n\txfs_buf_t\t\t*bp;\n\txfs_inode_t\t\t*ip;\n\txfs_inode_log_item_t\t*iip;\n\txfs_log_item_t\t\t*lip;\n\tstruct xfs_perag\t*pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = mp->m_ialloc_blks / blks_per_cluster;\n\n\tfor (j = 0; j < nbufs; j++, inum += inodes_per_cluster) {\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\n\t\t/*\n\t\t * We obtain and lock the backing buffer first in the process\n\t\t * here, as we have to ensure that any dirty inode that we\n\t\t * can't get the flush lock on is attached to the buffer.\n\t\t * If we scan the in-memory inodes first, then buffer IO can\n\t\t * complete before we get a lock on it, and hence we may fail\n\t\t * to mark all the active inodes on the buffer stale.\n\t\t */\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\t\tmp->m_bsize * blks_per_cluster,\n\t\t\t\t\tXBF_UNMAPPED);\n\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * This buffer may not have been correctly initialised as we\n\t\t * didn't read it from disk. That's not important because we are\n\t\t * only using to mark the buffer as stale in the log, and to\n\t\t * attach stale cached inodes on it. That means it will never be\n\t\t * dispatched for IO. If it is, we want to know about it, and we\n\t\t * want it to fail. We can acheive this by adding a write\n\t\t * verifier to the buffer.\n\t\t */\n\t\t bp->b_ops = &xfs_inode_buf_ops;\n\n\t\t/*\n\t\t * Walk the inodes already attached to the buffer and mark them\n\t\t * stale. These will all have the flush locks held, so an\n\t\t * in-memory inode walk can't lock them. By marking them all\n\t\t * stale first, we will not attempt to lock them in the loop\n\t\t * below as the XFS_ISTALE flag will be set.\n\t\t */\n\t\tlip = bp->b_fspriv;\n\t\twhile (lip) {\n\t\t\tif (lip->li_type == XFS_LI_INODE) {\n\t\t\t\tiip = (xfs_inode_log_item_t *)lip;\n\t\t\t\tASSERT(iip->ili_logged == 1);\n\t\t\t\tlip->li_cb = xfs_istale_done;\n\t\t\t\txfs_trans_ail_copy_lsn(mp->m_ail,\n\t\t\t\t\t\t\t&iip->ili_flush_lsn,\n\t\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\t\t\t\txfs_iflags_set(iip->ili_inode, XFS_ISTALE);\n\t\t\t}\n\t\t\tlip = lip->li_bio_list;\n\t\t}\n\n\n\t\t/*\n\t\t * For each inode in memory attempt to add it to the inode\n\t\t * buffer and set it up for being staled on buffer IO\n\t\t * completion.  This is safe as we've locked out tail pushing\n\t\t * and flushing by locking the buffer.\n\t\t *\n\t\t * We have already marked every inode that was part of a\n\t\t * transaction stale above, which means there is no point in\n\t\t * even trying to lock them.\n\t\t */\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\nretry:\n\t\t\trcu_read_lock();\n\t\t\tip = radix_tree_lookup(&pag->pag_ici_root,\n\t\t\t\t\tXFS_INO_TO_AGINO(mp, (inum + i)));\n\n\t\t\t/* Inode not in memory, nothing to do */\n\t\t\tif (!ip) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * because this is an RCU protected lookup, we could\n\t\t\t * find a recently freed or even reallocated inode\n\t\t\t * during the lookup. We need to check under the\n\t\t\t * i_flags_lock for a valid inode here. Skip it if it\n\t\t\t * is not valid, the wrong inode or stale.\n\t\t\t */\n\t\t\tspin_lock(&ip->i_flags_lock);\n\t\t\tif (ip->i_ino != inum + i ||\n\t\t\t    __xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t\t/*\n\t\t\t * Don't try to lock/unlock the current inode, but we\n\t\t\t * _cannot_ skip the other inodes that we did not find\n\t\t\t * in the list attached to the buffer and are not\n\t\t\t * already marked stale. If we can't lock it, back off\n\t\t\t * and retry.\n\t\t\t */\n\t\t\tif (ip != free_ip &&\n\t\t\t    !xfs_ilock_nowait(ip, XFS_ILOCK_EXCL)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tdelay(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\txfs_iflock(ip);\n\t\t\txfs_iflags_set(ip, XFS_ISTALE);\n\n\t\t\t/*\n\t\t\t * we don't need to attach clean inodes or those only\n\t\t\t * with unlogged changes (which we throw away, anyway).\n\t\t\t */\n\t\t\tiip = ip->i_itemp;\n\t\t\tif (!iip || xfs_inode_clean(ip)) {\n\t\t\t\tASSERT(ip != free_ip);\n\t\t\t\txfs_ifunlock(ip);\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tiip->ili_last_fields = iip->ili_fields;\n\t\t\tiip->ili_fields = 0;\n\t\t\tiip->ili_logged = 1;\n\t\t\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\n\t\t\txfs_buf_attach_iodone(bp, xfs_istale_done,\n\t\t\t\t\t\t  &iip->ili_item);\n\n\t\t\tif (ip != free_ip)\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_ifree_cluster(\n\txfs_inode_t\t*free_ip,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tinum)\n{\n\txfs_mount_t\t\t*mp = free_ip->i_mount;\n\tint\t\t\tblks_per_cluster;\n\tint\t\t\tinodes_per_cluster;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\tblkno;\n\txfs_buf_t\t\t*bp;\n\txfs_inode_t\t\t*ip;\n\txfs_inode_log_item_t\t*iip;\n\txfs_log_item_t\t\t*lip;\n\tstruct xfs_perag\t*pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = mp->m_ialloc_blks / blks_per_cluster;\n\n\tfor (j = 0; j < nbufs; j++, inum += inodes_per_cluster) {\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\n\t\t/*\n\t\t * We obtain and lock the backing buffer first in the process\n\t\t * here, as we have to ensure that any dirty inode that we\n\t\t * can't get the flush lock on is attached to the buffer.\n\t\t * If we scan the in-memory inodes first, then buffer IO can\n\t\t * complete before we get a lock on it, and hence we may fail\n\t\t * to mark all the active inodes on the buffer stale.\n\t\t */\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\t\tmp->m_bsize * blks_per_cluster,\n\t\t\t\t\tXBF_UNMAPPED);\n\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * This buffer may not have been correctly initialised as we\n\t\t * didn't read it from disk. That's not important because we are\n\t\t * only using to mark the buffer as stale in the log, and to\n\t\t * attach stale cached inodes on it. That means it will never be\n\t\t * dispatched for IO. If it is, we want to know about it, and we\n\t\t * want it to fail. We can acheive this by adding a write\n\t\t * verifier to the buffer.\n\t\t */\n\t\t bp->b_ops = &xfs_inode_buf_ops;\n\n\t\t/*\n\t\t * Walk the inodes already attached to the buffer and mark them\n\t\t * stale. These will all have the flush locks held, so an\n\t\t * in-memory inode walk can't lock them. By marking them all\n\t\t * stale first, we will not attempt to lock them in the loop\n\t\t * below as the XFS_ISTALE flag will be set.\n\t\t */\n\t\tlip = bp->b_fspriv;\n\t\twhile (lip) {\n\t\t\tif (lip->li_type == XFS_LI_INODE) {\n\t\t\t\tiip = (xfs_inode_log_item_t *)lip;\n\t\t\t\tASSERT(iip->ili_logged == 1);\n\t\t\t\tlip->li_cb = xfs_istale_done;\n\t\t\t\txfs_trans_ail_copy_lsn(mp->m_ail,\n\t\t\t\t\t\t\t&iip->ili_flush_lsn,\n\t\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\t\t\t\txfs_iflags_set(iip->ili_inode, XFS_ISTALE);\n\t\t\t}\n\t\t\tlip = lip->li_bio_list;\n\t\t}\n\n\n\t\t/*\n\t\t * For each inode in memory attempt to add it to the inode\n\t\t * buffer and set it up for being staled on buffer IO\n\t\t * completion.  This is safe as we've locked out tail pushing\n\t\t * and flushing by locking the buffer.\n\t\t *\n\t\t * We have already marked every inode that was part of a\n\t\t * transaction stale above, which means there is no point in\n\t\t * even trying to lock them.\n\t\t */\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\nretry:\n\t\t\trcu_read_lock();\n\t\t\tip = radix_tree_lookup(&pag->pag_ici_root,\n\t\t\t\t\tXFS_INO_TO_AGINO(mp, (inum + i)));\n\n\t\t\t/* Inode not in memory, nothing to do */\n\t\t\tif (!ip) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * because this is an RCU protected lookup, we could\n\t\t\t * find a recently freed or even reallocated inode\n\t\t\t * during the lookup. We need to check under the\n\t\t\t * i_flags_lock for a valid inode here. Skip it if it\n\t\t\t * is not valid, the wrong inode or stale.\n\t\t\t */\n\t\t\tspin_lock(&ip->i_flags_lock);\n\t\t\tif (ip->i_ino != inum + i ||\n\t\t\t    __xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t\t/*\n\t\t\t * Don't try to lock/unlock the current inode, but we\n\t\t\t * _cannot_ skip the other inodes that we did not find\n\t\t\t * in the list attached to the buffer and are not\n\t\t\t * already marked stale. If we can't lock it, back off\n\t\t\t * and retry.\n\t\t\t */\n\t\t\tif (ip != free_ip &&\n\t\t\t    !xfs_ilock_nowait(ip, XFS_ILOCK_EXCL)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tdelay(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\txfs_iflock(ip);\n\t\t\txfs_iflags_set(ip, XFS_ISTALE);\n\n\t\t\t/*\n\t\t\t * we don't need to attach clean inodes or those only\n\t\t\t * with unlogged changes (which we throw away, anyway).\n\t\t\t */\n\t\t\tiip = ip->i_itemp;\n\t\t\tif (!iip || xfs_inode_clean(ip)) {\n\t\t\t\tASSERT(ip != free_ip);\n\t\t\t\txfs_ifunlock(ip);\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tiip->ili_last_fields = iip->ili_fields;\n\t\t\tiip->ili_fields = 0;\n\t\t\tiip->ili_logged = 1;\n\t\t\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\n\t\t\txfs_buf_attach_iodone(bp, xfs_istale_done,\n\t\t\t\t\t\t  &iip->ili_item);\n\n\t\t\tif (ip != free_ip)\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_difree",
          "args": [
            "tp",
            "ip->i_ino",
            "flist",
            "&delete",
            "&first_ino"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_difree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1664-1739",
          "snippet": "int\nxfs_difree(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\t\tinode,\t\t/* inode to be freed */\n\tstruct xfs_bmap_free\t*flist,\t\t/* extents to free */\n\tint\t\t\t*deleted,/* set if inode cluster was deleted */\n\txfs_ino_t\t\t*first_ino)/* first inode in deleted cluster */\n{\n\t/* REFERENCED */\n\txfs_agblock_t\t\tagbno;\t/* block number containing inode */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for allocation group header */\n\txfs_agino_t\t\tagino;\t/* allocation group inode number */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_mount\t*mp;\t/* mount structure for filesystem */\n\tstruct xfs_inobt_rec_incore rec;/* btree record */\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Break up inode number into its components.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, inode);\n\tif (agno >= mp->m_sb.sb_agcount)  {\n\t\txfs_warn(mp, \"%s: agno >= mp->m_sb.sb_agcount (%d >= %d).\",\n\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagino = XFS_INO_TO_AGINO(mp, inode);\n\tif (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {\n\t\txfs_warn(mp, \"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\",\n\t\t\t__func__, (unsigned long long)inode,\n\t\t\t(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks)  {\n\t\txfs_warn(mp, \"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\",\n\t\t\t__func__, agbno, mp->m_sb.sb_agblocks);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Get the allocation group header.\n\t */\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_ialloc_read_agi() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Fix up the inode allocation btree.\n\t */\n\terror = xfs_difree_inobt(mp, tp, agbp, agino, flist, deleted, first_ino,\n\t\t\t\t &rec);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Fix up the free inode btree.\n\t */\n\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\terror = xfs_difree_finobt(mp, tp, agbp, agino, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\treturn 0;\n\nerror0:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_difree(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_ino_t\t\tinode,\t\t/* inode to be freed */\n\tstruct xfs_bmap_free\t*flist,\t\t/* extents to free */\n\tint\t\t\t*deleted,/* set if inode cluster was deleted */\n\txfs_ino_t\t\t*first_ino)/* first inode in deleted cluster */\n{\n\t/* REFERENCED */\n\txfs_agblock_t\t\tagbno;\t/* block number containing inode */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for allocation group header */\n\txfs_agino_t\t\tagino;\t/* allocation group inode number */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_mount\t*mp;\t/* mount structure for filesystem */\n\tstruct xfs_inobt_rec_incore rec;/* btree record */\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Break up inode number into its components.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, inode);\n\tif (agno >= mp->m_sb.sb_agcount)  {\n\t\txfs_warn(mp, \"%s: agno >= mp->m_sb.sb_agcount (%d >= %d).\",\n\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagino = XFS_INO_TO_AGINO(mp, inode);\n\tif (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {\n\t\txfs_warn(mp, \"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\",\n\t\t\t__func__, (unsigned long long)inode,\n\t\t\t(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks)  {\n\t\txfs_warn(mp, \"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\",\n\t\t\t__func__, agbno, mp->m_sb.sb_agblocks);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Get the allocation group header.\n\t */\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_ialloc_read_agi() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Fix up the inode allocation btree.\n\t */\n\terror = xfs_difree_inobt(mp, tp, agbp, agino, flist, deleted, first_ino,\n\t\t\t\t &rec);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * Fix up the free inode btree.\n\t */\n\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\terror = xfs_difree_finobt(mp, tp, agbp, agino, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\treturn 0;\n\nerror0:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlink_remove",
          "args": [
            "tp",
            "ip"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlink_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2007-2176",
          "snippet": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nblocks == 0"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_size == 0 || !S_ISREG(ip->i_d.di_mode)"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_anextents == 0"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nextents == 0"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink == 0"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ifree(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_bmap_free_t\t*flist)\n{\n\tint\t\t\terror;\n\tint\t\t\tdelete;\n\txfs_ino_t\t\tfirst_ino;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_nextents == 0);\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_d.di_size == 0 || !S_ISREG(ip->i_d.di_mode));\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\t/*\n\t * Pull the on-disk inode from the AGI unlinked list.\n\t */\n\terror = xfs_iunlink_remove(tp, ip);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_difree(tp, ip->i_ino, flist, &delete, &first_ino);\n\tif (error)\n\t\treturn error;\n\n\tip->i_d.di_mode = 0;\t\t/* mark incore inode as free */\n\tip->i_d.di_flags = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_forkoff = 0;\t\t/* mark the attr fork not in use */\n\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t/*\n\t * Bump the generation count so no one will be confused\n\t * by reincarnations of this inode.\n\t */\n\tip->i_d.di_gen++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (delete)\n\t\terror = xfs_ifree_cluster(ip, tp, first_ino);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_ifree_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2183-2345",
    "snippet": "STATIC int\nxfs_ifree_cluster(\n\txfs_inode_t\t*free_ip,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tinum)\n{\n\txfs_mount_t\t\t*mp = free_ip->i_mount;\n\tint\t\t\tblks_per_cluster;\n\tint\t\t\tinodes_per_cluster;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\tblkno;\n\txfs_buf_t\t\t*bp;\n\txfs_inode_t\t\t*ip;\n\txfs_inode_log_item_t\t*iip;\n\txfs_log_item_t\t\t*lip;\n\tstruct xfs_perag\t*pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = mp->m_ialloc_blks / blks_per_cluster;\n\n\tfor (j = 0; j < nbufs; j++, inum += inodes_per_cluster) {\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\n\t\t/*\n\t\t * We obtain and lock the backing buffer first in the process\n\t\t * here, as we have to ensure that any dirty inode that we\n\t\t * can't get the flush lock on is attached to the buffer.\n\t\t * If we scan the in-memory inodes first, then buffer IO can\n\t\t * complete before we get a lock on it, and hence we may fail\n\t\t * to mark all the active inodes on the buffer stale.\n\t\t */\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\t\tmp->m_bsize * blks_per_cluster,\n\t\t\t\t\tXBF_UNMAPPED);\n\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * This buffer may not have been correctly initialised as we\n\t\t * didn't read it from disk. That's not important because we are\n\t\t * only using to mark the buffer as stale in the log, and to\n\t\t * attach stale cached inodes on it. That means it will never be\n\t\t * dispatched for IO. If it is, we want to know about it, and we\n\t\t * want it to fail. We can acheive this by adding a write\n\t\t * verifier to the buffer.\n\t\t */\n\t\t bp->b_ops = &xfs_inode_buf_ops;\n\n\t\t/*\n\t\t * Walk the inodes already attached to the buffer and mark them\n\t\t * stale. These will all have the flush locks held, so an\n\t\t * in-memory inode walk can't lock them. By marking them all\n\t\t * stale first, we will not attempt to lock them in the loop\n\t\t * below as the XFS_ISTALE flag will be set.\n\t\t */\n\t\tlip = bp->b_fspriv;\n\t\twhile (lip) {\n\t\t\tif (lip->li_type == XFS_LI_INODE) {\n\t\t\t\tiip = (xfs_inode_log_item_t *)lip;\n\t\t\t\tASSERT(iip->ili_logged == 1);\n\t\t\t\tlip->li_cb = xfs_istale_done;\n\t\t\t\txfs_trans_ail_copy_lsn(mp->m_ail,\n\t\t\t\t\t\t\t&iip->ili_flush_lsn,\n\t\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\t\t\t\txfs_iflags_set(iip->ili_inode, XFS_ISTALE);\n\t\t\t}\n\t\t\tlip = lip->li_bio_list;\n\t\t}\n\n\n\t\t/*\n\t\t * For each inode in memory attempt to add it to the inode\n\t\t * buffer and set it up for being staled on buffer IO\n\t\t * completion.  This is safe as we've locked out tail pushing\n\t\t * and flushing by locking the buffer.\n\t\t *\n\t\t * We have already marked every inode that was part of a\n\t\t * transaction stale above, which means there is no point in\n\t\t * even trying to lock them.\n\t\t */\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\nretry:\n\t\t\trcu_read_lock();\n\t\t\tip = radix_tree_lookup(&pag->pag_ici_root,\n\t\t\t\t\tXFS_INO_TO_AGINO(mp, (inum + i)));\n\n\t\t\t/* Inode not in memory, nothing to do */\n\t\t\tif (!ip) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * because this is an RCU protected lookup, we could\n\t\t\t * find a recently freed or even reallocated inode\n\t\t\t * during the lookup. We need to check under the\n\t\t\t * i_flags_lock for a valid inode here. Skip it if it\n\t\t\t * is not valid, the wrong inode or stale.\n\t\t\t */\n\t\t\tspin_lock(&ip->i_flags_lock);\n\t\t\tif (ip->i_ino != inum + i ||\n\t\t\t    __xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t\t/*\n\t\t\t * Don't try to lock/unlock the current inode, but we\n\t\t\t * _cannot_ skip the other inodes that we did not find\n\t\t\t * in the list attached to the buffer and are not\n\t\t\t * already marked stale. If we can't lock it, back off\n\t\t\t * and retry.\n\t\t\t */\n\t\t\tif (ip != free_ip &&\n\t\t\t    !xfs_ilock_nowait(ip, XFS_ILOCK_EXCL)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tdelay(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\txfs_iflock(ip);\n\t\t\txfs_iflags_set(ip, XFS_ISTALE);\n\n\t\t\t/*\n\t\t\t * we don't need to attach clean inodes or those only\n\t\t\t * with unlogged changes (which we throw away, anyway).\n\t\t\t */\n\t\t\tiip = ip->i_itemp;\n\t\t\tif (!iip || xfs_inode_clean(ip)) {\n\t\t\t\tASSERT(ip != free_ip);\n\t\t\t\txfs_ifunlock(ip);\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tiip->ili_last_fields = iip->ili_fields;\n\t\t\tiip->ili_fields = 0;\n\t\t\tiip->ili_logged = 1;\n\t\t\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\n\t\t\txfs_buf_attach_iodone(bp, xfs_istale_done,\n\t\t\t\t\t\t  &iip->ili_item);\n\n\t\t\tif (ip != free_ip)\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\n\txfs_perag_put(pag);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "bp"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_stale_inode_buf",
          "args": [
            "tp",
            "bp"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_stale_inode_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "663-677",
          "snippet": "void\nxfs_trans_stale_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_STALE_INODE;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_stale_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_STALE_INODE;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_attach_iodone",
          "args": [
            "bp",
            "xfs_istale_done",
            "&iip->ili_item"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_attach_iodone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "987-1009",
          "snippet": "void\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_copy_lsn",
          "args": [
            "mp->m_ail",
            "&iip->ili_flush_lsn",
            "&iip->ili_item.li_lsn"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_copy_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "151-159",
          "snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "ip"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip != free_ip"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_clean",
          "args": [
            "ip"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.h",
          "lines": "39-42",
          "snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_set",
          "args": [
            "ip",
            "XFS_ISTALE"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "118-124",
          "snippet": "static inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflock",
          "args": [
            "ip"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "490-504",
          "snippet": "void\n__xfs_iflock(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IFLOCK_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IFLOCK_BIT);\n\n\tdo {\n\t\tprepare_to_wait_exclusive(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_isiflocked(ip))\n\t\t\tio_schedule();\n\t} while (!xfs_iflock_nowait(ip));\n\n\tfinish_wait(wq, &wait.wait);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\n__xfs_iflock(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IFLOCK_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IFLOCK_BIT);\n\n\tdo {\n\t\tprepare_to_wait_exclusive(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_isiflocked(ip))\n\t\t\tio_schedule();\n\t} while (!xfs_iflock_nowait(ip));\n\n\tfinish_wait(wq, &wait.wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xfs_iflags_test",
          "args": [
            "ip",
            "XFS_ISTALE"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflags_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "134-138",
          "snippet": "static inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(mp, (inum + i))"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "(inum + i)"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iip->ili_logged == 1"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "blkno",
            "mp->m_bsize * blks_per_cluster",
            "XBF_UNMAPPED"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, inum)",
            "XFS_INO_TO_AGBNO(mp, inum)"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGBNO",
          "args": [
            "mp",
            "inum"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "inum"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icluster_size_fsb",
          "args": [
            "mp"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icluster_size_fsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.h",
          "lines": "32-39",
          "snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, inum)"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "inum"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_ifree_cluster(\n\txfs_inode_t\t*free_ip,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tinum)\n{\n\txfs_mount_t\t\t*mp = free_ip->i_mount;\n\tint\t\t\tblks_per_cluster;\n\tint\t\t\tinodes_per_cluster;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\tblkno;\n\txfs_buf_t\t\t*bp;\n\txfs_inode_t\t\t*ip;\n\txfs_inode_log_item_t\t*iip;\n\txfs_log_item_t\t\t*lip;\n\tstruct xfs_perag\t*pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = mp->m_ialloc_blks / blks_per_cluster;\n\n\tfor (j = 0; j < nbufs; j++, inum += inodes_per_cluster) {\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\n\t\t/*\n\t\t * We obtain and lock the backing buffer first in the process\n\t\t * here, as we have to ensure that any dirty inode that we\n\t\t * can't get the flush lock on is attached to the buffer.\n\t\t * If we scan the in-memory inodes first, then buffer IO can\n\t\t * complete before we get a lock on it, and hence we may fail\n\t\t * to mark all the active inodes on the buffer stale.\n\t\t */\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\t\tmp->m_bsize * blks_per_cluster,\n\t\t\t\t\tXBF_UNMAPPED);\n\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * This buffer may not have been correctly initialised as we\n\t\t * didn't read it from disk. That's not important because we are\n\t\t * only using to mark the buffer as stale in the log, and to\n\t\t * attach stale cached inodes on it. That means it will never be\n\t\t * dispatched for IO. If it is, we want to know about it, and we\n\t\t * want it to fail. We can acheive this by adding a write\n\t\t * verifier to the buffer.\n\t\t */\n\t\t bp->b_ops = &xfs_inode_buf_ops;\n\n\t\t/*\n\t\t * Walk the inodes already attached to the buffer and mark them\n\t\t * stale. These will all have the flush locks held, so an\n\t\t * in-memory inode walk can't lock them. By marking them all\n\t\t * stale first, we will not attempt to lock them in the loop\n\t\t * below as the XFS_ISTALE flag will be set.\n\t\t */\n\t\tlip = bp->b_fspriv;\n\t\twhile (lip) {\n\t\t\tif (lip->li_type == XFS_LI_INODE) {\n\t\t\t\tiip = (xfs_inode_log_item_t *)lip;\n\t\t\t\tASSERT(iip->ili_logged == 1);\n\t\t\t\tlip->li_cb = xfs_istale_done;\n\t\t\t\txfs_trans_ail_copy_lsn(mp->m_ail,\n\t\t\t\t\t\t\t&iip->ili_flush_lsn,\n\t\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\t\t\t\txfs_iflags_set(iip->ili_inode, XFS_ISTALE);\n\t\t\t}\n\t\t\tlip = lip->li_bio_list;\n\t\t}\n\n\n\t\t/*\n\t\t * For each inode in memory attempt to add it to the inode\n\t\t * buffer and set it up for being staled on buffer IO\n\t\t * completion.  This is safe as we've locked out tail pushing\n\t\t * and flushing by locking the buffer.\n\t\t *\n\t\t * We have already marked every inode that was part of a\n\t\t * transaction stale above, which means there is no point in\n\t\t * even trying to lock them.\n\t\t */\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\nretry:\n\t\t\trcu_read_lock();\n\t\t\tip = radix_tree_lookup(&pag->pag_ici_root,\n\t\t\t\t\tXFS_INO_TO_AGINO(mp, (inum + i)));\n\n\t\t\t/* Inode not in memory, nothing to do */\n\t\t\tif (!ip) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * because this is an RCU protected lookup, we could\n\t\t\t * find a recently freed or even reallocated inode\n\t\t\t * during the lookup. We need to check under the\n\t\t\t * i_flags_lock for a valid inode here. Skip it if it\n\t\t\t * is not valid, the wrong inode or stale.\n\t\t\t */\n\t\t\tspin_lock(&ip->i_flags_lock);\n\t\t\tif (ip->i_ino != inum + i ||\n\t\t\t    __xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t\t/*\n\t\t\t * Don't try to lock/unlock the current inode, but we\n\t\t\t * _cannot_ skip the other inodes that we did not find\n\t\t\t * in the list attached to the buffer and are not\n\t\t\t * already marked stale. If we can't lock it, back off\n\t\t\t * and retry.\n\t\t\t */\n\t\t\tif (ip != free_ip &&\n\t\t\t    !xfs_ilock_nowait(ip, XFS_ILOCK_EXCL)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tdelay(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\txfs_iflock(ip);\n\t\t\txfs_iflags_set(ip, XFS_ISTALE);\n\n\t\t\t/*\n\t\t\t * we don't need to attach clean inodes or those only\n\t\t\t * with unlogged changes (which we throw away, anyway).\n\t\t\t */\n\t\t\tiip = ip->i_itemp;\n\t\t\tif (!iip || xfs_inode_clean(ip)) {\n\t\t\t\tASSERT(ip != free_ip);\n\t\t\t\txfs_ifunlock(ip);\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tiip->ili_last_fields = iip->ili_fields;\n\t\t\tiip->ili_fields = 0;\n\t\t\tiip->ili_logged = 1;\n\t\t\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t\t\t&iip->ili_item.li_lsn);\n\n\t\t\txfs_buf_attach_iodone(bp, xfs_istale_done,\n\t\t\t\t\t\t  &iip->ili_item);\n\n\t\t\tif (ip != free_ip)\n\t\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\n\txfs_perag_put(pag);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iunlink_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "2007-2176",
    "snippet": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inobp_check",
          "args": [
            "mp",
            "last_ibp"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "37-57",
          "snippet": "void\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "last_ibp",
            "offset",
            "(offset + sizeof(xfs_agino_t) - 1)"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_inode_buf",
          "args": [
            "tp",
            "last_ibp"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_inode_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "639-652",
          "snippet": "void\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "mp",
            "last_dip"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != 0"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "next_agino"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "ibp"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != agino"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != 0"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_next_unlinked"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_imap_to_bp(2) returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap_to_bp",
          "args": [
            "mp",
            "tp",
            "&ip->i_imap",
            "&dip",
            "&ibp",
            "0",
            "0"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_to_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "156-191",
          "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != 0"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != NULLAGINO"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "last_dip->di_next_unlinked"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_imap_to_bp returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_imap returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap",
          "args": [
            "mp",
            "tp",
            "next_ino",
            "&imap",
            "0"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1804-1934",
          "snippet": "int\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "next_agino"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_unlinked[bucket_index]"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "agibp",
            "XFS_BLFT_AGI_BUF"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "next_agino"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != agino"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != 0"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_agino != 0"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_next_unlinked"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_imap_to_bp returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_unlinked[bucket_index]"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_unlinked[bucket_index]"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO)"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agino != 0"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agibp"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&agibp"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iunlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1926-2002",
    "snippet": "int\nxfs_iunlink(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agino_t\tagino;\n\tshort\t\tbucket_index;\n\tint\t\toffset;\n\tint\t\terror;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, XFS_INO_TO_AGNO(mp, ip->i_ino), &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\tASSERT(be32_to_cpu(agi->agi_unlinked[bucket_index]) != agino);\n\n\tif (agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO)) {\n\t\t/*\n\t\t * There is already another inode in the bucket we need\n\t\t * to add ourselves to.  Add us at the front of the list.\n\t\t * Here we put the head pointer into our next pointer,\n\t\t * and then we fall through to point the head at us.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(dip->di_next_unlinked == cpu_to_be32(NULLAGINO));\n\t\tdip->di_next_unlinked = agi->agi_unlinked[bucket_index];\n\t\toffset = ip->i_imap.im_boffset +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\txfs_trans_inode_buf(tp, ibp);\n\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, ibp);\n\t}\n\n\t/*\n\t * Point the bucket head pointer at the inode being inserted.\n\t */\n\tASSERT(agino != 0);\n\tagi->agi_unlinked[bucket_index] = cpu_to_be32(agino);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t(sizeof(xfs_agino_t) * bucket_index);\n\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "agibp",
            "offset",
            "(offset + sizeof(xfs_agino_t) - 1)"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "agibp",
            "XFS_BLFT_AGI_BUF"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agino"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agino != 0"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobp_check",
          "args": [
            "mp",
            "ibp"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "37-57",
          "snippet": "void\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_inode_buf",
          "args": [
            "tp",
            "ibp"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_inode_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "639-652",
          "snippet": "void\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "mp",
            "dip"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dip->di_next_unlinked == cpu_to_be32(NULLAGINO)"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap_to_bp",
          "args": [
            "mp",
            "tp",
            "&ip->i_imap",
            "&dip",
            "&ibp",
            "0",
            "0"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_to_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "156-191",
          "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(agi->agi_unlinked[bucket_index]) != agino"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_unlinked[bucket_index]"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agi->agi_unlinked[bucket_index]"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agino != 0"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agibp"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "tp",
            "XFS_INO_TO_AGNO(mp, ip->i_ino)",
            "&agibp"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_mode != 0"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink == 0"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_iunlink(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agino_t\tagino;\n\tshort\t\tbucket_index;\n\tint\t\toffset;\n\tint\t\terror;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, XFS_INO_TO_AGNO(mp, ip->i_ino), &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\tASSERT(be32_to_cpu(agi->agi_unlinked[bucket_index]) != agino);\n\n\tif (agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO)) {\n\t\t/*\n\t\t * There is already another inode in the bucket we need\n\t\t * to add ourselves to.  Add us at the front of the list.\n\t\t * Here we put the head pointer into our next pointer,\n\t\t * and then we fall through to point the head at us.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(dip->di_next_unlinked == cpu_to_be32(NULLAGINO));\n\t\tdip->di_next_unlinked = agi->agi_unlinked[bucket_index];\n\t\toffset = ip->i_imap.im_boffset +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\txfs_trans_inode_buf(tp, ibp);\n\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, ibp);\n\t}\n\n\t/*\n\t * Point the bucket head pointer at the inode being inserted.\n\t */\n\tASSERT(agino != 0);\n\tagi->agi_unlinked[bucket_index] = cpu_to_be32(agino);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t(sizeof(xfs_agino_t) * bucket_index);\n\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1837-1919",
    "snippet": "void\nxfs_inactive(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount\t*mp;\n\tint\t\t\terror;\n\tint\t\t\ttruncate = 0;\n\n\t/*\n\t * If the inode is already free, then there can be nothing\n\t * to clean up here.\n\t */\n\tif (ip->i_d.di_mode == 0) {\n\t\tASSERT(ip->i_df.if_real_bytes == 0);\n\t\tASSERT(ip->i_df.if_broot_bytes == 0);\n\t\treturn;\n\t}\n\n\tmp = ip->i_mount;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn;\n\n\tif (ip->i_d.di_nlink != 0) {\n\t\t/*\n\t\t * force is true because we are evicting an inode from the\n\t\t * cache. Post-eof blocks must be freed, lest we end up with\n\t\t * broken free space accounting.\n\t\t */\n\t\tif (xfs_can_free_eofblocks(ip, true))\n\t\t\txfs_free_eofblocks(mp, ip, false);\n\n\t\treturn;\n\t}\n\n\tif (S_ISREG(ip->i_d.di_mode) &&\n\t    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||\n\t     ip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))\n\t\ttruncate = 1;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn;\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\terror = xfs_inactive_symlink(ip);\n\telse if (truncate)\n\t\terror = xfs_inactive_truncate(ip);\n\tif (error)\n\t\treturn;\n\n\t/*\n\t * If there are attributes associated with the file then blow them away\n\t * now.  The code calls a routine that recursively deconstructs the\n\t * attribute fork.  We need to just commit the current transaction\n\t * because we can't use it for xfs_attr_inactive().\n\t */\n\tif (ip->i_d.di_anextents > 0) {\n\t\tASSERT(ip->i_d.di_forkoff != 0);\n\n\t\terror = xfs_attr_inactive(ip);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\t/*\n\t * Free the inode.\n\t */\n\terror = xfs_inactive_ifree(ip);\n\tif (error)\n\t\treturn;\n\n\t/*\n\t * Release the dquots held by inode, if any.\n\t */\n\txfs_qm_dqdetach(ip);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqdetach",
          "args": [
            "ip"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "401-423",
          "snippet": "void\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inactive_ifree",
          "args": [
            "ip"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inactive_ifree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1742-1827",
          "snippet": "STATIC int\nxfs_inactive_ifree(\n\tstruct xfs_inode *ip)\n{\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t/*\n\t * The ifree transaction might need to allocate blocks for record\n\t * insertion to the finobt. We don't want to fail here at ENOSPC, so\n\t * allow ifree to dip into the reserved block pool if necessary.\n\t *\n\t * Freeing large sets of inodes generally means freeing inode chunks,\n\t * directory and file data blocks, so this should be relatively safe.\n\t * Only under severe circumstances should it be possible to free enough\n\t * inodes to exhaust the reserve block pool via finobt expansion while\n\t * at the same time not creating free space in the filesystem.\n\t *\n\t * Send a warning if the reservation does happen to fail, as the inode\n\t * now remains allocated and sits on the unlinked list until the fs is\n\t * repaired.\n\t */\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree,\n\t\t\t\t  XFS_IFREE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\tif (error == -ENOSPC) {\n\t\t\txfs_warn_ratelimited(mp,\n\t\t\t\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\");\n\t\t} else {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_ifree(tp, ip, &free_list);\n\tif (error) {\n\t\t/*\n\t\t * If we fail to free the inode, shut down.  The cancel\n\t\t * might do that, we need to make sure.  Otherwise the\n\t\t * inode might be lost for a long time or forever.\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\txfs_notice(mp, \"%s: xfs_ifree returned error %d\",\n\t\t\t\t__func__, error);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Credit the quota account(s). The inode is gone.\n\t */\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/*\n\t * Just ignore errors at this point.  There is nothing we can\n\t * do except to try to keep going. Make sure it's not a silent\n\t * error.\n\t */\n\terror = xfs_bmap_finish(&tp,  &free_list, &committed);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_bmap_finish returned error %d\",\n\t\t\t__func__, error);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_trans_commit returned error %d\",\n\t\t\t__func__, error);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_inactive_ifree(\n\tstruct xfs_inode *ip)\n{\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t/*\n\t * The ifree transaction might need to allocate blocks for record\n\t * insertion to the finobt. We don't want to fail here at ENOSPC, so\n\t * allow ifree to dip into the reserved block pool if necessary.\n\t *\n\t * Freeing large sets of inodes generally means freeing inode chunks,\n\t * directory and file data blocks, so this should be relatively safe.\n\t * Only under severe circumstances should it be possible to free enough\n\t * inodes to exhaust the reserve block pool via finobt expansion while\n\t * at the same time not creating free space in the filesystem.\n\t *\n\t * Send a warning if the reservation does happen to fail, as the inode\n\t * now remains allocated and sits on the unlinked list until the fs is\n\t * repaired.\n\t */\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree,\n\t\t\t\t  XFS_IFREE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\tif (error == -ENOSPC) {\n\t\t\txfs_warn_ratelimited(mp,\n\t\t\t\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\");\n\t\t} else {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_ifree(tp, ip, &free_list);\n\tif (error) {\n\t\t/*\n\t\t * If we fail to free the inode, shut down.  The cancel\n\t\t * might do that, we need to make sure.  Otherwise the\n\t\t * inode might be lost for a long time or forever.\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\txfs_notice(mp, \"%s: xfs_ifree returned error %d\",\n\t\t\t\t__func__, error);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Credit the quota account(s). The inode is gone.\n\t */\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/*\n\t * Just ignore errors at this point.  There is nothing we can\n\t * do except to try to keep going. Make sure it's not a silent\n\t * error.\n\t */\n\terror = xfs_bmap_finish(&tp,  &free_list, &committed);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_bmap_finish returned error %d\",\n\t\t\t__func__, error);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_trans_commit returned error %d\",\n\t\t\t__func__, error);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_anextents == 0"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idestroy_fork",
          "args": [
            "ip",
            "XFS_ATTR_FORK"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idestroy_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "678-719",
          "snippet": "void\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\n\nvoid\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_inactive",
          "args": [
            "ip"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "382-449",
          "snippet": "int\nxfs_attr_inactive(xfs_inode_t *dp)\n{\n\txfs_trans_t *trans;\n\txfs_mount_t *mp;\n\tint error;\n\n\tmp = dp->i_mount;\n\tASSERT(! XFS_NOT_DQATTACHED(mp, dp));\n\n\txfs_ilock(dp, XFS_ILOCK_SHARED);\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\ttrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\n\terror = xfs_trans_reserve(trans, &M_RES(mp)->tr_attrinval, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks, not allocate, in the common case.\n\t */\n\txfs_trans_ijoin(trans, dp, 0);\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\terror = xfs_attr3_root_inactive(&trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_inactive(xfs_inode_t *dp)\n{\n\txfs_trans_t *trans;\n\txfs_mount_t *mp;\n\tint error;\n\n\tmp = dp->i_mount;\n\tASSERT(! XFS_NOT_DQATTACHED(mp, dp));\n\n\txfs_ilock(dp, XFS_ILOCK_SHARED);\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\ttrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\n\terror = xfs_trans_reserve(trans, &M_RES(mp)->tr_attrinval, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks, not allocate, in the common case.\n\t */\n\txfs_trans_ijoin(trans, dp, 0);\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\terror = xfs_attr3_root_inactive(&trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_forkoff != 0"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inactive_truncate",
          "args": [
            "ip"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inactive_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1690-1735",
          "snippet": "STATIC int\nxfs_inactive_truncate(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Log the inode size first to prevent stale data exposure in the event\n\t * of a system crash before the truncate completes. See the related\n\t * comment in xfs_setattr_size() for details.\n\t */\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto error_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_inactive_truncate(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Log the inode size first to prevent stale data exposure in the event\n\t * of a system crash before the truncate completes. See the related\n\t * comment in xfs_setattr_size() for details.\n\t */\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto error_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inactive_symlink",
          "args": [
            "ip"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inactive_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "554-598",
          "snippet": "int\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_eofblocks",
          "args": [
            "mp",
            "ip",
            "false"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "833-926",
          "snippet": "int\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_can_free_eofblocks",
          "args": [
            "ip",
            "true"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_can_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "797-826",
          "snippet": "bool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_broot_bytes == 0"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_real_bytes == 0"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_inactive(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount\t*mp;\n\tint\t\t\terror;\n\tint\t\t\ttruncate = 0;\n\n\t/*\n\t * If the inode is already free, then there can be nothing\n\t * to clean up here.\n\t */\n\tif (ip->i_d.di_mode == 0) {\n\t\tASSERT(ip->i_df.if_real_bytes == 0);\n\t\tASSERT(ip->i_df.if_broot_bytes == 0);\n\t\treturn;\n\t}\n\n\tmp = ip->i_mount;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn;\n\n\tif (ip->i_d.di_nlink != 0) {\n\t\t/*\n\t\t * force is true because we are evicting an inode from the\n\t\t * cache. Post-eof blocks must be freed, lest we end up with\n\t\t * broken free space accounting.\n\t\t */\n\t\tif (xfs_can_free_eofblocks(ip, true))\n\t\t\txfs_free_eofblocks(mp, ip, false);\n\n\t\treturn;\n\t}\n\n\tif (S_ISREG(ip->i_d.di_mode) &&\n\t    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||\n\t     ip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))\n\t\ttruncate = 1;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn;\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\terror = xfs_inactive_symlink(ip);\n\telse if (truncate)\n\t\terror = xfs_inactive_truncate(ip);\n\tif (error)\n\t\treturn;\n\n\t/*\n\t * If there are attributes associated with the file then blow them away\n\t * now.  The code calls a routine that recursively deconstructs the\n\t * attribute fork.  We need to just commit the current transaction\n\t * because we can't use it for xfs_attr_inactive().\n\t */\n\tif (ip->i_d.di_anextents > 0) {\n\t\tASSERT(ip->i_d.di_forkoff != 0);\n\n\t\terror = xfs_attr_inactive(ip);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\t/*\n\t * Free the inode.\n\t */\n\terror = xfs_inactive_ifree(ip);\n\tif (error)\n\t\treturn;\n\n\t/*\n\t * Release the dquots held by inode, if any.\n\t */\n\txfs_qm_dqdetach(ip);\n}"
  },
  {
    "function_name": "xfs_inactive_ifree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1742-1827",
    "snippet": "STATIC int\nxfs_inactive_ifree(\n\tstruct xfs_inode *ip)\n{\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t/*\n\t * The ifree transaction might need to allocate blocks for record\n\t * insertion to the finobt. We don't want to fail here at ENOSPC, so\n\t * allow ifree to dip into the reserved block pool if necessary.\n\t *\n\t * Freeing large sets of inodes generally means freeing inode chunks,\n\t * directory and file data blocks, so this should be relatively safe.\n\t * Only under severe circumstances should it be possible to free enough\n\t * inodes to exhaust the reserve block pool via finobt expansion while\n\t * at the same time not creating free space in the filesystem.\n\t *\n\t * Send a warning if the reservation does happen to fail, as the inode\n\t * now remains allocated and sits on the unlinked list until the fs is\n\t * repaired.\n\t */\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree,\n\t\t\t\t  XFS_IFREE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\tif (error == -ENOSPC) {\n\t\t\txfs_warn_ratelimited(mp,\n\t\t\t\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\");\n\t\t} else {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_ifree(tp, ip, &free_list);\n\tif (error) {\n\t\t/*\n\t\t * If we fail to free the inode, shut down.  The cancel\n\t\t * might do that, we need to make sure.  Otherwise the\n\t\t * inode might be lost for a long time or forever.\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\txfs_notice(mp, \"%s: xfs_ifree returned error %d\",\n\t\t\t\t__func__, error);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Credit the quota account(s). The inode is gone.\n\t */\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/*\n\t * Just ignore errors at this point.  There is nothing we can\n\t * do except to try to keep going. Make sure it's not a silent\n\t * error.\n\t */\n\terror = xfs_bmap_finish(&tp,  &free_list, &committed);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_bmap_finish returned error %d\",\n\t\t\t__func__, error);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_trans_commit returned error %d\",\n\t\t\t__func__, error);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s: xfs_trans_commit returned error %d\"",
            "__func__",
            "error"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s: xfs_bmap_finish returned error %d\"",
            "__func__",
            "error"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "XFS_TRANS_DQ_ICOUNT",
            "-1"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_META_IO_ERROR"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s: xfs_ifree returned error %d\"",
            "__func__",
            "error"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ifree",
          "args": [
            "tp",
            "ip",
            "&free_list"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2357-2402",
          "snippet": "int\nxfs_ifree(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_bmap_free_t\t*flist)\n{\n\tint\t\t\terror;\n\tint\t\t\tdelete;\n\txfs_ino_t\t\tfirst_ino;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_nextents == 0);\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_d.di_size == 0 || !S_ISREG(ip->i_d.di_mode));\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\t/*\n\t * Pull the on-disk inode from the AGI unlinked list.\n\t */\n\terror = xfs_iunlink_remove(tp, ip);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_difree(tp, ip->i_ino, flist, &delete, &first_ino);\n\tif (error)\n\t\treturn error;\n\n\tip->i_d.di_mode = 0;\t\t/* mark incore inode as free */\n\tip->i_d.di_flags = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_forkoff = 0;\t\t/* mark the attr fork not in use */\n\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t/*\n\t * Bump the generation count so no one will be confused\n\t * by reincarnations of this inode.\n\t */\n\tip->i_d.di_gen++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (delete)\n\t\terror = xfs_ifree_cluster(ip, tp, first_ino);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ifree(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_bmap_free_t\t*flist)\n{\n\tint\t\t\terror;\n\tint\t\t\tdelete;\n\txfs_ino_t\t\tfirst_ino;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_nextents == 0);\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_d.di_size == 0 || !S_ISREG(ip->i_d.di_mode));\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\t/*\n\t * Pull the on-disk inode from the AGI unlinked list.\n\t */\n\terror = xfs_iunlink_remove(tp, ip);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_difree(tp, ip->i_ino, flist, &delete, &first_ino);\n\tif (error)\n\t\treturn error;\n\n\tip->i_d.di_mode = 0;\t\t/* mark incore inode as free */\n\tip->i_d.di_flags = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_forkoff = 0;\t\t/* mark the attr fork not in use */\n\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t/*\n\t * Bump the generation count so no one will be confused\n\t * by reincarnations of this inode.\n\t */\n\tip->i_d.di_gen++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (delete)\n\t\terror = xfs_ifree_cluster(ip, tp, first_ino);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn_ratelimited",
          "args": [
            "mp",
            "\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\""
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_ifree",
            "XFS_IFREE_SPACE_RES(mp)",
            "0"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFREE_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_INACTIVE"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_inactive_ifree(\n\tstruct xfs_inode *ip)\n{\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t/*\n\t * The ifree transaction might need to allocate blocks for record\n\t * insertion to the finobt. We don't want to fail here at ENOSPC, so\n\t * allow ifree to dip into the reserved block pool if necessary.\n\t *\n\t * Freeing large sets of inodes generally means freeing inode chunks,\n\t * directory and file data blocks, so this should be relatively safe.\n\t * Only under severe circumstances should it be possible to free enough\n\t * inodes to exhaust the reserve block pool via finobt expansion while\n\t * at the same time not creating free space in the filesystem.\n\t *\n\t * Send a warning if the reservation does happen to fail, as the inode\n\t * now remains allocated and sits on the unlinked list until the fs is\n\t * repaired.\n\t */\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree,\n\t\t\t\t  XFS_IFREE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\tif (error == -ENOSPC) {\n\t\t\txfs_warn_ratelimited(mp,\n\t\t\t\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\");\n\t\t} else {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_ifree(tp, ip, &free_list);\n\tif (error) {\n\t\t/*\n\t\t * If we fail to free the inode, shut down.  The cancel\n\t\t * might do that, we need to make sure.  Otherwise the\n\t\t * inode might be lost for a long time or forever.\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\txfs_notice(mp, \"%s: xfs_ifree returned error %d\",\n\t\t\t\t__func__, error);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\n\t\t}\n\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Credit the quota account(s). The inode is gone.\n\t */\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/*\n\t * Just ignore errors at this point.  There is nothing we can\n\t * do except to try to keep going. Make sure it's not a silent\n\t * error.\n\t */\n\terror = xfs_bmap_finish(&tp,  &free_list, &committed);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_bmap_finish returned error %d\",\n\t\t\t__func__, error);\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\txfs_notice(mp, \"%s: xfs_trans_commit returned error %d\",\n\t\t\t__func__, error);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inactive_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1690-1735",
    "snippet": "STATIC int\nxfs_inactive_truncate(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Log the inode size first to prevent stale data exposure in the event\n\t * of a system crash before the truncate completes. See the related\n\t * comment in xfs_setattr_size() for details.\n\t */\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto error_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nextents == 0"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_itruncate_extents",
          "args": [
            "&tp",
            "ip",
            "XFS_DATA_FORK",
            "0"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_itruncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1492-1605",
          "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [
            "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_INACTIVE"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int\nxfs_inactive_truncate(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Log the inode size first to prevent stale data exposure in the event\n\t * of a system crash before the truncate completes. See the related\n\t * comment in xfs_setattr_size() for details.\n\t */\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tASSERT(ip->i_d.di_nextents == 0);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto error_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1607-1683",
    "snippet": "int\nxfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror;\n\n\tif (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))\n\t\treturn 0;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tint truncated;\n\n\t\t/*\n\t\t * If we previously truncated this file and removed old data\n\t\t * in the process, we want to initiate \"early\" writeout on\n\t\t * the last close.  This is an attempt to combat the notorious\n\t\t * NULL files problem which is particularly noticeable from a\n\t\t * truncate down, buffered (re-)write (delalloc), followed by\n\t\t * a crash.  What we are effectively doing here is\n\t\t * significantly reducing the time window where we'd otherwise\n\t\t * be exposed to that problem.\n\t\t */\n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ip->i_d.di_nlink == 0)\n\t\treturn 0;\n\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\n\t\t/*\n\t\t * If we can't get the iolock just skip truncating the blocks\n\t\t * past EOF because we could deadlock with the mmap_sem\n\t\t * otherwise.  We'll get another chance to drop them once the\n\t\t * last reference to the inode is dropped, so we'll never leak\n\t\t * blocks permanently.\n\t\t *\n\t\t * Further, check if the inode is being opened, written and\n\t\t * closed frequently and we have delayed allocation blocks\n\t\t * outstanding (e.g. streaming writes from the NFS server),\n\t\t * truncating the blocks past EOF will cause fragmentation to\n\t\t * occur.\n\t\t *\n\t\t * In this case don't do the truncation, either, but we have to\n\t\t * be careful how we detect this case. Blocks beyond EOF show\n\t\t * up as i_delayed_blks even when the inode is clean, so we\n\t\t * need to truncate them away first before checking for a dirty\n\t\t * release. Hence on the first dirty close we will still remove\n\t\t * the speculative allocation, but after that we will leave it\n\t\t * in place.\n\t\t */\n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\treturn 0;\n\n\t\terror = xfs_free_eofblocks(mp, ip, true);\n\t\tif (error && error != -EAGAIN)\n\t\t\treturn error;\n\n\t\t/* delalloc blocks after truncation means it really is dirty */\n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iflags_set",
          "args": [
            "ip",
            "XFS_IDIRTY_RELEASE"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "118-124",
          "snippet": "static inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_eofblocks",
          "args": [
            "mp",
            "ip",
            "true"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "833-926",
          "snippet": "int\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_IDIRTY_RELEASE"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_can_free_eofblocks",
          "args": [
            "ip",
            "false"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_can_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "797-826",
          "snippet": "bool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "VFS_I(ip)->i_mapping"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "ip",
            "XFS_IDIRTY_RELEASE"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test_and_clear",
          "args": [
            "ip",
            "XFS_ITRUNCATED"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "150-161",
          "snippet": "static inline int\nxfs_iflags_test_and_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (ret)\n\t\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (ret)\n\t\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror;\n\n\tif (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))\n\t\treturn 0;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tint truncated;\n\n\t\t/*\n\t\t * If we previously truncated this file and removed old data\n\t\t * in the process, we want to initiate \"early\" writeout on\n\t\t * the last close.  This is an attempt to combat the notorious\n\t\t * NULL files problem which is particularly noticeable from a\n\t\t * truncate down, buffered (re-)write (delalloc), followed by\n\t\t * a crash.  What we are effectively doing here is\n\t\t * significantly reducing the time window where we'd otherwise\n\t\t * be exposed to that problem.\n\t\t */\n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ip->i_d.di_nlink == 0)\n\t\treturn 0;\n\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\n\t\t/*\n\t\t * If we can't get the iolock just skip truncating the blocks\n\t\t * past EOF because we could deadlock with the mmap_sem\n\t\t * otherwise.  We'll get another chance to drop them once the\n\t\t * last reference to the inode is dropped, so we'll never leak\n\t\t * blocks permanently.\n\t\t *\n\t\t * Further, check if the inode is being opened, written and\n\t\t * closed frequently and we have delayed allocation blocks\n\t\t * outstanding (e.g. streaming writes from the NFS server),\n\t\t * truncating the blocks past EOF will cause fragmentation to\n\t\t * occur.\n\t\t *\n\t\t * In this case don't do the truncation, either, but we have to\n\t\t * be careful how we detect this case. Blocks beyond EOF show\n\t\t * up as i_delayed_blks even when the inode is clean, so we\n\t\t * need to truncate them away first before checking for a dirty\n\t\t * release. Hence on the first dirty close we will still remove\n\t\t * the speculative allocation, but after that we will leave it\n\t\t * in place.\n\t\t */\n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\treturn 0;\n\n\t\terror = xfs_free_eofblocks(mp, ip, true);\n\t\tif (error && error != -EAGAIN)\n\t\t\treturn error;\n\n\t\t/* delalloc blocks after truncation means it really is dirty */\n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_itruncate_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1492-1605",
    "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [
      "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_itruncate_extents_end",
          "args": [
            "ip",
            "new_size"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "tp->t_ticket"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_dup",
          "args": [
            "tp"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "116-152",
          "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "tp",
            "ip",
            "first_unmap_block",
            "unmap_len",
            "xfs_bmapi_aflag(whichfork)",
            "XFS_ITRUNC_MAX_EXTENTS",
            "&first_block",
            "&free_list",
            "&done"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_aflag",
          "args": [
            "whichfork"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_aflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "122-125",
          "snippet": "static inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */\n\nstatic inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "first_unmap_block < last_block"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "mp->m_super->s_maxbytes"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "(xfs_ufsize_t)new_size"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_itruncate_extents_start",
          "args": [
            "ip",
            "new_size"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!XFS_NOT_DQATTACHED(mp, ip)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_itemp->ili_lock_flags == 0"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_itemp != NULL"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "new_size <= XFS_ISIZE(ip)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&VFS_I(ip)->i_count"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
  },
  {
    "function_name": "xfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1362-1469",
    "snippet": "int\nxfs_link(\n\txfs_inode_t\t\t*tdp,\n\txfs_inode_t\t\t*sip,\n\tstruct xfs_name\t\t*target_name)\n{\n\txfs_mount_t\t\t*mp = tdp->i_mount;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tint\t\t\tresblks;\n\n\ttrace_xfs_link(tdp, target_name);\n\n\tASSERT(!S_ISDIR(sip->i_d.di_mode));\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(sip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(tdp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_LINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_lock_two_inodes(sip, tdp, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, sip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, tdp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow hard link\n\t * creation in our tree when the project IDs are the same; else\n\t * the tree quota mechanism could be circumvented.\n\t */\n\tif (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(tdp) != xfs_get_projid(sip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, tdp, target_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\tif (sip->i_d.di_nlink == 0) {\n\t\terror = xfs_iunlink_remove(tp, sip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto abort_return;\n\txfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\n\n\terror = xfs_bumplink(tp, sip);\n\tif (error)\n\t\tgoto abort_return;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * link transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish (&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\tgoto abort_return;\n\t}\n\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bumplink",
          "args": [
            "tp",
            "sip"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bumplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1046-1059",
          "snippet": "int\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "tdp",
            "XFS_ILOG_CORE"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "tdp",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_createname",
          "args": [
            "tp",
            "tdp",
            "target_name",
            "sip->i_ino",
            "&first_block",
            "&free_list",
            "resblks"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_createname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "255-321",
          "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlink_remove",
          "args": [
            "tp",
            "sip"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlink_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2007-2176",
          "snippet": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_canenter",
          "args": [
            "tp",
            "tdp",
            "target_name"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_canenter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "556-563",
          "snippet": "int\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(tdp) != xfs_get_projid(sip))"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "sip"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "tdp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_lock_two_inodes",
          "args": [
            "sip",
            "tdp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_two_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "448-487",
          "snippet": "void\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_link",
            "0",
            "0"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LINK_SPACE_RES",
          "args": [
            "mp",
            "target_name->len"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_LINK"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "tdp",
            "0"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!S_ISDIR(sip->i_d.di_mode)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sip->i_d.di_mode"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_link",
          "args": [
            "tdp",
            "target_name"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_link(\n\txfs_inode_t\t\t*tdp,\n\txfs_inode_t\t\t*sip,\n\tstruct xfs_name\t\t*target_name)\n{\n\txfs_mount_t\t\t*mp = tdp->i_mount;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tint\t\t\tresblks;\n\n\ttrace_xfs_link(tdp, target_name);\n\n\tASSERT(!S_ISDIR(sip->i_d.di_mode));\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(sip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(tdp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_LINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_lock_two_inodes(sip, tdp, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, sip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, tdp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow hard link\n\t * creation in our tree when the project IDs are the same; else\n\t * the tree quota mechanism could be circumvented.\n\t */\n\tif (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(tdp) != xfs_get_projid(sip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, tdp, target_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\tif (sip->i_d.di_nlink == 0) {\n\t\terror = xfs_iunlink_remove(tp, sip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto abort_return;\n\txfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\n\n\terror = xfs_bumplink(tp, sip);\n\tif (error)\n\t\tgoto abort_return;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * link transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish (&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\tgoto abort_return;\n\t}\n\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_create_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1254-1360",
    "snippet": "int\nxfs_create_tmpfile(\n\tstruct xfs_inode\t*dp,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tprid_t                  prid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tresblks = XFS_IALLOC_SPACE_RES(mp);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE_TMPFILE);\n\n\ttres = &M_RES(mp)->tr_create_tmpfile;\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_dir_ialloc(&tp, dp, mode, 1, 0,\n\t\t\t\tprid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tip->i_d.di_nlink--;\n\terror = xfs_iunlink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "pdqp"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlink",
          "args": [
            "tp",
            "ip"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlink_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2007-2176",
          "snippet": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_create_dqattach",
          "args": [
            "tp",
            "ip",
            "udqp",
            "gdqp",
            "pdqp"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_create_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1897-1933",
          "snippet": "void\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_ialloc",
          "args": [
            "&tp",
            "dp",
            "mode",
            "1",
            "0",
            "prid",
            "resblks > 0",
            "&ip",
            "NULL"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "838-1009",
          "snippet": "int\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota",
          "args": [
            "tp",
            "mp",
            "udqp",
            "gdqp",
            "pdqp",
            "resblks",
            "1",
            "0"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "tres",
            "0",
            "0"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_CREATE_TMPFILE"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IALLOC_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_dqalloc",
          "args": [
            "dp",
            "xfs_kuid_to_uid(current_fsuid())",
            "xfs_kgid_to_gid(current_fsgid())",
            "prid",
            "XFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT",
            "&udqp",
            "&gdqp",
            "&pdqp"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quota.h",
          "lines": "105-114",
          "snippet": "static inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_quota_defs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_quota_defs.h\"\n\nstatic inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "current_fsgid()"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "current_fsuid()"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_initial_prid",
          "args": [
            "dp"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_initial_prid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "195-202",
          "snippet": "static inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_create_tmpfile(\n\tstruct xfs_inode\t*dp,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tprid_t                  prid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tresblks = XFS_IALLOC_SPACE_RES(mp);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE_TMPFILE);\n\n\ttres = &M_RES(mp)->tr_create_tmpfile;\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_dir_ialloc(&tp, dp, mode, 1, 0,\n\t\t\t\tprid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tip->i_d.di_nlink--;\n\terror = xfs_iunlink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1061-1252",
    "snippet": "int\nxfs_create(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\tumode_t\t\t\tmode,\n\txfs_dev_t\t\trdev,\n\txfs_inode_t\t\t**ipp)\n{\n\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool                    unlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\trdev = 0;\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_MKDIR);\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE);\n\t}\n\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * Initially assume that the file does not exist and\n\t * reserve the resources for that case.  If that is not\n\t * the case we'll drop the one we have and get a more\n\t * appropriate transaction later.\n\t */\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* flush outstanding delalloc blocks and retry */\n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\t}\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Reserve disk quota and the inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, name);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * A newly created regular or special file just has one directory\n\t * entry pointing to them, but a directory also the \".\" entry\n\t * pointing to itself.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\n\t\t\t       prid, resblks > 0, &ip, &committed);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\t/*\n\t * Now we join the directory inode to the transaction.  We do not do it\n\t * earlier because xfs_dir_ialloc might commit the previous transaction\n\t * (and release all the locks).  An error from here on will result in\n\t * the transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks ?\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp) : 0);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out_trans_abort;\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\tif (is_dir) {\n\t\terror = xfs_dir_init(tp, ip, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\terror = xfs_bumplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * create transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "pdqp"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_create_dqattach",
          "args": [
            "tp",
            "ip",
            "udqp",
            "gdqp",
            "pdqp"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_create_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1897-1933",
          "snippet": "void\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bumplink",
          "args": [
            "tp",
            "dp"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bumplink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1046-1059",
          "snippet": "int\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_init",
          "args": [
            "tp",
            "ip",
            "dp"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "225-249",
          "snippet": "int\nxfs_dir_init(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\txfs_inode_t\t*pdp)\n{\n\tstruct xfs_da_args *args;\n\tint\t\terror;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\terror = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);\n\tif (error)\n\t\treturn error;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->dp = dp;\n\targs->trans = tp;\n\terror = xfs_dir2_sf_create(args, pdp->i_ino);\n\tkmem_free(args);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_init(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\txfs_inode_t\t*pdp)\n{\n\tstruct xfs_da_args *args;\n\tint\t\terror;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\terror = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);\n\tif (error)\n\t\treturn error;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->dp = dp;\n\targs->trans = tp;\n\terror = xfs_dir2_sf_create(args, pdp->i_ino);\n\tkmem_free(args);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "dp",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_createname",
          "args": [
            "tp",
            "dp",
            "name",
            "ip->i_ino",
            "&first_block",
            "&free_list",
            "resblks ?\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp) : 0"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_createname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "255-321",
          "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IALLOC_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_ialloc",
          "args": [
            "&tp",
            "dp",
            "mode",
            "is_dir ? 2 : 1",
            "rdev",
            "prid",
            "resblks > 0",
            "&ip",
            "&committed"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "838-1009",
          "snippet": "int\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_canenter",
          "args": [
            "tp",
            "dp",
            "name"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_canenter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "556-563",
          "snippet": "int\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota",
          "args": [
            "tp",
            "mp",
            "udqp",
            "gdqp",
            "pdqp",
            "resblks",
            "1",
            "0"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL | XFS_ILOCK_PARENT"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "tres",
            "0",
            "0"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_flush_inodes",
          "args": [
            "mp"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "913-923",
          "snippet": "void\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_CREATE"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CREATE_SPACE_RES",
          "args": [
            "mp",
            "name->len"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_MKDIR_SPACE_RES",
          "args": [
            "mp",
            "name->len"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_dqalloc",
          "args": [
            "dp",
            "xfs_kuid_to_uid(current_fsuid())",
            "xfs_kgid_to_gid(current_fsgid())",
            "prid",
            "XFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT",
            "&udqp",
            "&gdqp",
            "&pdqp"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quota.h",
          "lines": "105-114",
          "snippet": "static inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_quota_defs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_quota_defs.h\"\n\nstatic inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "current_fsgid()"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "current_fsuid()"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_initial_prid",
          "args": [
            "dp"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_initial_prid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "195-202",
          "snippet": "static inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_create",
          "args": [
            "dp",
            "name"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_create(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\tumode_t\t\t\tmode,\n\txfs_dev_t\t\trdev,\n\txfs_inode_t\t\t**ipp)\n{\n\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool                    unlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\trdev = 0;\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_MKDIR);\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE);\n\t}\n\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * Initially assume that the file does not exist and\n\t * reserve the resources for that case.  If that is not\n\t * the case we'll drop the one we have and get a more\n\t * appropriate transaction later.\n\t */\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* flush outstanding delalloc blocks and retry */\n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\t}\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Reserve disk quota and the inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, name);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * A newly created regular or special file just has one directory\n\t * entry pointing to them, but a directory also the \".\" entry\n\t * pointing to itself.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\n\t\t\t       prid, resblks > 0, &ip, &committed);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\t/*\n\t * Now we join the directory inode to the transaction.  We do not do it\n\t * earlier because xfs_dir_ialloc might commit the previous transaction\n\t * (and release all the locks).  An error from here on will result in\n\t * the transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks ?\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp) : 0);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out_trans_abort;\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\tif (is_dir) {\n\t\terror = xfs_dir_init(tp, ip, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\terror = xfs_bumplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * create transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bumplink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1046-1059",
    "snippet": "int\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version > 1"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "ip",
            "XFS_ICHGTIME_CHG"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT(ip->i_d.di_version > 1);\n\tASSERT(ip->i_d.di_nlink > 0 || (VFS_I(ip)->i_state & I_LINKABLE));\n\tip->i_d.di_nlink++;\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_droplink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "1016-1041",
    "snippet": "int\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlink",
          "args": [
            "tp",
            "ip"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlink_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2007-2176",
          "snippet": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nSTATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)\n{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index] != cpu_to_be32(NULLAGINO));\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's on-disk\n\t\t * buffer to see if there is anyone after us on the list.\n\t\t * Only modify our next pointer if it is not already NULLAGINO.\n\t\t * This saves us the overhead of dealing with the buffer when\n\t\t * there is no need to change it.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\tstruct xfs_imap\timap;\n\n\t\t\tif (last_ibp)\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\n\t\t\timap.im_blkno = 0;\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\n\t\t\terror = xfs_imap(mp, tp, next_ino, &imap, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap returned error %d.\",\n\t\t\t\t\t __func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\terror = xfs_imap_to_bp(mp, tp, &imap, &last_dip,\n\t\t\t\t\t       &last_ibp, 0, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp,\n\t\"%s: xfs_imap_to_bp returned error %d.\",\n\t\t\t\t\t__func__, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tlast_offset = imap.im_boffset;\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on the\n\t\t * unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,\n\t\t\t\t       0, 0);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_imap_to_bp(2) returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t\t/* need to recalc the inode CRC if appropriate */\n\t\t\txfs_dinode_calc_crc(mp, dip);\n\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\t/* need to recalc the inode CRC if appropriate */\n\t\txfs_dinode_calc_crc(mp, last_dip);\n\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink > 0"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "ip",
            "XFS_ICHGTIME_CHG"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\t\t\t\t/* error */\nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\tint\terror;\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tASSERT (ip->i_d.di_nlink > 0);\n\tip->i_d.di_nlink--;\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = 0;\n\tif (ip->i_d.di_nlink == 0) {\n\t\t/*\n\t\t * We're dropping the last link to this file.\n\t\t * Move the on-disk inode to the AGI unlinked list.\n\t\t * From xfs_inactive() we will pull the inode from\n\t\t * the list and free it.\n\t\t */\n\t\terror = xfs_iunlink(tp, ip);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir_ialloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "838-1009",
    "snippet": "int\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!ialloc_context && ip"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc",
          "args": [
            "tp",
            "dp",
            "mode",
            "nlink",
            "rdev",
            "prid",
            "okalloc",
            "&ialloc_context",
            "&ip"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "638-826",
          "snippet": "int\nxfs_ialloc(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*pip,\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\n\tint\t\tokalloc,\n\txfs_buf_t\t**ialloc_context,\n\txfs_inode_t\t**ipp)\n{\n\tstruct xfs_mount *mp = tp->t_mountp;\n\txfs_ino_t\tino;\n\txfs_inode_t\t*ip;\n\tuint\t\tflags;\n\tint\t\terror;\n\tstruct timespec\ttv;\n\n\t/*\n\t * Call the space management code to pick\n\t * the on-disk inode to be allocated.\n\t */\n\terror = xfs_dialloc(tp, pip ? pip->i_ino : 0, mode, okalloc,\n\t\t\t    ialloc_context, &ino);\n\tif (error)\n\t\treturn error;\n\tif (*ialloc_context || ino == NULLFSINO) {\n\t\t*ipp = NULL;\n\t\treturn 0;\n\t}\n\tASSERT(*ialloc_context == NULL);\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively.\n\t * This is because we're setting fields here we need\n\t * to prevent others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE,\n\t\t\t XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\tASSERT(ip != NULL);\n\n\t/*\n\t * We always convert v1 inodes to v2 now - we only support filesystems\n\t * with >= v2 inode capability, so there is no reason for ever leaving\n\t * an inode in v1 format.\n\t */\n\tif (ip->i_d.di_version == 1)\n\t\tip->i_d.di_version = 2;\n\n\tip->i_d.di_mode = mode;\n\tip->i_d.di_onlink = 0;\n\tip->i_d.di_nlink = nlink;\n\tASSERT(ip->i_d.di_nlink == nlink);\n\tip->i_d.di_uid = xfs_kuid_to_uid(current_fsuid());\n\tip->i_d.di_gid = xfs_kgid_to_gid(current_fsgid());\n\txfs_set_projid(ip, prid);\n\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\n\tif (pip && XFS_INHERIT_GID(pip)) {\n\t\tip->i_d.di_gid = pip->i_d.di_gid;\n\t\tif ((pip->i_d.di_mode & S_ISGID) && S_ISDIR(mode)) {\n\t\t\tip->i_d.di_mode |= S_ISGID;\n\t\t}\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif ((irix_sgid_inherit) &&\n\t    (ip->i_d.di_mode & S_ISGID) &&\n\t    (!in_group_p(xfs_gid_to_kgid(ip->i_d.di_gid)))) {\n\t\tip->i_d.di_mode &= ~S_ISGID;\n\t}\n\n\tip->i_d.di_size = 0;\n\tip->i_d.di_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_fs_time(mp->m_super);\n\tip->i_d.di_mtime.t_sec = (__int32_t)tv.tv_sec;\n\tip->i_d.di_mtime.t_nsec = (__int32_t)tv.tv_nsec;\n\tip->i_d.di_atime = ip->i_d.di_mtime;\n\tip->i_d.di_ctime = ip->i_d.di_mtime;\n\n\t/*\n\t * di_gen will have been taken care of in xfs_iread.\n\t */\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (ip->i_d.di_version == 3) {\n\t\tASSERT(ip->i_d.di_ino == ino);\n\t\tASSERT(uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid));\n\t\tip->i_d.di_crc = 0;\n\t\tip->i_d.di_changecount = 1;\n\t\tip->i_d.di_lsn = 0;\n\t\tip->i_d.di_flags2 = 0;\n\t\tmemset(&(ip->i_d.di_pad2[0]), 0, sizeof(ip->i_d.di_pad2));\n\t\tip->i_d.di_crtime = ip->i_d.di_mtime;\n\t}\n\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_u2.if_rdev = rdev;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY)) {\n\t\t\tuint\tdi_flags = 0;\n\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t\t\t} else if (S_ISREG(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOATIME) &&\n\t\t\t    xfs_inherit_noatime)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODUMP) &&\n\t\t\t    xfs_inherit_nodump)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_SYNC) &&\n\t\t\t    xfs_inherit_sync)\n\t\t\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&\n\t\t\t    xfs_inherit_nosymlinks)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&\n\t\t\t    xfs_inherit_nodefrag)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\t\t\tip->i_d.di_flags |= di_flags;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = ip->i_df.if_real_bytes = 0;\n\t\tip->i_df.if_u1.if_extents = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\t/*\n\t * Attribute fork settings for new inode.\n\t */\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_anextents = 0;\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup inode ops and unlock */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ialloc(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*pip,\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\n\tint\t\tokalloc,\n\txfs_buf_t\t**ialloc_context,\n\txfs_inode_t\t**ipp)\n{\n\tstruct xfs_mount *mp = tp->t_mountp;\n\txfs_ino_t\tino;\n\txfs_inode_t\t*ip;\n\tuint\t\tflags;\n\tint\t\terror;\n\tstruct timespec\ttv;\n\n\t/*\n\t * Call the space management code to pick\n\t * the on-disk inode to be allocated.\n\t */\n\terror = xfs_dialloc(tp, pip ? pip->i_ino : 0, mode, okalloc,\n\t\t\t    ialloc_context, &ino);\n\tif (error)\n\t\treturn error;\n\tif (*ialloc_context || ino == NULLFSINO) {\n\t\t*ipp = NULL;\n\t\treturn 0;\n\t}\n\tASSERT(*ialloc_context == NULL);\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively.\n\t * This is because we're setting fields here we need\n\t * to prevent others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE,\n\t\t\t XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\tASSERT(ip != NULL);\n\n\t/*\n\t * We always convert v1 inodes to v2 now - we only support filesystems\n\t * with >= v2 inode capability, so there is no reason for ever leaving\n\t * an inode in v1 format.\n\t */\n\tif (ip->i_d.di_version == 1)\n\t\tip->i_d.di_version = 2;\n\n\tip->i_d.di_mode = mode;\n\tip->i_d.di_onlink = 0;\n\tip->i_d.di_nlink = nlink;\n\tASSERT(ip->i_d.di_nlink == nlink);\n\tip->i_d.di_uid = xfs_kuid_to_uid(current_fsuid());\n\tip->i_d.di_gid = xfs_kgid_to_gid(current_fsgid());\n\txfs_set_projid(ip, prid);\n\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\n\tif (pip && XFS_INHERIT_GID(pip)) {\n\t\tip->i_d.di_gid = pip->i_d.di_gid;\n\t\tif ((pip->i_d.di_mode & S_ISGID) && S_ISDIR(mode)) {\n\t\t\tip->i_d.di_mode |= S_ISGID;\n\t\t}\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif ((irix_sgid_inherit) &&\n\t    (ip->i_d.di_mode & S_ISGID) &&\n\t    (!in_group_p(xfs_gid_to_kgid(ip->i_d.di_gid)))) {\n\t\tip->i_d.di_mode &= ~S_ISGID;\n\t}\n\n\tip->i_d.di_size = 0;\n\tip->i_d.di_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_fs_time(mp->m_super);\n\tip->i_d.di_mtime.t_sec = (__int32_t)tv.tv_sec;\n\tip->i_d.di_mtime.t_nsec = (__int32_t)tv.tv_nsec;\n\tip->i_d.di_atime = ip->i_d.di_mtime;\n\tip->i_d.di_ctime = ip->i_d.di_mtime;\n\n\t/*\n\t * di_gen will have been taken care of in xfs_iread.\n\t */\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (ip->i_d.di_version == 3) {\n\t\tASSERT(ip->i_d.di_ino == ino);\n\t\tASSERT(uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid));\n\t\tip->i_d.di_crc = 0;\n\t\tip->i_d.di_changecount = 1;\n\t\tip->i_d.di_lsn = 0;\n\t\tip->i_d.di_flags2 = 0;\n\t\tmemset(&(ip->i_d.di_pad2[0]), 0, sizeof(ip->i_d.di_pad2));\n\t\tip->i_d.di_crtime = ip->i_d.di_mtime;\n\t}\n\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_u2.if_rdev = rdev;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY)) {\n\t\t\tuint\tdi_flags = 0;\n\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t\t\t} else if (S_ISREG(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOATIME) &&\n\t\t\t    xfs_inherit_noatime)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODUMP) &&\n\t\t\t    xfs_inherit_nodump)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_SYNC) &&\n\t\t\t    xfs_inherit_sync)\n\t\t\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&\n\t\t\t    xfs_inherit_nosymlinks)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&\n\t\t\t    xfs_inherit_nodefrag)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\t\t\tip->i_d.di_flags |= di_flags;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = ip->i_df.if_real_bytes = 0;\n\t\tip->i_df.if_u1.if_extents = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\t/*\n\t * Attribute fork settings for new inode.\n\t */\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_anextents = 0;\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup inode ops and unlock */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_bjoin",
          "args": [
            "tp",
            "ialloc_context"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "115-122",
          "snippet": "void\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "ialloc_context"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&tres",
            "0",
            "0"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "tp->t_ticket"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_free_dqinfo",
          "args": [
            "tp"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "879-887",
          "snippet": "void\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_dup",
          "args": [
            "tp"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "116-152",
          "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_log_count",
          "args": [
            "tp"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_log_res",
          "args": [
            "tp"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_bhold",
          "args": [
            "tp",
            "ialloc_context"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_bhold_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "471-486",
          "snippet": "void\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ialloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "638-826",
    "snippet": "int\nxfs_ialloc(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*pip,\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\n\tint\t\tokalloc,\n\txfs_buf_t\t**ialloc_context,\n\txfs_inode_t\t**ipp)\n{\n\tstruct xfs_mount *mp = tp->t_mountp;\n\txfs_ino_t\tino;\n\txfs_inode_t\t*ip;\n\tuint\t\tflags;\n\tint\t\terror;\n\tstruct timespec\ttv;\n\n\t/*\n\t * Call the space management code to pick\n\t * the on-disk inode to be allocated.\n\t */\n\terror = xfs_dialloc(tp, pip ? pip->i_ino : 0, mode, okalloc,\n\t\t\t    ialloc_context, &ino);\n\tif (error)\n\t\treturn error;\n\tif (*ialloc_context || ino == NULLFSINO) {\n\t\t*ipp = NULL;\n\t\treturn 0;\n\t}\n\tASSERT(*ialloc_context == NULL);\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively.\n\t * This is because we're setting fields here we need\n\t * to prevent others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE,\n\t\t\t XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\tASSERT(ip != NULL);\n\n\t/*\n\t * We always convert v1 inodes to v2 now - we only support filesystems\n\t * with >= v2 inode capability, so there is no reason for ever leaving\n\t * an inode in v1 format.\n\t */\n\tif (ip->i_d.di_version == 1)\n\t\tip->i_d.di_version = 2;\n\n\tip->i_d.di_mode = mode;\n\tip->i_d.di_onlink = 0;\n\tip->i_d.di_nlink = nlink;\n\tASSERT(ip->i_d.di_nlink == nlink);\n\tip->i_d.di_uid = xfs_kuid_to_uid(current_fsuid());\n\tip->i_d.di_gid = xfs_kgid_to_gid(current_fsgid());\n\txfs_set_projid(ip, prid);\n\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\n\tif (pip && XFS_INHERIT_GID(pip)) {\n\t\tip->i_d.di_gid = pip->i_d.di_gid;\n\t\tif ((pip->i_d.di_mode & S_ISGID) && S_ISDIR(mode)) {\n\t\t\tip->i_d.di_mode |= S_ISGID;\n\t\t}\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif ((irix_sgid_inherit) &&\n\t    (ip->i_d.di_mode & S_ISGID) &&\n\t    (!in_group_p(xfs_gid_to_kgid(ip->i_d.di_gid)))) {\n\t\tip->i_d.di_mode &= ~S_ISGID;\n\t}\n\n\tip->i_d.di_size = 0;\n\tip->i_d.di_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_fs_time(mp->m_super);\n\tip->i_d.di_mtime.t_sec = (__int32_t)tv.tv_sec;\n\tip->i_d.di_mtime.t_nsec = (__int32_t)tv.tv_nsec;\n\tip->i_d.di_atime = ip->i_d.di_mtime;\n\tip->i_d.di_ctime = ip->i_d.di_mtime;\n\n\t/*\n\t * di_gen will have been taken care of in xfs_iread.\n\t */\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (ip->i_d.di_version == 3) {\n\t\tASSERT(ip->i_d.di_ino == ino);\n\t\tASSERT(uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid));\n\t\tip->i_d.di_crc = 0;\n\t\tip->i_d.di_changecount = 1;\n\t\tip->i_d.di_lsn = 0;\n\t\tip->i_d.di_flags2 = 0;\n\t\tmemset(&(ip->i_d.di_pad2[0]), 0, sizeof(ip->i_d.di_pad2));\n\t\tip->i_d.di_crtime = ip->i_d.di_mtime;\n\t}\n\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_u2.if_rdev = rdev;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY)) {\n\t\t\tuint\tdi_flags = 0;\n\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t\t\t} else if (S_ISREG(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOATIME) &&\n\t\t\t    xfs_inherit_noatime)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODUMP) &&\n\t\t\t    xfs_inherit_nodump)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_SYNC) &&\n\t\t\t    xfs_inherit_sync)\n\t\t\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&\n\t\t\t    xfs_inherit_nosymlinks)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&\n\t\t\t    xfs_inherit_nodefrag)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\t\t\tip->i_d.di_flags |= di_flags;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = ip->i_df.if_real_bytes = 0;\n\t\tip->i_df.if_u1.if_extents = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\t/*\n\t * Attribute fork settings for new inode.\n\t */\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_anextents = 0;\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup inode ops and unlock */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setup_inode",
          "args": [
            "ip"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "1242-1332",
          "snippet": "void\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key xfs_nondir_ilock_class;",
            "static struct lock_class_key xfs_dir_ilock_class;",
            "STATIC struct",
            "STATIC struct",
            "static const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};",
            "static const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
            "static const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
            "static const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\nSTATIC struct;\nSTATIC struct;\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "flags"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(ip->i_d.di_pad2[0])",
            "0",
            "sizeof(ip->i_d.di_pad2)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&ip->i_d.di_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_ino == ino"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "mp->m_super"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nblocks == 0"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "xfs_gid_to_kgid(ip->i_d.di_gid)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_gid_to_kgid",
          "args": [
            "ip->i_d.di_gid"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_gid_to_kgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "218-221",
          "snippet": "static inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INHERIT_GID",
          "args": [
            "pip"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(ip->i_d.di_pad[0])",
            "0",
            "sizeof(ip->i_d.di_pad)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_set_projid",
          "args": [
            "ip",
            "prid"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "187-193",
          "snippet": "static inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "current_fsgid()"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "current_fsuid()"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink == nlink"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip != NULL"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "tp",
            "ino",
            "XFS_IGET_CREATE",
            "XFS_ILOCK_EXCL",
            "&ip"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*ialloc_context == NULL"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dialloc",
          "args": [
            "tp",
            "pip ? pip->i_ino : 0",
            "mode",
            "okalloc",
            "ialloc_context",
            "&ino"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1299-1435",
          "snippet": "int\nxfs_dialloc(\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tparent,\n\tumode_t\t\t\tmode,\n\tint\t\t\tokalloc,\n\tstruct xfs_buf\t\t**IO_agbp,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*agbp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\tint\t\t\tialloced;\n\tint\t\t\tnoroom = 0;\n\txfs_agnumber_t\t\tstart_agno;\n\tstruct xfs_perag\t*pag;\n\n\tif (*IO_agbp) {\n\t\t/*\n\t\t * If the caller passes in a pointer to the AGI buffer,\n\t\t * continue where we left off before.  In this case, we\n\t\t * know that the allocation group has free inodes.\n\t\t */\n\t\tagbp = *IO_agbp;\n\t\tgoto out_alloc;\n\t}\n\n\t/*\n\t * We do not have an agbp, so select an initial allocation\n\t * group for inode allocation.\n\t */\n\tstart_agno = xfs_ialloc_ag_select(tp, parent, mode, okalloc);\n\tif (start_agno == NULLAGNUMBER) {\n\t\t*inop = NULLFSINO;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we have already hit the ceiling of inode blocks then clear\n\t * okalloc so we scan all available agi structures for a free\n\t * inode.\n\t */\n\tif (mp->m_maxicount &&\n\t    mp->m_sb.sb_icount + mp->m_ialloc_inos > mp->m_maxicount) {\n\t\tnoroom = 1;\n\t\tokalloc = 0;\n\t}\n\n\t/*\n\t * Loop until we find an allocation group that either has free inodes\n\t * or in which we can allocate some inodes.  Iterate through the\n\t * allocation groups upward, wrapping at the end.\n\t */\n\tagno = start_agno;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/*\n\t\t * Do a first racy fast path check if this AG is usable.\n\t\t */\n\t\tif (!pag->pagi_freecount && !okalloc)\n\t\t\tgoto nextag;\n\n\t\t/*\n\t\t * Then read in the AGI buffer and recheck with the AGI buffer\n\t\t * lock held.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\tgoto out_alloc;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag_relse_buffer;\n\n\n\t\terror = xfs_ialloc_ag_alloc(tp, agbp, &ialloced);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\n\t\t\tif (error != -ENOSPC)\n\t\t\t\tgoto out_error;\n\n\t\t\txfs_perag_put(pag);\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ialloced) {\n\t\t\t/*\n\t\t\t * We successfully allocated some inodes, return\n\t\t\t * the current context to the caller so that it\n\t\t\t * can commit the current transaction and call\n\t\t\t * us again where we left off.\n\t\t\t */\n\t\t\tASSERT(pag->pagi_freecount > 0);\n\t\t\txfs_perag_put(pag);\n\n\t\t\t*IO_agbp = agbp;\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\nnextag_relse_buffer:\n\t\txfs_trans_brelse(tp, agbp);\nnextag:\n\t\txfs_perag_put(pag);\n\t\tif (++agno == mp->m_sb.sb_agcount)\n\t\t\tagno = 0;\n\t\tif (agno == start_agno) {\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn noroom ? -ENOSPC : 0;\n\t\t}\n\t}\n\nout_alloc:\n\t*IO_agbp = NULL;\n\treturn xfs_dialloc_ag(tp, agbp, parent, inop);\nout_error:\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dialloc(\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tparent,\n\tumode_t\t\t\tmode,\n\tint\t\t\tokalloc,\n\tstruct xfs_buf\t\t**IO_agbp,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*agbp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\tint\t\t\tialloced;\n\tint\t\t\tnoroom = 0;\n\txfs_agnumber_t\t\tstart_agno;\n\tstruct xfs_perag\t*pag;\n\n\tif (*IO_agbp) {\n\t\t/*\n\t\t * If the caller passes in a pointer to the AGI buffer,\n\t\t * continue where we left off before.  In this case, we\n\t\t * know that the allocation group has free inodes.\n\t\t */\n\t\tagbp = *IO_agbp;\n\t\tgoto out_alloc;\n\t}\n\n\t/*\n\t * We do not have an agbp, so select an initial allocation\n\t * group for inode allocation.\n\t */\n\tstart_agno = xfs_ialloc_ag_select(tp, parent, mode, okalloc);\n\tif (start_agno == NULLAGNUMBER) {\n\t\t*inop = NULLFSINO;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we have already hit the ceiling of inode blocks then clear\n\t * okalloc so we scan all available agi structures for a free\n\t * inode.\n\t */\n\tif (mp->m_maxicount &&\n\t    mp->m_sb.sb_icount + mp->m_ialloc_inos > mp->m_maxicount) {\n\t\tnoroom = 1;\n\t\tokalloc = 0;\n\t}\n\n\t/*\n\t * Loop until we find an allocation group that either has free inodes\n\t * or in which we can allocate some inodes.  Iterate through the\n\t * allocation groups upward, wrapping at the end.\n\t */\n\tagno = start_agno;\n\tfor (;;) {\n\t\tpag = xfs_perag_get(mp, agno);\n\t\tif (!pag->pagi_inodeok) {\n\t\t\txfs_ialloc_next_ag(mp);\n\t\t\tgoto nextag;\n\t\t}\n\n\t\tif (!pag->pagi_init) {\n\t\t\terror = xfs_ialloc_pagi_init(mp, tp, agno);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/*\n\t\t * Do a first racy fast path check if this AG is usable.\n\t\t */\n\t\tif (!pag->pagi_freecount && !okalloc)\n\t\t\tgoto nextag;\n\n\t\t/*\n\t\t * Then read in the AGI buffer and recheck with the AGI buffer\n\t\t * lock held.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (pag->pagi_freecount) {\n\t\t\txfs_perag_put(pag);\n\t\t\tgoto out_alloc;\n\t\t}\n\n\t\tif (!okalloc)\n\t\t\tgoto nextag_relse_buffer;\n\n\n\t\terror = xfs_ialloc_ag_alloc(tp, agbp, &ialloced);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\n\t\t\tif (error != -ENOSPC)\n\t\t\t\tgoto out_error;\n\n\t\t\txfs_perag_put(pag);\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ialloced) {\n\t\t\t/*\n\t\t\t * We successfully allocated some inodes, return\n\t\t\t * the current context to the caller so that it\n\t\t\t * can commit the current transaction and call\n\t\t\t * us again where we left off.\n\t\t\t */\n\t\t\tASSERT(pag->pagi_freecount > 0);\n\t\t\txfs_perag_put(pag);\n\n\t\t\t*IO_agbp = agbp;\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn 0;\n\t\t}\n\nnextag_relse_buffer:\n\t\txfs_trans_brelse(tp, agbp);\nnextag:\n\t\txfs_perag_put(pag);\n\t\tif (++agno == mp->m_sb.sb_agcount)\n\t\t\tagno = 0;\n\t\tif (agno == start_agno) {\n\t\t\t*inop = NULLFSINO;\n\t\t\treturn noroom ? -ENOSPC : 0;\n\t\t}\n\t}\n\nout_alloc:\n\t*IO_agbp = NULL;\n\treturn xfs_dialloc_ag(tp, agbp, parent, inop);\nout_error:\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ialloc(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*pip,\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\n\tint\t\tokalloc,\n\txfs_buf_t\t**ialloc_context,\n\txfs_inode_t\t**ipp)\n{\n\tstruct xfs_mount *mp = tp->t_mountp;\n\txfs_ino_t\tino;\n\txfs_inode_t\t*ip;\n\tuint\t\tflags;\n\tint\t\terror;\n\tstruct timespec\ttv;\n\n\t/*\n\t * Call the space management code to pick\n\t * the on-disk inode to be allocated.\n\t */\n\terror = xfs_dialloc(tp, pip ? pip->i_ino : 0, mode, okalloc,\n\t\t\t    ialloc_context, &ino);\n\tif (error)\n\t\treturn error;\n\tif (*ialloc_context || ino == NULLFSINO) {\n\t\t*ipp = NULL;\n\t\treturn 0;\n\t}\n\tASSERT(*ialloc_context == NULL);\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively.\n\t * This is because we're setting fields here we need\n\t * to prevent others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE,\n\t\t\t XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\tASSERT(ip != NULL);\n\n\t/*\n\t * We always convert v1 inodes to v2 now - we only support filesystems\n\t * with >= v2 inode capability, so there is no reason for ever leaving\n\t * an inode in v1 format.\n\t */\n\tif (ip->i_d.di_version == 1)\n\t\tip->i_d.di_version = 2;\n\n\tip->i_d.di_mode = mode;\n\tip->i_d.di_onlink = 0;\n\tip->i_d.di_nlink = nlink;\n\tASSERT(ip->i_d.di_nlink == nlink);\n\tip->i_d.di_uid = xfs_kuid_to_uid(current_fsuid());\n\tip->i_d.di_gid = xfs_kgid_to_gid(current_fsgid());\n\txfs_set_projid(ip, prid);\n\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\n\tif (pip && XFS_INHERIT_GID(pip)) {\n\t\tip->i_d.di_gid = pip->i_d.di_gid;\n\t\tif ((pip->i_d.di_mode & S_ISGID) && S_ISDIR(mode)) {\n\t\t\tip->i_d.di_mode |= S_ISGID;\n\t\t}\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif ((irix_sgid_inherit) &&\n\t    (ip->i_d.di_mode & S_ISGID) &&\n\t    (!in_group_p(xfs_gid_to_kgid(ip->i_d.di_gid)))) {\n\t\tip->i_d.di_mode &= ~S_ISGID;\n\t}\n\n\tip->i_d.di_size = 0;\n\tip->i_d.di_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_fs_time(mp->m_super);\n\tip->i_d.di_mtime.t_sec = (__int32_t)tv.tv_sec;\n\tip->i_d.di_mtime.t_nsec = (__int32_t)tv.tv_nsec;\n\tip->i_d.di_atime = ip->i_d.di_mtime;\n\tip->i_d.di_ctime = ip->i_d.di_mtime;\n\n\t/*\n\t * di_gen will have been taken care of in xfs_iread.\n\t */\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (ip->i_d.di_version == 3) {\n\t\tASSERT(ip->i_d.di_ino == ino);\n\t\tASSERT(uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid));\n\t\tip->i_d.di_crc = 0;\n\t\tip->i_d.di_changecount = 1;\n\t\tip->i_d.di_lsn = 0;\n\t\tip->i_d.di_flags2 = 0;\n\t\tmemset(&(ip->i_d.di_pad2[0]), 0, sizeof(ip->i_d.di_pad2));\n\t\tip->i_d.di_crtime = ip->i_d.di_mtime;\n\t}\n\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_u2.if_rdev = rdev;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY)) {\n\t\t\tuint\tdi_flags = 0;\n\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t\t\t} else if (S_ISREG(mode)) {\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t\t\t\t\tip->i_d.di_extsize = pip->i_d.di_extsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOATIME) &&\n\t\t\t    xfs_inherit_noatime)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODUMP) &&\n\t\t\t    xfs_inherit_nodump)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_SYNC) &&\n\t\t\t    xfs_inherit_sync)\n\t\t\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&\n\t\t\t    xfs_inherit_nosymlinks)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\t\tif ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&\n\t\t\t    xfs_inherit_nodefrag)\n\t\t\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\t\t\tif (pip->i_d.di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\t\t\tip->i_d.di_flags |= di_flags;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_d.di_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = ip->i_df.if_real_bytes = 0;\n\t\tip->i_df.if_u1.if_extents = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\t/*\n\t * Attribute fork settings for new inode.\n\t */\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tip->i_d.di_anextents = 0;\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup inode ops and unlock */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "570-605",
    "snippet": "int\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ci_name->name"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "dp->i_mount",
            "NULL",
            "inum",
            "0",
            "0",
            "ipp"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "lock_mode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_lookup",
          "args": [
            "NULL",
            "dp",
            "name",
            "&inum",
            "ci_name"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "354-424",
          "snippet": "int\nxfs_dir_lookup(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\t*inum,\t\t/* out: inode number */\n\tstruct xfs_name *ci_name)\t/* out: actual name if CI match */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_lookup);\n\n\t/*\n\t * We need to use KM_NOFS here so that lockdep will not throw false\n\t * positive deadlock warnings on a non-transactional lookup path. It is\n\t * safe to recurse into inode recalim in that case, but lockdep can't\n\t * easily be taught about it. Hence KM_NOFS avoids having to add more\n\t * lockdep Doing this avoids having to add a bunch of lockdep class\n\t * annotations into the reclaim path for the ilock.\n\t */\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->dp = dp;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\tif (ci_name)\n\t\targs->op_flags |= XFS_DA_OP_CILOOKUP;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_lookup(args);\n\telse\n\t\trval = xfs_dir2_node_lookup(args);\n\nout_check_rval:\n\tif (rval == -EEXIST)\n\t\trval = 0;\n\tif (!rval) {\n\t\t*inum = args->inumber;\n\t\tif (ci_name) {\n\t\t\tci_name->name = args->value;\n\t\t\tci_name->len = args->valuelen;\n\t\t}\n\t}\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_lookup(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\t*inum,\t\t/* out: inode number */\n\tstruct xfs_name *ci_name)\t/* out: actual name if CI match */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_lookup);\n\n\t/*\n\t * We need to use KM_NOFS here so that lockdep will not throw false\n\t * positive deadlock warnings on a non-transactional lookup path. It is\n\t * safe to recurse into inode recalim in that case, but lockdep can't\n\t * easily be taught about it. Hence KM_NOFS avoids having to add more\n\t * lockdep Doing this avoids having to add a bunch of lockdep class\n\t * annotations into the reclaim path for the ilock.\n\t */\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->dp = dp;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\tif (ci_name)\n\t\targs->op_flags |= XFS_DA_OP_CILOOKUP;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_lookup(args);\n\telse\n\t\trval = xfs_dir2_node_lookup(args);\n\nout_check_rval:\n\tif (rval == -EEXIST)\n\t\trval = 0;\n\tif (!rval) {\n\t\t*inum = args->inumber;\n\t\tif (ci_name) {\n\t\t\tci_name->name = args->value;\n\t\t\tci_name->len = args->valuelen;\n\t\t}\n\t}\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "dp"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_lookup",
          "args": [
            "dp",
            "name"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dic2xflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "556-562",
    "snippet": "uint\nxfs_dic2xflags(\n\txfs_dinode_t\t\t*dip)\n{\n\treturn _xfs_dic2xflags(be16_to_cpu(dip->di_flags)) |\n\t\t\t\t(XFS_DFORK_Q(dip) ? XFS_XFLAG_HASATTR : 0);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_DFORK_Q",
          "args": [
            "dip"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_dic2xflags",
          "args": [
            "be16_to_cpu(dip->di_flags)"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_dic2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "506-544",
          "snippet": "STATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_flags"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_dic2xflags(\n\txfs_dinode_t\t\t*dip)\n{\n\treturn _xfs_dic2xflags(be16_to_cpu(dip->di_flags)) |\n\t\t\t\t(XFS_DFORK_Q(dip) ? XFS_XFLAG_HASATTR : 0);\n}"
  },
  {
    "function_name": "xfs_ip2xflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "546-554",
    "snippet": "uint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_dic2xflags",
          "args": [
            "dic->di_flags"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_dic2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "506-544",
          "snippet": "STATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nuint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}"
  },
  {
    "function_name": "_xfs_dic2xflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "506-544",
    "snippet": "STATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC uint\n_xfs_dic2xflags(\n\t__uint16_t\t\tdi_flags)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_ANY) {\n\t\tif (di_flags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= XFS_XFLAG_REALTIME;\n\t\tif (di_flags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= XFS_XFLAG_PREALLOC;\n\t\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= XFS_XFLAG_IMMUTABLE;\n\t\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= XFS_XFLAG_APPEND;\n\t\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= XFS_XFLAG_SYNC;\n\t\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= XFS_XFLAG_NOATIME;\n\t\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= XFS_XFLAG_NODUMP;\n\t\tif (di_flags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= XFS_XFLAG_RTINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= XFS_XFLAG_PROJINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= XFS_XFLAG_NOSYMLINKS;\n\t\tif (di_flags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= XFS_XFLAG_EXTSIZE;\n\t\tif (di_flags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= XFS_XFLAG_EXTSZINHERIT;\n\t\tif (di_flags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= XFS_XFLAG_NODEFRAG;\n\t\tif (di_flags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= XFS_XFLAG_FILESTREAM;\n\t}\n\n\treturn flags;\n}"
  },
  {
    "function_name": "__xfs_iflock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "490-504",
    "snippet": "void\n__xfs_iflock(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IFLOCK_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IFLOCK_BIT);\n\n\tdo {\n\t\tprepare_to_wait_exclusive(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_isiflocked(ip))\n\t\t\tio_schedule();\n\t} while (!xfs_iflock_nowait(ip));\n\n\tfinish_wait(wq, &wait.wait);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait.wait"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflock_nowait",
          "args": [
            "ip"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "234-237",
          "snippet": "static inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isiflocked",
          "args": [
            "ip"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isiflocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "252-255",
          "snippet": "static inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait_exclusive",
          "args": [
            "wq",
            "&wait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&ip->i_flags",
            "__XFS_IFLOCK_BIT"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&ip->i_flags",
            "__XFS_IFLOCK_BIT"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\n__xfs_iflock(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IFLOCK_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IFLOCK_BIT);\n\n\tdo {\n\t\tprepare_to_wait_exclusive(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_isiflocked(ip))\n\t\t\tio_schedule();\n\t} while (!xfs_iflock_nowait(ip));\n\n\tfinish_wait(wq, &wait.wait);\n}"
  },
  {
    "function_name": "xfs_lock_two_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "448-487",
    "snippet": "void\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip1",
            "xfs_lock_inumorder(lock_mode, 1)"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_lock_inumorder",
          "args": [
            "lock_mode",
            "1"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_inumorder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "320-329",
          "snippet": "static inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip0",
            "lock_mode"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip1",
            "xfs_lock_inumorder(lock_mode, 1)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip0->i_ino != ip1->i_ino"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}"
  },
  {
    "function_name": "xfs_lock_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "342-440",
    "snippet": "void\nxfs_lock_inodes(\n\txfs_inode_t\t**ips,\n\tint\t\tinodes,\n\tuint\t\tlock_mode)\n{\n\tint\t\tattempts = 0, i, j, try_lock;\n\txfs_log_item_t\t*lp;\n\n\tASSERT(ips && (inodes >= 2)); /* we need at least two */\n\n\ttry_lock = 0;\n\ti = 0;\n\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\n\t\tif (i && (ips[i] == ips[i-1]))\t/* Already locked */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If try_lock is not set yet, make sure all locked inodes\n\t\t * are not in the AIL.\n\t\t * If any are, set try_lock to be used later.\n\t\t */\n\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = (xfs_log_item_t *)ips[j]->i_itemp;\n\t\t\t\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\t\t\t\ttry_lock++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If any of the previous locks we have locked is in the AIL,\n\t\t * we must TRY to get the second and subsequent locks. If\n\t\t * we can't get any, we must release all we have\n\t\t * and try again.\n\t\t */\n\n\t\tif (try_lock) {\n\t\t\t/* try_lock must be 0 if i is 0. */\n\t\t\t/*\n\t\t\t * try_lock means we have an inode locked\n\t\t\t * that is in the AIL.\n\t\t\t */\n\t\t\tASSERT(i != 0);\n\t\t\tif (!xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i))) {\n\t\t\t\tattempts++;\n\n\t\t\t\t/*\n\t\t\t\t * Unlock all previous guys and try again.\n\t\t\t\t * xfs_iunlock will try to push the tail\n\t\t\t\t * if the inode is in the AIL.\n\t\t\t\t */\n\n\t\t\t\tfor(j = i - 1; j >= 0; j--) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check to see if we've already\n\t\t\t\t\t * unlocked this one.\n\t\t\t\t\t * Not the first one going back,\n\t\t\t\t\t * and the inode ptr is the same.\n\t\t\t\t\t */\n\t\t\t\t\tif ((j != (i - 1)) && ips[j] ==\n\t\t\t\t\t\t\t\tips[j+1])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t\t\t}\n\n\t\t\t\tif ((attempts % 5) == 0) {\n\t\t\t\t\tdelay(1); /* Don't just spin the CPU */\n#ifdef DEBUG\n\t\t\t\t\txfs_lock_delays++;\n#endif\n\t\t\t\t}\n\t\t\t\ti = 0;\n\t\t\t\ttry_lock = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tif (attempts) {\n\t\tif (attempts < 5) xfs_small_retries++;\n\t\telse if (attempts < 100) xfs_middle_retries++;\n\t\telse xfs_lots_retries++;\n\t} else {\n\t\txfs_locked_n++;\n\t}\n#endif\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ips[i]",
            "xfs_lock_inumorder(lock_mode, i)"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_lock_inumorder",
          "args": [
            "lock_mode",
            "i"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_inumorder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "320-329",
          "snippet": "static inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ips[j]",
            "lock_mode"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ips[i]",
            "xfs_lock_inumorder(lock_mode, i)"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i != 0"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ips[i]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ips && (inodes >= 2)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_inodes(\n\txfs_inode_t\t**ips,\n\tint\t\tinodes,\n\tuint\t\tlock_mode)\n{\n\tint\t\tattempts = 0, i, j, try_lock;\n\txfs_log_item_t\t*lp;\n\n\tASSERT(ips && (inodes >= 2)); /* we need at least two */\n\n\ttry_lock = 0;\n\ti = 0;\n\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\n\t\tif (i && (ips[i] == ips[i-1]))\t/* Already locked */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If try_lock is not set yet, make sure all locked inodes\n\t\t * are not in the AIL.\n\t\t * If any are, set try_lock to be used later.\n\t\t */\n\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = (xfs_log_item_t *)ips[j]->i_itemp;\n\t\t\t\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\t\t\t\ttry_lock++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If any of the previous locks we have locked is in the AIL,\n\t\t * we must TRY to get the second and subsequent locks. If\n\t\t * we can't get any, we must release all we have\n\t\t * and try again.\n\t\t */\n\n\t\tif (try_lock) {\n\t\t\t/* try_lock must be 0 if i is 0. */\n\t\t\t/*\n\t\t\t * try_lock means we have an inode locked\n\t\t\t * that is in the AIL.\n\t\t\t */\n\t\t\tASSERT(i != 0);\n\t\t\tif (!xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i))) {\n\t\t\t\tattempts++;\n\n\t\t\t\t/*\n\t\t\t\t * Unlock all previous guys and try again.\n\t\t\t\t * xfs_iunlock will try to push the tail\n\t\t\t\t * if the inode is in the AIL.\n\t\t\t\t */\n\n\t\t\t\tfor(j = i - 1; j >= 0; j--) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check to see if we've already\n\t\t\t\t\t * unlocked this one.\n\t\t\t\t\t * Not the first one going back,\n\t\t\t\t\t * and the inode ptr is the same.\n\t\t\t\t\t */\n\t\t\t\t\tif ((j != (i - 1)) && ips[j] ==\n\t\t\t\t\t\t\t\tips[j+1])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t\t\t}\n\n\t\t\t\tif ((attempts % 5) == 0) {\n\t\t\t\t\tdelay(1); /* Don't just spin the CPU */\n#ifdef DEBUG\n\t\t\t\t\txfs_lock_delays++;\n#endif\n\t\t\t\t}\n\t\t\t\ti = 0;\n\t\t\t\ttry_lock = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tif (attempts) {\n\t\tif (attempts < 5) xfs_small_retries++;\n\t\telse if (attempts < 100) xfs_middle_retries++;\n\t\telse xfs_lots_retries++;\n\t} else {\n\t\txfs_locked_n++;\n\t}\n#endif\n}"
  },
  {
    "function_name": "xfs_lock_inumorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "320-329",
    "snippet": "static inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nstatic inline int\nxfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\n\t\tlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\n\n\treturn lock_mode;\n}"
  },
  {
    "function_name": "xfs_isilocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "286-305",
    "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&ip->i_iolock.mr_lock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&ip->i_lock.mr_lock"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ilock_demote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "269-283",
    "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_ilock_demote",
          "args": [
            "ip",
            "lock_flags",
            "_RET_IP_"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mrdemote",
          "args": [
            "&ip->i_iolock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "mrdemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "82-88",
          "snippet": "static inline void mrdemote(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tdowngrade_write(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrdemote(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tdowngrade_write(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_iunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "235-263",
    "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_iunlock",
          "args": [
            "ip",
            "lock_flags",
            "_RET_IP_"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mrunlock_shared",
          "args": [
            "&ip->i_lock"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "mrunlock_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "77-80",
          "snippet": "static inline void mrunlock_shared(mrlock_t *mrp)\n{\n\tup_read(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrunlock_shared(mrlock_t *mrp)\n{\n\tup_read(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mrunlock_excl",
          "args": [
            "&ip->i_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "mrunlock_excl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "69-75",
          "snippet": "static inline void mrunlock_excl(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tup_write(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrunlock_excl(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tup_write(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lock_flags != 0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_ilock_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "180-221",
    "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mrunlock_shared",
          "args": [
            "&ip->i_iolock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "mrunlock_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "77-80",
          "snippet": "static inline void mrunlock_shared(mrlock_t *mrp)\n{\n\tup_read(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrunlock_shared(mrlock_t *mrp)\n{\n\tup_read(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mrunlock_excl",
          "args": [
            "&ip->i_iolock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "mrunlock_excl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "69-75",
          "snippet": "static inline void mrunlock_excl(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tup_write(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrunlock_excl(mrlock_t *mrp)\n{\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 0;\n#endif\n\tup_write(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mrtryaccess",
          "args": [
            "&ip->i_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "mrtryaccess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "54-57",
          "snippet": "static inline int mrtryaccess(mrlock_t *mrp)\n{\n\treturn down_read_trylock(&mrp->mr_lock);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline int mrtryaccess(mrlock_t *mrp)\n{\n\treturn down_read_trylock(&mrp->mr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mrtryupdate",
          "args": [
            "&ip->i_lock"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "mrtryupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "59-67",
          "snippet": "static inline int mrtryupdate(mrlock_t *mrp)\n{\n\tif (!down_write_trylock(&mrp->mr_lock))\n\t\treturn 0;\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 1;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline int mrtryupdate(mrlock_t *mrp)\n{\n\tif (!down_write_trylock(&mrp->mr_lock))\n\t\treturn 0;\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 1;\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ilock_nowait",
          "args": [
            "ip",
            "lock_flags",
            "_RET_IP_"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ilock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "139-166",
    "snippet": "void\nxfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_iolock, XFS_IOLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_iolock, XFS_IOLOCK_DEP(lock_flags));\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mraccess_nested",
          "args": [
            "&ip->i_lock",
            "XFS_ILOCK_DEP(lock_flags)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "mraccess_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "41-44",
          "snippet": "static inline void mraccess_nested(mrlock_t *mrp, int subclass)\n{\n\tdown_read_nested(&mrp->mr_lock, subclass);\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mraccess_nested(mrlock_t *mrp, int subclass)\n{\n\tdown_read_nested(&mrp->mr_lock, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ILOCK_DEP",
          "args": [
            "lock_flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mrupdate_nested",
          "args": [
            "&ip->i_lock",
            "XFS_ILOCK_DEP(lock_flags)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "mrupdate_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/mrlock.h",
          "lines": "46-52",
          "snippet": "static inline void mrupdate_nested(mrlock_t *mrp, int subclass)\n{\n\tdown_write_nested(&mrp->mr_lock, subclass);\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 1;\n#endif\n}",
          "includes": [
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n\nstatic inline void mrupdate_nested(mrlock_t *mrp, int subclass)\n{\n\tdown_write_nested(&mrp->mr_lock, subclass);\n#if defined(DEBUG) || defined(XFS_WARN)\n\tmrp->mr_writer = 1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ILOCK_DEP",
          "args": [
            "lock_flags"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IOLOCK_DEP",
          "args": [
            "lock_flags"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IOLOCK_DEP",
          "args": [
            "lock_flags"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ilock",
          "args": [
            "ip",
            "lock_flags",
            "_RET_IP_"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_iolock, XFS_IOLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_iolock, XFS_IOLOCK_DEP(lock_flags));\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}"
  },
  {
    "function_name": "xfs_ilock_attr_map_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "106-117",
    "snippet": "uint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "lock_mode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
  },
  {
    "function_name": "xfs_ilock_data_map_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "93-104",
    "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "lock_mode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
  },
  {
    "function_name": "xfs_get_extsz_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
    "lines": "67-76",
    "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
  }
]