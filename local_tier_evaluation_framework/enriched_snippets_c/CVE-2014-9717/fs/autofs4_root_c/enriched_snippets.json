[
  {
    "function_name": "autofs4_root_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "909-922",
    "snippet": "static long autofs4_root_compat_ioctl(struct file *filp,\n\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (cmd == AUTOFS_IOC_READY || cmd == AUTOFS_IOC_FAIL)\n\t\tret = autofs4_root_ioctl_unlocked(inode, filp, cmd, arg);\n\telse\n\t\tret = autofs4_root_ioctl_unlocked(inode, filp, cmd,\n\t\t\t(unsigned long)compat_ptr(arg));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
      "static int autofs4_dir_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_root_ioctl_unlocked",
          "args": [
            "inode",
            "filp",
            "cmd",
            "(unsigned long)compat_ptr(arg)"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_root_ioctl_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "851-899",
          "snippet": "static int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
            "static int autofs4_dir_open(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\n\nstatic int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\n\nstatic long autofs4_root_compat_ioctl(struct file *filp,\n\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (cmd == AUTOFS_IOC_READY || cmd == AUTOFS_IOC_FAIL)\n\t\tret = autofs4_root_ioctl_unlocked(inode, filp, cmd, arg);\n\telse\n\t\tret = autofs4_root_ioctl_unlocked(inode, filp, cmd,\n\t\t\t(unsigned long)compat_ptr(arg));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "autofs4_root_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "901-906",
    "snippet": "static long autofs4_root_ioctl(struct file *filp,\n\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\treturn autofs4_root_ioctl_unlocked(inode, filp, cmd, arg);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
      "static int autofs4_dir_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_root_ioctl_unlocked",
          "args": [
            "inode",
            "filp",
            "cmd",
            "arg"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_root_ioctl_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "851-899",
          "snippet": "static int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
            "static int autofs4_dir_open(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\n\nstatic int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\n\nstatic long autofs4_root_ioctl(struct file *filp,\n\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\treturn autofs4_root_ioctl_unlocked(inode, filp, cmd, arg);\n}"
  },
  {
    "function_name": "autofs4_root_ioctl_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "851-899",
    "snippet": "static int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
      "static int autofs4_dir_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_expire_multi",
          "args": [
            "inode->i_sb",
            "filp->f_path.mnt",
            "sbi",
            "p"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_multi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "593-602",
          "snippet": "int autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\tstruct autofs_sb_info *sbi, int __user *arg)\n{\n\tint do_now = 0;\n\n\tif (arg && get_user(do_now, arg))\n\t\treturn -EFAULT;\n\n\treturn autofs4_do_expire_multi(sb, mnt, sbi, do_now);\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nint autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\tstruct autofs_sb_info *sbi, int __user *arg)\n{\n\tint do_now = 0;\n\n\tif (arg && get_user(do_now, arg))\n\t\treturn -EFAULT;\n\n\treturn autofs4_do_expire_multi(sb, mnt, sbi, do_now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_expire_run",
          "args": [
            "inode->i_sb",
            "filp->f_path.mnt",
            "sbi",
            "p"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "524-559",
          "snippet": "int autofs4_expire_run(struct super_block *sb,\n\t\t      struct vfsmount *mnt,\n\t\t      struct autofs_sb_info *sbi,\n\t\t      struct autofs_packet_expire __user *pkt_p)\n{\n\tstruct autofs_packet_expire pkt;\n\tstruct autofs_info *ino;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tmemset(&pkt,0,sizeof pkt);\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = autofs_ptype_expire;\n\n\tif ((dentry = autofs4_expire_indirect(sb, mnt, sbi, 0)) == NULL)\n\t\treturn -EAGAIN;\n\n\tpkt.len = dentry->d_name.len;\n\tmemcpy(pkt.name, dentry->d_name.name, pkt.len);\n\tpkt.name[pkt.len] = '\\0';\n\tdput(dentry);\n\n\tif ( copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)) )\n\t\tret = -EFAULT;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(dentry);\n\t/* avoid rapid-fire expire attempts if expiry fails */\n\tino->last_used = now;\n\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\tcomplete_all(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nint autofs4_expire_run(struct super_block *sb,\n\t\t      struct vfsmount *mnt,\n\t\t      struct autofs_sb_info *sbi,\n\t\t      struct autofs_packet_expire __user *pkt_p)\n{\n\tstruct autofs_packet_expire pkt;\n\tstruct autofs_info *ino;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tmemset(&pkt,0,sizeof pkt);\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = autofs_ptype_expire;\n\n\tif ((dentry = autofs4_expire_indirect(sb, mnt, sbi, 0)) == NULL)\n\t\treturn -EAGAIN;\n\n\tpkt.len = dentry->d_name.len;\n\tmemcpy(pkt.name, dentry->d_name.name, pkt.len);\n\tpkt.name[pkt.len] = '\\0';\n\tdput(dentry);\n\n\tif ( copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)) )\n\t\tret = -EFAULT;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(dentry);\n\t/* avoid rapid-fire expire attempts if expiry fails */\n\tino->last_used = now;\n\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\tcomplete_all(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_ask_umount",
          "args": [
            "filp->f_path.mnt",
            "p"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_ask_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "822-834",
          "snippet": "static inline int autofs4_ask_umount(struct vfsmount *mnt, int __user *p)\n{\n\tint status = 0;\n\n\tif (may_umount(mnt))\n\t\tstatus = 1;\n\n\tDPRINTK(\"returning %d\", status);\n\n\tstatus = put_user(status, p);\n\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_ask_umount(struct vfsmount *mnt, int __user *p)\n{\n\tint status = 0;\n\n\tif (may_umount(mnt))\n\t\tstatus = 1;\n\n\tDPRINTK(\"returning %d\", status);\n\n\tstatus = put_user(status, p);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_compat_get_set_timeout",
          "args": [
            "sbi",
            "p"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_compat_get_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "770-786",
          "snippet": "static inline int autofs4_compat_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t compat_ulong_t __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > UINT_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_compat_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t compat_ulong_t __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > UINT_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_set_timeout",
          "args": [
            "sbi",
            "p"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "789-805",
          "snippet": "static inline int autofs4_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t unsigned long __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > ULONG_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t unsigned long __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > ULONG_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_protosubver",
          "args": [
            "sbi",
            "p"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_protosubver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "814-817",
          "snippet": "static inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->sub_version, p);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->sub_version, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_protover",
          "args": [
            "sbi",
            "p"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_protover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "808-811",
          "snippet": "static inline int autofs4_get_protover(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->version, p);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_protover(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->version, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_catatonic_mode",
          "args": [
            "sbi"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_catatonic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "27-55",
          "snippet": "void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nvoid autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_wait_release",
          "args": [
            "sbi",
            "(autofs_wqt_t)arg",
            "-ENOENT"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "AUTOFS_IOC_FIRST"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "cmd"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "AUTOFS_IOC_FIRST"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "cmd"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\"",
            "cmd",
            "arg",
            "sbi",
            "task_pgrp_nr(current)"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_nr",
          "args": [
            "current"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "inode->i_sb"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\n\nstatic int autofs4_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tDPRINTK(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\",\n\t\tcmd,arg,sbi,task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\t\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t\n\tswitch(cmd) {\n\tcase AUTOFS_IOC_READY:\t/* Wait queue: go ahead and retry */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);\n\tcase AUTOFS_IOC_FAIL:\t/* Wait queue: fail with ENOENT */\n\t\treturn autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);\n\tcase AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */\n\t\tautofs4_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER: /* Get protocol version */\n\t\treturn autofs4_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER: /* Get protocol sub version */\n\t\treturn autofs4_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs4_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs4_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs4_ask_umount(filp->f_path.mnt, p);\n\n\t/* return a single thing to expire */\n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);\n\t/* same as above, but can send multiple expires through pipe */\n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
  },
  {
    "function_name": "is_autofs4_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "840-845",
    "snippet": "int is_autofs4_dentry(struct dentry *dentry)\n{\n\treturn dentry && dentry->d_inode &&\n\t\tdentry->d_op == &autofs4_dentry_operations &&\n\t\tdentry->d_fsdata != NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);",
      "const struct dentry_operations autofs4_dentry_operations = {\n\t.d_automount\t= autofs4_d_automount,\n\t.d_manage\t= autofs4_d_manage,\n\t.d_release\t= autofs4_dentry_release,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\nconst struct dentry_operations autofs4_dentry_operations = {\n\t.d_automount\t= autofs4_d_automount,\n\t.d_manage\t= autofs4_d_manage,\n\t.d_release\t= autofs4_dentry_release,\n};\n\nint is_autofs4_dentry(struct dentry *dentry)\n{\n\treturn dentry && dentry->d_inode &&\n\t\tdentry->d_op == &autofs4_dentry_operations &&\n\t\tdentry->d_fsdata != NULL;\n}"
  },
  {
    "function_name": "autofs4_ask_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "822-834",
    "snippet": "static inline int autofs4_ask_umount(struct vfsmount *mnt, int __user *p)\n{\n\tint status = 0;\n\n\tif (may_umount(mnt))\n\t\tstatus = 1;\n\n\tDPRINTK(\"returning %d\", status);\n\n\tstatus = put_user(status, p);\n\n\treturn status;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "status",
            "p"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"returning %d\"",
            "status"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_umount",
          "args": [
            "mnt"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "may_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1304-1314",
          "snippet": "int may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_ask_umount(struct vfsmount *mnt, int __user *p)\n{\n\tint status = 0;\n\n\tif (may_umount(mnt))\n\t\tstatus = 1;\n\n\tDPRINTK(\"returning %d\", status);\n\n\tstatus = put_user(status, p);\n\n\treturn status;\n}"
  },
  {
    "function_name": "autofs4_get_protosubver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "814-817",
    "snippet": "static inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->sub_version, p);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sbi->sub_version",
            "p"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->sub_version, p);\n}"
  },
  {
    "function_name": "autofs4_get_protover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "808-811",
    "snippet": "static inline int autofs4_get_protover(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->version, p);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sbi->version",
            "p"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_protover(struct autofs_sb_info *sbi, int __user *p)\n{\n\treturn put_user(sbi->version, p);\n}"
  },
  {
    "function_name": "autofs4_get_set_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "789-805",
    "snippet": "static inline int autofs4_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t unsigned long __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > ULONG_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sbi->exp_timeout/HZ",
            "p"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "ntimeout",
            "p"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t unsigned long __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > ULONG_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_compat_get_set_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "770-786",
    "snippet": "static inline int autofs4_compat_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t compat_ulong_t __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > UINT_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sbi->exp_timeout/HZ",
            "p"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "ntimeout",
            "p"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic inline int autofs4_compat_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t compat_ulong_t __user *p)\n{\n\tint rv;\n\tunsigned long ntimeout;\n\n\tif ((rv = get_user(ntimeout, p)) ||\n\t     (rv = put_user(sbi->exp_timeout/HZ, p)))\n\t\treturn rv;\n\n\tif (ntimeout > UINT_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_dir_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "731-766",
    "snippet": "static int autofs4_dir_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tDPRINTK(\"dentry %p, creating %pd\", dentry, dentry);\n\n\tBUG_ON(!ino);\n\n\tautofs4_clean_ino(ino);\n\n\tautofs4_del_active(dentry);\n\n\tinode = autofs4_get_inode(dir->i_sb, S_IFDIR | 0555);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\td_add(dentry, inode);\n\n\tif (sbi->version < 5)\n\t\tautofs_set_leaf_automount_flags(dentry);\n\n\tdget(dentry);\n\tatomic_inc(&ino->count);\n\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\tif (p_ino && !IS_ROOT(dentry))\n\t\tatomic_inc(&p_ino->count);\n\tinc_nlink(dir);\n\tdir->i_mtime = CURRENT_TIME;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static int autofs4_dir_mkdir(struct inode *,struct dentry *,umode_t);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&p_ino->count"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry->d_parent"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ino->count"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_set_leaf_automount_flags",
          "args": [
            "dentry"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_set_leaf_automount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "652-668",
          "snippet": "static void autofs_set_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t/* root and dentrys in the root are already handled */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_set_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tmanaged_dentry_clear_managed(parent);\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs_set_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t/* root and dentrys in the root are already handled */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_set_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tmanaged_dentry_clear_managed(parent);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_inode",
          "args": [
            "dir->i_sb",
            "S_IFDIR | 0555"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "346-370",
          "snippet": "struct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_del_active",
          "args": [
            "dentry"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_del_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "90-104",
          "snippet": "static void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_clean_ino",
          "args": [
            "ino"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_clean_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "37-42",
          "snippet": "void autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ino"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry %p, creating %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dir->i_sb"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic int autofs4_dir_mkdir(struct inode *,struct dentry *,umode_t);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_dir_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tDPRINTK(\"dentry %p, creating %pd\", dentry, dentry);\n\n\tBUG_ON(!ino);\n\n\tautofs4_clean_ino(ino);\n\n\tautofs4_del_active(dentry);\n\n\tinode = autofs4_get_inode(dir->i_sb, S_IFDIR | 0555);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\td_add(dentry, inode);\n\n\tif (sbi->version < 5)\n\t\tautofs_set_leaf_automount_flags(dentry);\n\n\tdget(dentry);\n\tatomic_inc(&ino->count);\n\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\tif (p_ino && !IS_ROOT(dentry))\n\t\tatomic_inc(&p_ino->count);\n\tinc_nlink(dir);\n\tdir->i_mtime = CURRENT_TIME;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_dir_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "693-729",
    "snippet": "static int autofs4_dir_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\t\n\tDPRINTK(\"dentry %p, removing %pd\", dentry, dentry);\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tspin_lock(&sbi->lookup_lock);\n\tif (!simple_empty(dentry)) {\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\treturn -ENOTEMPTY;\n\t}\n\t__autofs4_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tif (sbi->version < 5)\n\t\tautofs_clear_leaf_automount_flags(dentry);\n\n\tif (atomic_dec_and_test(&ino->count)) {\n\t\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\t\tif (p_ino && dentry->d_parent != dentry)\n\t\t\tatomic_dec(&p_ino->count);\n\t}\n\tdput(ino->dentry);\n\tdentry->d_inode->i_size = 0;\n\tclear_nlink(dentry->d_inode);\n\n\tif (dir->i_nlink)\n\t\tdrop_nlink(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "dentry->d_inode"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ino->dentry"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&p_ino->count"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry->d_parent"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ino->count"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_clear_leaf_automount_flags",
          "args": [
            "dentry"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_clear_leaf_automount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "670-691",
          "snippet": "static void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct list_head *d_child;\n\tstruct dentry *parent;\n\n\t/* flags for dentrys in the root are handled elsewhere */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_clear_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\td_child = &dentry->d_child;\n\t/* Set parent managed if it's becoming empty */\n\tif (d_child->next == &parent->d_subdirs &&\n\t    d_child->prev == &parent->d_subdirs)\n\t\tmanaged_dentry_set_managed(parent);\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct list_head *d_child;\n\tstruct dentry *parent;\n\n\t/* flags for dentrys in the root are handled elsewhere */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_clear_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\td_child = &dentry->d_child;\n\t/* Set parent managed if it's becoming empty */\n\tif (d_child->next == &parent->d_subdirs &&\n\t    d_child->prev == &parent->d_subdirs)\n\t\tmanaged_dentry_set_managed(parent);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__autofs4_add_expiring",
          "args": [
            "dentry"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__autofs4_add_expiring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "246-255",
          "snippet": "static inline void __autofs4_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_clean_ino(struct autofs_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_clean_ino(struct autofs_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline void __autofs4_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry %p, removing %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dir->i_sb"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_dir_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\t\n\tDPRINTK(\"dentry %p, removing %pd\", dentry, dentry);\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tspin_lock(&sbi->lookup_lock);\n\tif (!simple_empty(dentry)) {\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\treturn -ENOTEMPTY;\n\t}\n\t__autofs4_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tif (sbi->version < 5)\n\t\tautofs_clear_leaf_automount_flags(dentry);\n\n\tif (atomic_dec_and_test(&ino->count)) {\n\t\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\t\tif (p_ino && dentry->d_parent != dentry)\n\t\t\tatomic_dec(&p_ino->count);\n\t}\n\tdput(ino->dentry);\n\tdentry->d_inode->i_size = 0;\n\tclear_nlink(dentry->d_inode);\n\n\tif (dir->i_nlink)\n\t\tdrop_nlink(dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_clear_leaf_automount_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "670-691",
    "snippet": "static void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct list_head *d_child;\n\tstruct dentry *parent;\n\n\t/* flags for dentrys in the root are handled elsewhere */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_clear_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\td_child = &dentry->d_child;\n\t/* Set parent managed if it's becoming empty */\n\tif (d_child->next == &parent->d_subdirs &&\n\t    d_child->prev == &parent->d_subdirs)\n\t\tmanaged_dentry_set_managed(parent);\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "managed_dentry_set_managed",
          "args": [
            "parent"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "managed_dentry_set_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "189-194",
          "snippet": "static inline void managed_dentry_set_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_set_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void managed_dentry_set_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_set_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "parent->d_parent"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_dentry_clear_managed",
          "args": [
            "dentry"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "managed_dentry_clear_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "201-206",
          "snippet": "static inline void managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_clear_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_clear_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry->d_parent"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct list_head *d_child;\n\tstruct dentry *parent;\n\n\t/* flags for dentrys in the root are handled elsewhere */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_clear_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\td_child = &dentry->d_child;\n\t/* Set parent managed if it's becoming empty */\n\tif (d_child->next == &parent->d_subdirs &&\n\t    d_child->prev == &parent->d_subdirs)\n\t\tmanaged_dentry_set_managed(parent);\n\treturn;\n}"
  },
  {
    "function_name": "autofs_set_leaf_automount_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "652-668",
    "snippet": "static void autofs_set_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t/* root and dentrys in the root are already handled */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_set_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tmanaged_dentry_clear_managed(parent);\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "managed_dentry_clear_managed",
          "args": [
            "parent"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "managed_dentry_clear_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "201-206",
          "snippet": "static inline void managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_clear_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_clear_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "parent->d_parent"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_dentry_set_managed",
          "args": [
            "dentry"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "managed_dentry_set_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "189-194",
          "snippet": "static inline void managed_dentry_set_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_set_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void managed_dentry_set_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_set_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry->d_parent"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs_set_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t/* root and dentrys in the root are already handled */\n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_set_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t/* only consider parents below dentrys in the root */\n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tmanaged_dentry_clear_managed(parent);\n\treturn;\n}"
  },
  {
    "function_name": "autofs4_dir_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "611-639",
    "snippet": "static int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\t\n\t/* This allows root to remove symlinks */\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_dec_and_test(&ino->count)) {\n\t\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\t\tif (p_ino && !IS_ROOT(dentry))\n\t\t\tatomic_dec(&p_ino->count);\n\t}\n\tdput(ino->dentry);\n\n\tdentry->d_inode->i_size = 0;\n\tclear_nlink(dentry->d_inode);\n\n\tdir->i_mtime = CURRENT_TIME;\n\n\tspin_lock(&sbi->lookup_lock);\n\t__autofs4_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__autofs4_add_expiring",
          "args": [
            "dentry"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__autofs4_add_expiring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "246-255",
          "snippet": "static inline void __autofs4_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_clean_ino(struct autofs_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_clean_ino(struct autofs_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline void __autofs4_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "dentry->d_inode"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ino->dentry"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&p_ino->count"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry->d_parent"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ino->count"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dir->i_sb"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\t\n\t/* This allows root to remove symlinks */\n\tif (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_dec_and_test(&ino->count)) {\n\t\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\t\tif (p_ino && !IS_ROOT(dentry))\n\t\t\tatomic_dec(&p_ino->count);\n\t}\n\tdput(ino->dentry);\n\n\tdentry->d_inode->i_size = 0;\n\tclear_nlink(dentry->d_inode);\n\n\tdir->i_mtime = CURRENT_TIME;\n\n\tspin_lock(&sbi->lookup_lock);\n\t__autofs4_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_dir_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "546-594",
    "snippet": "static int autofs4_dir_symlink(struct inode *dir, \n\t\t\t       struct dentry *dentry,\n\t\t\t       const char *symname)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\tsize_t size = strlen(symname);\n\tchar *cp;\n\n\tDPRINTK(\"%s <- %pd\", symname, dentry);\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tBUG_ON(!ino);\n\n\tautofs4_clean_ino(ino);\n\n\tautofs4_del_active(dentry);\n\n\tcp = kmalloc(size + 1, GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tstrcpy(cp, symname);\n\n\tinode = autofs4_get_inode(dir->i_sb, S_IFLNK | 0555);\n\tif (!inode) {\n\t\tkfree(cp);\n\t\tif (!dentry->d_fsdata)\n\t\t\tkfree(ino);\n\t\treturn -ENOMEM;\n\t}\n\tinode->i_private = cp;\n\tinode->i_size = size;\n\td_add(dentry, inode);\n\n\tdget(dentry);\n\tatomic_inc(&ino->count);\n\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\tif (p_ino && !IS_ROOT(dentry))\n\t\tatomic_inc(&p_ino->count);\n\n\tdir->i_mtime = CURRENT_TIME;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&p_ino->count"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry->d_parent"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ino->count"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ino"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_get_inode",
          "args": [
            "dir->i_sb",
            "S_IFLNK | 0555"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "346-370",
          "snippet": "struct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct inode *autofs4_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = sb->s_root->d_inode->i_uid;\n\t\tinode->i_gid = sb->s_root->d_inode->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs4_dir_inode_operations;\n\t\tinode->i_fop = &autofs4_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs4_symlink_inode_operations;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cp",
            "symname"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_del_active",
          "args": [
            "dentry"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_del_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "90-104",
          "snippet": "static void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_clean_ino",
          "args": [
            "ino"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_clean_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "37-42",
          "snippet": "void autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ino"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"%s <- %pd\"",
            "symname",
            "dentry"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dir->i_sb"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_dir_symlink(struct inode *dir, \n\t\t\t       struct dentry *dentry,\n\t\t\t       const char *symname)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\tsize_t size = strlen(symname);\n\tchar *cp;\n\n\tDPRINTK(\"%s <- %pd\", symname, dentry);\n\n\tif (!autofs4_oz_mode(sbi))\n\t\treturn -EACCES;\n\n\tBUG_ON(!ino);\n\n\tautofs4_clean_ino(ino);\n\n\tautofs4_del_active(dentry);\n\n\tcp = kmalloc(size + 1, GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tstrcpy(cp, symname);\n\n\tinode = autofs4_get_inode(dir->i_sb, S_IFLNK | 0555);\n\tif (!inode) {\n\t\tkfree(cp);\n\t\tif (!dentry->d_fsdata)\n\t\t\tkfree(ino);\n\t\treturn -ENOMEM;\n\t}\n\tinode->i_private = cp;\n\tinode->i_size = size;\n\td_add(dentry, inode);\n\n\tdget(dentry);\n\tatomic_inc(&ino->count);\n\tp_ino = autofs4_dentry_ino(dentry->d_parent);\n\tif (p_ino && !IS_ROOT(dentry))\n\t\tatomic_inc(&p_ino->count);\n\n\tdir->i_mtime = CURRENT_TIME;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "497-544",
    "snippet": "static struct dentry *autofs4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tstruct dentry *active;\n\n\tDPRINTK(\"name = %pd\", dentry);\n\n\t/* File name too long to exist */\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tsbi = autofs4_sbi(dir->i_sb);\n\n\tDPRINTK(\"pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\",\n\t\tcurrent->pid, task_pgrp_nr(current), sbi->catatonic,\n\t\tautofs4_oz_mode(sbi));\n\n\tactive = autofs4_lookup_active(dentry);\n\tif (active) {\n\t\treturn active;\n\t} else {\n\t\t/*\n\t\t * A dentry that is not within the root can never trigger a\n\t\t * mount operation, unless the directory already exists, so we\n\t\t * can return fail immediately.  The daemon however does need\n\t\t * to create directories within the file system.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) && !IS_ROOT(dentry->d_parent))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* Mark entries in the root as mount triggers */\n\t\tif (autofs_type_indirect(sbi->type) && IS_ROOT(dentry->d_parent))\n\t\t\t__managed_dentry_set_managed(dentry);\n\n\t\tino = autofs4_new_ino(sbi);\n\t\tif (!ino)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tdentry->d_fsdata = ino;\n\t\tino->dentry = dentry;\n\n\t\tautofs4_add_active(dentry);\n\n\t\td_instantiate(dentry, NULL);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
      "static int autofs4_dir_open(struct inode *inode, struct file *file);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_add_active",
          "args": [
            "dentry"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_add_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "74-88",
          "snippet": "static void autofs4_add_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!ino->active_count) {\n\t\t\tif (list_empty(&ino->active))\n\t\t\t\tlist_add(&ino->active, &sbi->active_list);\n\t\t}\n\t\tino->active_count++;\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_add_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!ino->active_count) {\n\t\t\tif (list_empty(&ino->active))\n\t\t\t\tlist_add(&ino->active, &sbi->active_list);\n\t\t}\n\t\tino->active_count++;\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_new_ino",
          "args": [
            "sbi"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_new_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "25-35",
          "snippet": "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t}\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__managed_dentry_set_managed",
          "args": [
            "dentry"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "__managed_dentry_set_managed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "184-187",
          "snippet": "static inline void __managed_dentry_set_managed(struct dentry *dentry)\n{\n\tdentry->d_flags |= (DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline void __managed_dentry_set_managed(struct dentry *dentry)\n{\n\tdentry->d_flags |= (DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry->d_parent"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_indirect",
          "args": [
            "sbi->type"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry->d_parent"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_lookup_active",
          "args": [
            "dentry"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_lookup_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "158-210",
          "snippet": "static struct dentry *autofs4_lookup_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->active_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *active;\n\t\tstruct qstr *qstr;\n\n\t\tino = list_entry(p, struct autofs_info, active);\n\t\tactive = ino->dentry;\n\n\t\tspin_lock(&active->d_lock);\n\n\t\t/* Already gone? */\n\t\tif ((int) d_count(active) <= 0)\n\t\t\tgoto next;\n\n\t\tqstr = &active->d_name;\n\n\t\tif (active->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (active->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(active)) {\n\t\t\tdget_dlock(active);\n\t\t\tspin_unlock(&active->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn active;\n\t\t}\nnext:\n\t\tspin_unlock(&active->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_lookup_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->active_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *active;\n\t\tstruct qstr *qstr;\n\n\t\tino = list_entry(p, struct autofs_info, active);\n\t\tactive = ino->dentry;\n\n\t\tspin_lock(&active->d_lock);\n\n\t\t/* Already gone? */\n\t\tif ((int) d_count(active) <= 0)\n\t\t\tgoto next;\n\n\t\tqstr = &active->d_name;\n\n\t\tif (active->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (active->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(active)) {\n\t\t\tdget_dlock(active);\n\t\t\tspin_unlock(&active->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn active;\n\t\t}\nnext:\n\t\tspin_unlock(&active->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\"",
            "current->pid",
            "task_pgrp_nr(current)",
            "sbi->catatonic",
            "autofs4_oz_mode(sbi)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_nr",
          "args": [
            "current"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dir->i_sb"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"name = %pd\"",
            "dentry"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tstruct dentry *active;\n\n\tDPRINTK(\"name = %pd\", dentry);\n\n\t/* File name too long to exist */\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tsbi = autofs4_sbi(dir->i_sb);\n\n\tDPRINTK(\"pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\",\n\t\tcurrent->pid, task_pgrp_nr(current), sbi->catatonic,\n\t\tautofs4_oz_mode(sbi));\n\n\tactive = autofs4_lookup_active(dentry);\n\tif (active) {\n\t\treturn active;\n\t} else {\n\t\t/*\n\t\t * A dentry that is not within the root can never trigger a\n\t\t * mount operation, unless the directory already exists, so we\n\t\t * can return fail immediately.  The daemon however does need\n\t\t * to create directories within the file system.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) && !IS_ROOT(dentry->d_parent))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t/* Mark entries in the root as mount triggers */\n\t\tif (autofs_type_indirect(sbi->type) && IS_ROOT(dentry->d_parent))\n\t\t\t__managed_dentry_set_managed(dentry);\n\n\t\tino = autofs4_new_ino(sbi);\n\t\tif (!ino)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tdentry->d_fsdata = ino;\n\t\tino->dentry = dentry;\n\n\t\tautofs4_add_active(dentry);\n\n\t\td_instantiate(dentry, NULL);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_d_manage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "422-494",
    "snippet": "static int autofs4_d_manage(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\tDPRINTK(\"dentry=%p %pd\", dentry, dentry);\n\n\t/* The daemon never waits. */\n\tif (autofs4_oz_mode(sbi)) {\n\t\tif (!d_mountpoint(dentry))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\t/* Wait for pending expires */\n\tif (do_expire_wait(dentry, rcu_walk) == -ECHILD)\n\t\treturn -ECHILD;\n\n\t/*\n\t * This dentry may be under construction so wait on mount\n\t * completion.\n\t */\n\tstatus = autofs4_mount_wait(dentry, rcu_walk);\n\tif (status)\n\t\treturn status;\n\n\tif (rcu_walk) {\n\t\t/* We don't need fs_lock in rcu_walk mode,\n\t\t * just testing 'AUTOFS_INFO_NO_RCU' is enough.\n\t\t * simple_empty() takes a spinlock, so leave it\n\t\t * to last.\n\t\t * We only return -EISDIR when certain this isn't\n\t\t * a mount-trap.\n\t\t */\n\t\tstruct inode *inode;\n\t\tif (ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))\n\t\t\treturn 0;\n\t\tif (d_mountpoint(dentry))\n\t\t\treturn 0;\n\t\tinode = ACCESS_ONCE(dentry->d_inode);\n\t\tif (inode && S_ISLNK(inode->i_mode))\n\t\t\treturn -EISDIR;\n\t\tif (list_empty(&dentry->d_subdirs))\n\t\t\treturn 0;\n\t\tif (!simple_empty(dentry))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\tspin_lock(&sbi->fs_lock);\n\t/*\n\t * If the dentry has been selected for expire while we slept\n\t * on the lock then it might go away. We'll deal with that in\n\t * ->d_automount() and wait on a new mount if the expire\n\t * succeeds or return here if it doesn't (since there's no\n\t * mount to follow with a rootless multi-mount).\n\t */\n\tif (!(ino->flags & AUTOFS_INF_EXPIRING)) {\n\t\t/*\n\t\t * Any needed mounting has been completed and the path\n\t\t * updated so check if this is a rootless multi-mount so\n\t\t * we can avoid needless calls ->d_automount() and avoid\n\t\t * an incorrect ELOOP error return.\n\t\t */\n\t\tif ((!d_mountpoint(dentry) && !simple_empty(dentry)) ||\n\t\t    (dentry->d_inode && d_is_symlink(dentry)))\n\t\t\tstatus = -EISDIR;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn status;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static struct vfsmount *autofs4_d_automount(struct path *);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dentry->d_subdirs"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_mount_wait",
          "args": [
            "dentry",
            "rcu_walk"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mount_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "272-287",
          "snippet": "static int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_expire_wait",
          "args": [
            "dentry",
            "rcu_walk"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "do_expire_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "289-309",
          "snippet": "static int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry=%p %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic struct vfsmount *autofs4_d_automount(struct path *);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_d_manage(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\tDPRINTK(\"dentry=%p %pd\", dentry, dentry);\n\n\t/* The daemon never waits. */\n\tif (autofs4_oz_mode(sbi)) {\n\t\tif (!d_mountpoint(dentry))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\t/* Wait for pending expires */\n\tif (do_expire_wait(dentry, rcu_walk) == -ECHILD)\n\t\treturn -ECHILD;\n\n\t/*\n\t * This dentry may be under construction so wait on mount\n\t * completion.\n\t */\n\tstatus = autofs4_mount_wait(dentry, rcu_walk);\n\tif (status)\n\t\treturn status;\n\n\tif (rcu_walk) {\n\t\t/* We don't need fs_lock in rcu_walk mode,\n\t\t * just testing 'AUTOFS_INFO_NO_RCU' is enough.\n\t\t * simple_empty() takes a spinlock, so leave it\n\t\t * to last.\n\t\t * We only return -EISDIR when certain this isn't\n\t\t * a mount-trap.\n\t\t */\n\t\tstruct inode *inode;\n\t\tif (ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))\n\t\t\treturn 0;\n\t\tif (d_mountpoint(dentry))\n\t\t\treturn 0;\n\t\tinode = ACCESS_ONCE(dentry->d_inode);\n\t\tif (inode && S_ISLNK(inode->i_mode))\n\t\t\treturn -EISDIR;\n\t\tif (list_empty(&dentry->d_subdirs))\n\t\t\treturn 0;\n\t\tif (!simple_empty(dentry))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\tspin_lock(&sbi->fs_lock);\n\t/*\n\t * If the dentry has been selected for expire while we slept\n\t * on the lock then it might go away. We'll deal with that in\n\t * ->d_automount() and wait on a new mount if the expire\n\t * succeeds or return here if it doesn't (since there's no\n\t * mount to follow with a rootless multi-mount).\n\t */\n\tif (!(ino->flags & AUTOFS_INF_EXPIRING)) {\n\t\t/*\n\t\t * Any needed mounting has been completed and the path\n\t\t * updated so check if this is a rootless multi-mount so\n\t\t * we can avoid needless calls ->d_automount() and avoid\n\t\t * an incorrect ELOOP error return.\n\t\t */\n\t\tif ((!d_mountpoint(dentry) && !simple_empty(dentry)) ||\n\t\t    (dentry->d_inode && d_is_symlink(dentry)))\n\t\t\tstatus = -EISDIR;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn status;\n}"
  },
  {
    "function_name": "autofs4_d_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "334-420",
    "snippet": "static struct vfsmount *autofs4_d_automount(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\tDPRINTK(\"dentry=%p %pd\", dentry, dentry);\n\n\t/* The daemon never triggers a mount. */\n\tif (autofs4_oz_mode(sbi))\n\t\treturn NULL;\n\n\t/*\n\t * If an expire request is pending everyone must wait.\n\t * If the expire fails we're still mounted so continue\n\t * the follow and return. A return of -EAGAIN (which only\n\t * happens with indirect mounts) means the expire completed\n\t * and the directory was removed, so just go ahead and try\n\t * the mount.\n\t */\n\tstatus = do_expire_wait(dentry, 0);\n\tif (status && status != -EAGAIN)\n\t\treturn NULL;\n\n\t/* Callback to the daemon to perform the mount or wait */\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs4_mount_wait(dentry, 0);\n\t\tif (status)\n\t\t\treturn ERR_PTR(status);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * If the dentry is a symlink it's equivalent to a directory\n\t * having d_mountpoint() true, so there's no need to call back\n\t * to the daemon.\n\t */\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tgoto done;\n\t}\n\n\tif (!d_mountpoint(dentry)) {\n\t\t/*\n\t\t * It's possible that user space hasn't removed directories\n\t\t * after umounting a rootless multi-mount, although it\n\t\t * should. For v5 have_submounts() is sufficient to handle\n\t\t * this because the leaves of the directory tree under the\n\t\t * mount never trigger mounts themselves (they have an autofs\n\t\t * trigger mount mounted on them). But v4 pseudo direct mounts\n\t\t * do need the leaves to trigger mounts. In this case we\n\t\t * have no choice but to use the list_empty() check and\n\t\t * require user space behave.\n\t\t */\n\t\tif (sbi->version > 4) {\n\t\t\tif (have_submounts(dentry)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!simple_empty(dentry)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tino->flags |= AUTOFS_INF_PENDING;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs4_mount_wait(dentry, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino->flags &= ~AUTOFS_INF_PENDING;\n\t\tif (status) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn ERR_PTR(status);\n\t\t}\n\t}\n\tspin_unlock(&sbi->fs_lock);\ndone:\n\t/* Mount succeeded, check if we ended up with a new dentry */\n\tdentry = autofs4_mountpoint_changed(path);\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static struct vfsmount *autofs4_d_automount(struct path *);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_mountpoint_changed",
          "args": [
            "path"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mountpoint_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "311-332",
          "snippet": "static struct dentry *autofs4_mountpoint_changed(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\t/*\n\t * If this is an indirect mount the dentry could have gone away\n\t * as a result of an expire and a new one created.\n\t */\n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *new = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tino = autofs4_dentry_ino(new);\n\t\tino->last_used = jiffies;\n\t\tdput(path->dentry);\n\t\tpath->dentry = new;\n\t}\n\treturn path->dentry;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static struct vfsmount *autofs4_d_automount(struct path *);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic struct vfsmount *autofs4_d_automount(struct path *);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_mountpoint_changed(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\t/*\n\t * If this is an indirect mount the dentry could have gone away\n\t * as a result of an expire and a new one created.\n\t */\n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *new = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tino = autofs4_dentry_ino(new);\n\t\tino->last_used = jiffies;\n\t\tdput(path->dentry);\n\t\tpath->dentry = new;\n\t}\n\treturn path->dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_mount_wait",
          "args": [
            "dentry",
            "0"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mount_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "272-287",
          "snippet": "static int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_submounts",
          "args": [
            "dentry"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "have_submounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1262-1269",
          "snippet": "int have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_expire_wait",
          "args": [
            "dentry",
            "0"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "do_expire_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "289-309",
          "snippet": "static int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry=%p %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic struct vfsmount *autofs4_d_automount(struct path *);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct vfsmount *autofs4_d_automount(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\tDPRINTK(\"dentry=%p %pd\", dentry, dentry);\n\n\t/* The daemon never triggers a mount. */\n\tif (autofs4_oz_mode(sbi))\n\t\treturn NULL;\n\n\t/*\n\t * If an expire request is pending everyone must wait.\n\t * If the expire fails we're still mounted so continue\n\t * the follow and return. A return of -EAGAIN (which only\n\t * happens with indirect mounts) means the expire completed\n\t * and the directory was removed, so just go ahead and try\n\t * the mount.\n\t */\n\tstatus = do_expire_wait(dentry, 0);\n\tif (status && status != -EAGAIN)\n\t\treturn NULL;\n\n\t/* Callback to the daemon to perform the mount or wait */\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs4_mount_wait(dentry, 0);\n\t\tif (status)\n\t\t\treturn ERR_PTR(status);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * If the dentry is a symlink it's equivalent to a directory\n\t * having d_mountpoint() true, so there's no need to call back\n\t * to the daemon.\n\t */\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tgoto done;\n\t}\n\n\tif (!d_mountpoint(dentry)) {\n\t\t/*\n\t\t * It's possible that user space hasn't removed directories\n\t\t * after umounting a rootless multi-mount, although it\n\t\t * should. For v5 have_submounts() is sufficient to handle\n\t\t * this because the leaves of the directory tree under the\n\t\t * mount never trigger mounts themselves (they have an autofs\n\t\t * trigger mount mounted on them). But v4 pseudo direct mounts\n\t\t * do need the leaves to trigger mounts. In this case we\n\t\t * have no choice but to use the list_empty() check and\n\t\t * require user space behave.\n\t\t */\n\t\tif (sbi->version > 4) {\n\t\t\tif (have_submounts(dentry)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!simple_empty(dentry)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tino->flags |= AUTOFS_INF_PENDING;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs4_mount_wait(dentry, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino->flags &= ~AUTOFS_INF_PENDING;\n\t\tif (status) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn ERR_PTR(status);\n\t\t}\n\t}\n\tspin_unlock(&sbi->fs_lock);\ndone:\n\t/* Mount succeeded, check if we ended up with a new dentry */\n\tdentry = autofs4_mountpoint_changed(path);\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_mountpoint_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "311-332",
    "snippet": "static struct dentry *autofs4_mountpoint_changed(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\t/*\n\t * If this is an indirect mount the dentry could have gone away\n\t * as a result of an expire and a new one created.\n\t */\n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *new = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tino = autofs4_dentry_ino(new);\n\t\tino->last_used = jiffies;\n\t\tdput(path->dentry);\n\t\tpath->dentry = new;\n\t}\n\treturn path->dentry;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static struct vfsmount *autofs4_d_automount(struct path *);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "new"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&dentry->d_name"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_indirect",
          "args": [
            "sbi->type"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic struct vfsmount *autofs4_d_automount(struct path *);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_mountpoint_changed(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\t/*\n\t * If this is an indirect mount the dentry could have gone away\n\t * as a result of an expire and a new one created.\n\t */\n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *new = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tino = autofs4_dentry_ino(new);\n\t\tino->last_used = jiffies;\n\t\tdput(path->dentry);\n\t\tpath->dentry = new;\n\t}\n\treturn path->dentry;\n}"
  },
  {
    "function_name": "do_expire_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "289-309",
    "snippet": "static int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "expiring"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_del_expiring",
          "args": [
            "expiring"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_del_expiring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "270-281",
          "snippet": "static inline void autofs4_del_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del_init(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_clean_ino(struct autofs_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_clean_ino(struct autofs_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline void autofs4_del_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del_init(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_expire_wait",
          "args": [
            "expiring",
            "0"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "490-521",
          "snippet": "int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nint autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "expiring"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "expiring"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_lookup_expiring",
          "args": [
            "dentry",
            "rcu_walk"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_lookup_expiring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "212-270",
          "snippet": "static struct dentry *autofs4_lookup_expiring(struct dentry *dentry,\n\t\t\t\t\t      bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->expiring_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *expiring;\n\t\tstruct qstr *qstr;\n\n\t\tif (rcu_walk) {\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\n\t\tino = list_entry(p, struct autofs_info, expiring);\n\t\texpiring = ino->dentry;\n\n\t\tspin_lock(&expiring->d_lock);\n\n\t\t/* We've already been dentry_iput or unlinked */\n\t\tif (!expiring->d_inode)\n\t\t\tgoto next;\n\n\t\tqstr = &expiring->d_name;\n\n\t\tif (expiring->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (expiring->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(expiring)) {\n\t\t\tdget_dlock(expiring);\n\t\t\tspin_unlock(&expiring->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn expiring;\n\t\t}\nnext:\n\t\tspin_unlock(&expiring->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_lookup_expiring(struct dentry *dentry,\n\t\t\t\t\t      bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->expiring_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *expiring;\n\t\tstruct qstr *qstr;\n\n\t\tif (rcu_walk) {\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\n\t\tino = list_entry(p, struct autofs_info, expiring);\n\t\texpiring = ino->dentry;\n\n\t\tspin_lock(&expiring->d_lock);\n\n\t\t/* We've already been dentry_iput or unlinked */\n\t\tif (!expiring->d_inode)\n\t\t\tgoto next;\n\n\t\tqstr = &expiring->d_name;\n\n\t\tif (expiring->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (expiring->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(expiring)) {\n\t\t\tdget_dlock(expiring);\n\t\t\tspin_unlock(&expiring->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn expiring;\n\t\t}\nnext:\n\t\tspin_unlock(&expiring->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int do_expire_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct dentry *expiring;\n\n\texpiring = autofs4_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs4_expire_wait(dentry, rcu_walk);\n\telse {\n\t\t/*\n\t\t * If we are racing with expire the request might not\n\t\t * be quite complete, but the directory has been removed\n\t\t * so it must have been successful, just wait for it.\n\t\t */\n\t\tautofs4_expire_wait(expiring, 0);\n\t\tautofs4_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_mount_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "272-287",
    "snippet": "static int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"mount wait done status=%d\"",
            "status"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_wait",
          "args": [
            "sbi",
            "dentry",
            "NFY_MOUNT"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"waiting for mount name=%pd\"",
            "dentry"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_mount_wait(struct dentry *dentry, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tDPRINTK(\"waiting for mount name=%pd\", dentry);\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_MOUNT);\n\t\tDPRINTK(\"mount wait done status=%d\", status);\n\t}\n\tino->last_used = jiffies;\n\treturn status;\n}"
  },
  {
    "function_name": "autofs4_lookup_expiring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "212-270",
    "snippet": "static struct dentry *autofs4_lookup_expiring(struct dentry *dentry,\n\t\t\t\t\t      bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->expiring_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *expiring;\n\t\tstruct qstr *qstr;\n\n\t\tif (rcu_walk) {\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\n\t\tino = list_entry(p, struct autofs_info, expiring);\n\t\texpiring = ino->dentry;\n\n\t\tspin_lock(&expiring->d_lock);\n\n\t\t/* We've already been dentry_iput or unlinked */\n\t\tif (!expiring->d_inode)\n\t\t\tgoto next;\n\n\t\tqstr = &expiring->d_name;\n\n\t\tif (expiring->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (expiring->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(expiring)) {\n\t\t\tdget_dlock(expiring);\n\t\t\tspin_unlock(&expiring->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn expiring;\n\t\t}\nnext:\n\t\tspin_unlock(&expiring->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "expiring"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "expiring"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "qstr->name",
            "str",
            "len"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&expiring->d_lock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structautofs_info",
            "expiring"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ECHILD"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "p",
            "head"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_lookup_expiring(struct dentry *dentry,\n\t\t\t\t\t      bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->expiring_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *expiring;\n\t\tstruct qstr *qstr;\n\n\t\tif (rcu_walk) {\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\n\t\tino = list_entry(p, struct autofs_info, expiring);\n\t\texpiring = ino->dentry;\n\n\t\tspin_lock(&expiring->d_lock);\n\n\t\t/* We've already been dentry_iput or unlinked */\n\t\tif (!expiring->d_inode)\n\t\t\tgoto next;\n\n\t\tqstr = &expiring->d_name;\n\n\t\tif (expiring->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (expiring->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(expiring)) {\n\t\t\tdget_dlock(expiring);\n\t\t\tspin_unlock(&expiring->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn expiring;\n\t\t}\nnext:\n\t\tspin_unlock(&expiring->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_lookup_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "158-210",
    "snippet": "static struct dentry *autofs4_lookup_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->active_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *active;\n\t\tstruct qstr *qstr;\n\n\t\tino = list_entry(p, struct autofs_info, active);\n\t\tactive = ino->dentry;\n\n\t\tspin_lock(&active->d_lock);\n\n\t\t/* Already gone? */\n\t\tif ((int) d_count(active) <= 0)\n\t\t\tgoto next;\n\n\t\tqstr = &active->d_name;\n\n\t\tif (active->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (active->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(active)) {\n\t\t\tdget_dlock(active);\n\t\t\tspin_unlock(&active->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn active;\n\t\t}\nnext:\n\t\tspin_unlock(&active->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "active"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "active"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "qstr->name",
            "str",
            "len"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "active"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&active->d_lock"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structautofs_info",
            "active"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "p",
            "head"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic struct dentry *autofs4_lookup_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tstruct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->active_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *active;\n\t\tstruct qstr *qstr;\n\n\t\tino = list_entry(p, struct autofs_info, active);\n\t\tactive = ino->dentry;\n\n\t\tspin_lock(&active->d_lock);\n\n\t\t/* Already gone? */\n\t\tif ((int) d_count(active) <= 0)\n\t\t\tgoto next;\n\n\t\tqstr = &active->d_name;\n\n\t\tif (active->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (active->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(active)) {\n\t\t\tdget_dlock(active);\n\t\t\tspin_unlock(&active->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn active;\n\t\t}\nnext:\n\t\tspin_unlock(&active->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_dentry_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "136-156",
    "snippet": "static void autofs4_dentry_release(struct dentry *de)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(de);\n\tstruct autofs_sb_info *sbi = autofs4_sbi(de->d_sb);\n\n\tDPRINTK(\"releasing %p\", de);\n\n\tif (!ino)\n\t\treturn;\n\n\tif (sbi) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->active))\n\t\t\tlist_del(&ino->active);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\n\tautofs4_free_ino(ino);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_free_ino",
          "args": [
            "ino"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_free_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/inode.c",
          "lines": "44-47",
          "snippet": "void autofs4_free_ino(struct autofs_info *ino)\n{\n\tkfree(ino);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include \"autofs_i.h\"",
            "#include <linux/magic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include \"autofs_i.h\"\n#include <linux/magic.h>\n#include <linux/bitops.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid autofs4_free_ino(struct autofs_info *ino)\n{\n\tkfree(ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ino->expiring"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ino->expiring"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"releasing %p\"",
            "de"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "de->d_sb"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "de"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_dentry_release(struct dentry *de)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(de);\n\tstruct autofs_sb_info *sbi = autofs4_sbi(de->d_sb);\n\n\tDPRINTK(\"releasing %p\", de);\n\n\tif (!ino)\n\t\treturn;\n\n\tif (sbi) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->active))\n\t\t\tlist_del(&ino->active);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\n\tautofs4_free_ino(ino);\n}"
  },
  {
    "function_name": "autofs4_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "106-134",
    "snippet": "static int autofs4_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\tDPRINTK(\"file=%p dentry=%p %pd\", file, dentry, dentry);\n\n\tif (autofs4_oz_mode(sbi))\n\t\tgoto out;\n\n\t/*\n\t * An empty directory in an autofs file system is always a\n\t * mount point. The daemon must have failed to mount this\n\t * during lookup so it doesn't exist. This can happen, for\n\t * example, if user space returns an incorrect status for a\n\t * mount request. Otherwise we're doing a readdir on the\n\t * autofs file system so just let the libfs routines handle\n\t * it.\n\t */\n\tspin_lock(&sbi->lookup_lock);\n\tif (!d_mountpoint(dentry) && simple_empty(dentry)) {\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\nout:\n\treturn dcache_dir_open(inode, file);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);",
      "static int autofs4_dir_open(struct inode *inode, struct file *file);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dcache_dir_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dcache_dir_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "77-84",
          "snippet": "int dcache_dir_open(struct inode *inode, struct file *file)\n{\n\tstatic struct qstr cursor_name = QSTR_INIT(\".\", 1);\n\n\tfile->private_data = d_alloc(file->f_path.dentry, &cursor_name);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint dcache_dir_open(struct inode *inode, struct file *file)\n{\n\tstatic struct qstr cursor_name = QSTR_INIT(\".\", 1);\n\n\tfile->private_data = d_alloc(file->f_path.dentry, &cursor_name);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"file=%p dentry=%p %pd\"",
            "file",
            "dentry",
            "dentry"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic long autofs4_root_ioctl(struct file *,unsigned int,unsigned long);\nstatic int autofs4_dir_open(struct inode *inode, struct file *file);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic int autofs4_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\tDPRINTK(\"file=%p dentry=%p %pd\", file, dentry, dentry);\n\n\tif (autofs4_oz_mode(sbi))\n\t\tgoto out;\n\n\t/*\n\t * An empty directory in an autofs file system is always a\n\t * mount point. The daemon must have failed to mount this\n\t * during lookup so it doesn't exist. This can happen, for\n\t * example, if user space returns an incorrect status for a\n\t * mount request. Otherwise we're doing a readdir on the\n\t * autofs file system so just let the libfs routines handle\n\t * it.\n\t */\n\tspin_lock(&sbi->lookup_lock);\n\tif (!d_mountpoint(dentry) && simple_empty(dentry)) {\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\nout:\n\treturn dcache_dir_open(inode, file);\n}"
  },
  {
    "function_name": "autofs4_del_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "90-104",
    "snippet": "static void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ino->active"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ino->active"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tino->active_count--;\n\t\tif (!ino->active_count) {\n\t\t\tif (!list_empty(&ino->active))\n\t\t\t\tlist_del_init(&ino->active);\n\t\t}\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "autofs4_add_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
    "lines": "74-88",
    "snippet": "static void autofs4_add_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!ino->active_count) {\n\t\t\tif (list_empty(&ino->active))\n\t\t\t\tlist_add(&ino->active, &sbi->active_list);\n\t\t}\n\t\tino->active_count++;\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/param.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
      "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
      "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
      "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
      "static int autofs4_d_manage(struct dentry *, bool);",
      "static void autofs4_dentry_release(struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ino->active",
            "&sbi->active_list"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ino->active"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\n\nstatic void autofs4_add_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!ino->active_count) {\n\t\t\tif (list_empty(&ino->active))\n\t\t\t\tlist_add(&ino->active, &sbi->active_list);\n\t\t}\n\t\tino->active_count++;\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\treturn;\n}"
  }
]